<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Daedalus 3.4 Documentation</title>

<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:2 2 6 3 4 5 5 2 3 4;}
@font-face
	{font-family:Helv;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:"New York";
	panose-1:2 4 5 3 6 5 6 2 3 4;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 1 6 1 0 1 1 1 1 1;}
@font-face
	{font-family:"MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimHei;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:MingLiU;
	panose-1:2 1 6 9 0 1 1 1 1 1;}
@font-face
	{font-family:Mincho;
	panose-1:2 2 6 9 4 3 5 8 3 5;}
@font-face
	{font-family:Gulim;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:Century;
	panose-1:2 4 6 4 5 5 5 2 3 4;}
@font-face
	{font-family:"Angsana New";
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"Cordia New";
	panose-1:2 11 3 4 2 2 2 2 2 4;}
@font-face
	{font-family:Mangal;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Latha;
	panose-1:2 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sylfaen;
	panose-1:1 10 5 2 5 3 6 3 3 3;}
@font-face
	{font-family:Vrinda;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Raavi;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Shruti;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sendnya;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Gautami;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tunga;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Estrangelo Edessa";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
h1
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Arial","sans-serif";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.A, li.A, div.A
	{mso-style-name:A;
	mso-style-link:"A Char Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
span.ACharChar
	{mso-style-name:"A Char Char";
	mso-style-link:A;}
p.Fixed, li.Fixed, div.Fixed
	{mso-style-name:Fixed;
	margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Courier New";}
p.Section, li.Section, div.Section
	{mso-style-name:Section;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	text-align:center;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:16.0pt;
	font-family:"Arial","sans-serif";
	font-weight:bold;}
p.Item, li.Item, div.Item
	{mso-style-name:Item;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.B, li.B, div.B
	{mso-style-name:B;
	mso-style-link:"B Char Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
span.BCharChar
	{mso-style-name:"B Char Char";
	mso-style-link:B;}
p.C, li.C, div.C
	{mso-style-name:C;
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:1.0in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
span.O
	{mso-style-name:O;
	color:green;
	font-weight:bold;}
span.P
	{mso-style-name:P;
	color:olive;
	font-weight:bold;}
span.N
	{mso-style-name:N;
	color:blue;
	font-weight:bold;}
p.Section2, li.Section2, div.Section2
	{mso-style-name:Section2;
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Courier New";
	color:red;
	font-weight:bold;}
p.D, li.D, div.D
	{mso-style-name:D;
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:1.5in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
span.M
	{mso-style-name:M;
	color:red;
	font-weight:bold;}
span.msoIns
	{mso-style-name:"";
	text-decoration:underline;
	color:teal;}
span.msoDel
	{mso-style-name:"";
	text-decoration:line-through;
	color:red;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple>

<div class=WordSection1>

<p class=Fixed><span style='background:silver'>DDDDD</span>     <span
style='background:silver'>AAAAA</span>   <span style='background:silver'>EEEEEEE</span> 
<span style='background:silver'>DDDDD</span>     <span style='background:silver'>AAAAA</span>  
<span style='background:silver'>L</span>        <span style='background:silver'>U</span>    
<span style='background:silver'>U</span>   <span style='background:silver'>SSSSS</span></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>D</span><span
lang=ES-CR>    <span style='background:silver'>D</span>   <span
style='background:silver'>A</span>     <span style='background:silver'>A</span> 
<span style='background:silver'>E</span>        <span style='background:silver'>D</span>   
<span style='background:silver'>D</span>   <span style='background:silver'>A</span>    
<span style='background:silver'>A</span>  <span style='background:silver'>L</span>       
<span style='background:silver'>U</span>     <span style='background:silver'>U</span> 
<span style='background:silver'>S</span>     <span style='background:silver'>S</span></span></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>D</span><span
lang=ES-CR>     <span style='background:silver'>D</span>  <span
style='background:silver'>A</span>     <span style='background:silver'>A</span> 
<span style='background:silver'>E</span>        <span style='background:silver'>D</span>    
<span style='background:silver'>D</span>  <span style='background:silver'>A</span>    
<span style='background:silver'>A</span>  <span style='background:silver'>L</span>       
<span style='background:silver'>U</span>     <span style='background:silver'>U</span> 
<span style='background:silver'>S</span></span></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>D</span><span
lang=ES-CR>     <span style='background:silver'>D</span>  <span
style='background:silver'>AAAAAAA</span>  <span style='background:silver'>EEEEEE</span>  
<span style='background:silver'>D</span>     <span style='background:silver'>D</span> 
<span style='background:silver'>AAAAAAA</span>  <span style='background:silver'>L</span>   
    <span style='background:silver'>U</span>     <span style='background:silver'>U</span>  
<span style='background:silver'>SSSSS</span></span></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>D</span><span
lang=ES-CR>     <span style='background:silver'>D</span>  <span
style='background:silver'>A</span>     <span style='background:silver'>A</span> 
<span style='background:silver'>E</span>        <span style='background:silver'>D</span>    
<span style='background:silver'>D</span>  <span style='background:silver'>A</span>    
<span style='background:silver'>A</span>  <span style='background:silver'>L</span>       
<span style='background:silver'>U</span>     <span style='background:silver'>U</span>       
<span style='background:silver'>S</span></span></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>D</span><span
lang=ES-CR>    <span style='background:silver'>D</span>   <span
style='background:silver'>A</span>     <span style='background:silver'>A</span> 
<span style='background:silver'>E</span>        <span style='background:silver'>D</span>   
<span style='background:silver'>D</span>   <span style='background:silver'>A</span>    
<span style='background:silver'>A</span>  <span style='background:silver'>L</span>       
<span style='background:silver'>U</span>     <span style='background:silver'>U</span> 
<span style='background:silver'>S</span>     <span style='background:silver'>S</span></span></p>

<p class=Fixed><span style='background:silver'>DDDDD</span>    <span
style='background:silver'>A</span>     <span style='background:silver'>A</span> 
<span style='background:silver'>EEEEEEE</span>  <span style='background:silver'>DDDDD</span>   
<span style='background:silver'>A</span>     <span style='background:silver'>A</span> 
<span style='background:silver'>LLLLLLL</span>   <span style='background:silver'>UUUUU</span>   
<span style='background:silver'>SSSSS</span></p>

<p class=Fixed>&nbsp;</p>

<p class=Fixed>                         **  VERSION  3.4  **</p>

<p class=A>&nbsp;</p>

<p class=A>Daedalus: The world’s most sophisticated Maze program! :)</p>

<p class=A>Daedalus is a program that allows one to create, solve, analyze,
view, walk through, and most of all have fun with Mazes. Daedalus is 100%
freeware with no registration fee! It runs on all versions of Windows
supporting 32 or 64 bit applications, ranging from Windows 95 to Windows 11 and
beyond.</p>

<p class=A>The file is divided into seven sections:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>1) <a href="#list">Daedalus feature list</a>:</b> A list of
the main features of the program.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>2) <a href="#intro">Introduction to Daedalus</a>:</b> A
summary of the program, what it does, and how it’s organized.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>3) <a href="#menu">Daedalus menus</a>:</b> A list of each menu
and menu command in the program, and documentation for it.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>4) <a href="#other">Other features of Daedalus</a>:</b>
Documentation for other ways to interface with the program other than menu
commands, such as mouse clicks.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>5) <a href="#example">Daedalus examples</a>:</b> How to use
Daedalus to accomplish specific scenarios, namely create and solve Mazes of
irregular shapes.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>6) <a href="#file">Daedalus files</a>:</b> A list of the files
that comes with the Daedalus install, and what each file is for.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>7) <a href="#history">Daedalus history</a>:</b> A timeline of
all the versions of Daedalus that have been released, and the main things
introduced in each.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=list>DAEDALUS FEATURE LIST</a></p>

</div>

<p class=A>Maze creation methods:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Perfect Mazes (standard simply connected Mazes).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Braid Mazes (Mazes without dead ends).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Unicursal Mazes (Mazes consisting of a single path without
junctions).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Labyrinths (special unicursal Mazes used for spiritual purposes).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Custom Labyrinths (in which you specify their circuit sequence).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>3D Mazes.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>4D Mazes.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>N-dimensional Mazes up to 18 dimensions.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Weave Mazes (2D Mazes with over and under passages).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Crack Mazes (Mazes with passages at random angles).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Arrow Mazes where you can’t go against the arrows.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Theta Mazes (Mazes with passages in concentric circles).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Delta Mazes (Mazes composed of interlocking triangles).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sigma Mazes (Mazes composed of interlocking hexagons).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Upsilon Mazes (Mazes composed of interlocking octagons and
squares).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Omicron Mazes (Mazes on the surface of a sphere)</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Zeta Mazes (orthogonal Mazes with diagonal passages).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Mazes on non-standard topology, e.g. on surface of a Moebius
strip or cube.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Mazes composed of interlocking spirals.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Nested cell fractal Mazes (Mazes composed of smaller Mazes).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Hilbert curve fractal Labyrinths (Labyrinths composed of smaller
Labyrinths).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Infinite recursive fractal Mazes (Mazes containing copies of
itself).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Hypermazes (3D Mazes in which you move a line, with the solution
a surface).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with a recursive backtracking algorithm.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with Prim’s algorithm (and modified
versions of it).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with Kruskal’s algorithm.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with the Aldous-Broder algorithm.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with Wilson’s algorithm.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with Eller’s algorithm.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with the Growing Tree or Growing Forest algorithms.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated with the Sidewinder algorithm.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated by making a binary tree.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Standard Mazes generated by adding walls instead of carving
passages.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Infinitely long Mazes limited only by your patience or disk
space!</p>

<p class=A>Maze solving methods:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Dead end filler.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Blind alley fillers.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Wall follower.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Recursive backtracker.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Shortest path finder.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All shortest paths finder.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Collision solver.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Cul-de-sac filler.</p>

<p class=A>Maze creating utilities:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create Mazes in which you specify the shape and computer does the
rest.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create Mazes in which you specify the solution and the computer
does the rest.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create biased Mazes with passages tending to go along one axis.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create Mazes with “run” tending to have longer straightaways.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create Mazes with symmetric passages.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create “segmented” Mazes with different sections having different
textures.</p>

<p class=A>Maze solving utilities:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Walk through a Maze in a 3D first person perspective view from
inside.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Semitransparent walls you can see through in 3D first person view.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Fog effects where walls fade into the distance in 3D first person
view.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Texture mapped walls and ground decorated with pictures in 1st
person view.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>“Breadcrumbs” feature to mark your path while in 3D first person
view.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Partial dead end fillers (see how the main false paths are
arranged).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>“Radar” feature to prevent you from entering short blind alleys.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Flood passages and walls.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Distance graph features to show how far all points are from each
other.</p>

<p class=A>Other Maze utilities:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Find and reconnect all detached walls in a Maze.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Find and break into all inaccessible sections in a Maze.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Remove all dead ends from a Maze (converting to a Braid Maze).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Find all bottlenecks in a Maze (areas that all solutions go
through).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Add more walls to a Maze (that won’t create inaccessible
sections).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Add and remove entrances.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Analyze passages (count dead ends, junctions, longest passages,
etc).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Analyze walls (count corners, straight sections, longest walls,
etc).</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Timer to measure how long it takes you to get through a Maze.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Move counter to measure the distance you travel through a Maze.</p>

<p class=A>Extra graphics features:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Display passages and walls in any color.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Display using color fades and rainbow fades.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Overlay two or even three images together.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Zoom, flip, rotate, smooth, thicken, and make thinner bitmaps.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Create antialiased color images.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Draw 3D orthographic overviews of bitmaps and 3D bitmaps.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Draw perspective views of bitmaps with an infinite vanishing
point.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Draw truly perspective 3D scenes of bitmaps or other objects.</p>

<p class=A>Macro and scripting features:</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Automate actions or write whole programs in macros and script
files.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample games: Nine Survivor Maze challenges - Find checkpoints in
the Mazes.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample games: Two Carleton Farm simulations - Find hidden message
in the corn Mazes.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Glacier Maze simulation - Fun with bridges in a
fence Maze.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Stocker Farms simulation - Explore a Halloween corn
Maze.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Safari Maze simulation - A fence Maze with towers
and tunnels.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: 4D Maze - Walk through a 4D Maze from a first person
view.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: 5D Mazes - Animate and solve Mazes in up to 18
dimensions!</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Gigamaze - Walk through a Maze larger than the
planet!</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Word Mazes - Create Mazes in the shapes of words.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Mouse Maze - Move with your mouse, but don’t hit a
wall.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Dragonslayer - Fight creatures in a random 3D
dungeon.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: 3D Pac-Man - The classic arcade video game
reproduced.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: 3D Sokoban - The Japanese box pushing puzzle game.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: The Hunger Games - Fight to be the last person
standing.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Survivor squares challenge - Run the computer out of
room.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Mandelbrot set simulation - Explore fractals in 3D.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Pentris - Like Tetris but with polyomonies composed
of 5 and 6 squares.</p>

<p class=Item><span style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Sample game: Grippy Socks - Mental health psych ward simulation.</p>

<p class=A>For a quick demo of some of the cool things Daedalus can do, start
the program, press the “Shift+V” key to create a Weave Maze, select “Weave To
Inside” on the Maze menu to start exploring a first person perspective view of
the Maze, then use the arrow keys and try to reach the exit. Notice the bridges
you can climb over and go under.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=intro>INTRODUCTION TO DAEDALUS</a></p>

</div>

<p class=A>Daedalus can be considered a glorified bitmap editor. The content you
work with in Daedalus are basically bitmaps, usually monochrome bitmaps of
Mazes. What you see in the Daedalus window is always a view of a bitmap. This
may be either the entire bitmap, a magnified subsection of it, or a special
view of some part of it, such as a 3D first person perspective view from inside
a Maze bitmap.</p>

<p class=A>The simplest Mazes in Daedalus are orthogonal in which each passage
and wall is one pixel wide. For these standard Mazes it’s assumed the even
numbered rows and columns are walls, and the odd number rows and columns are
passages. The default settings for the Daedalus window have walls be white “on”
pixels while passages are black “off” pixels. Note when printing you probably
want the colors reversed, as the background of paper is white while things
printed on it are black. You may also want the walls to be thinner than the
passages. It’s easy to change these things in the program so they look the way
you want: Use the Zoom Bias command on the Maze menu to set passage and wall
size, use Invert All on the All submenu of the Bitmap menu to reverse the
screen, or change the Passage and Wall color in the Set Colors dialog on the
Edit menu to reverse the colors permanently. An easier way to change these
settings is simply to select the Polished Mazes command on the Create menu,
i.e. press the “/” key to put the current and all future Mazes in a form ready
to print.</p>

<p class=A>There are two types of bitmap in Daedalus: (1) The main bitmap,
which most commands operate upon. In most cases what you see in the window is
this main monochrome bitmap. (2) The color bitmap, which can have pixels in any
24 bit RGB color value. If you’re not viewing the main bitmap, you’re viewing
the color bitmap, and you can switch back and forth between them. The contents
of the color bitmap are often a variant on the main bitmap, e.g. the main
bitmap indicates where walls are in a Maze while the color bitmap indicates the
color of the walls and floor, and certain commands set the contents of the
color bitmap based on the main bitmap. Both types of bitmaps above can exist in
three locations, for six bitmaps total: (a) The main bitmap and main color
bitmap, which is what’s being viewed or operated upon. (b) The temporary
bitmap, which the main monochrome or color bitmaps can be copied to or from.
Some commands may change or use this bitmap, and you can also copy to or from
it yourself as an undo buffer. (c) The extra bitmap, which is like another
temporary bitmap.</p>

<p class=A>3D Mazes and similar Maze types are expressed as a list of 2D
bitmaps arranged next to each other within a larger bitmap, one subbitmap per
level in the “3D bitmap”.</p>

<p class=A>When you start Daedalus, you’ll see a 63x63 pixel bitmap with a
31x31 passage Maze drawn within it. The default display settings zoom the
bitmap so it fills as much of the window as possible, even though the internal
bitmap is still only 63x63. The easiest thing to do with the program is select
the commands on the Create menu to draw various types of Mazes. You probably
want to use the size changing menu commands to make the bitmap and hence the
Mazes you create on it larger or smaller. Daedalus however is mainly designed
to be an advanced Maze editing environment. All the various commands may seem
confusing at first, and the program has 467 separate menu commands and 21
dialogs. In general you can do anything in Daedalus, although it may take
several steps and some thought about what steps to take to do what you want.</p>

<p class=A>To learn about different types of Mazes and ways to create and solve
them, see <a href="http://www.astrolog.org/labyrnth/algrithm.htm">http://www.astrolog.org/labyrnth/algrithm.htm</a>
for a Maze algorithms page, and <a
href="http://www.astrolog.org/labyrnth/glossary.htm">http://www.astrolog.org/labyrnth/glossary.htm</a>
for a dictionary of Maze terms.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menu>DAEDALUS MENUS</a></p>

</div>

<p class=A><span class=M>File Menu:</span> This contains all commands dealing
with loading to or saving from the main bitmap. It also deals with settings for
files, and has system commands concerning the program in general such as the
About dialog.</p>

<p class=A><span class=M>Edit Menu:</span> This deals with all low level
operations of the program. This includes clipboard commands, random number
settings, and the program’s timer. It also deals with fundamental display
settings, such as the color palette being used, and how to draw the current
bitmap being viewed.</p>

<p class=A><span class=M>Dot Menu:</span> This contains everything dealing with
“the dot”. The dot is like a cursor positioned over a particular pixel on the
bitmap. The dot can be moved around, the bitmap can be edited based on the dot,
and special displays can be centered on the dot like the 3D first person inside
view in which the dot indicates where you are.</p>

<p class=A><span class=M>Bitmap Menu:</span> This contains general graphics
commands that operate on the bitmap as a whole, such as clearing, resizing,
zooming, and copying. Some of these commands only operate on the main
monochrome bitmap, but most will do a similar action on the color bitmap if the
color bitmap is being shown.</p>

<p class=A><span class=M>Color Menu:</span> This contains all commands
affecting the color bitmap, such as the ability to load or copy to it, and save
or copy from it. Most commands set the color bitmap in an interesting way based
on other bitmaps, although some operate on the color bitmap itself.</p>

<p class=A><span class=M>Maze Menu:</span> This is similar to the Bitmap menu
but contains commands that operate on the main bitmap that are associated with
Mazes. This includes Maze generation commands that use what’s already on the
screen as a basis of what they do.</p>

<p class=A><span class=M>Create Menu:</span> This contains all the ways of
creating different types of Mazes and Labyrinths. Most of these commands will
draw a 100% computer generated Maze within the bounds of the main bitmap.</p>

<p class=A><span class=M>Solve Menu:</span> This contains all the ways of
partially or completely solving different types of Mazes.</p>

<p class=A><span class=M>Draw Menu:</span> This contains advanced graphic
commands which operate on the main bitmap or other data in memory and have as
their result another bitmap. This includes simple orthographic views of 2D and
3D bitmaps, along with general wireframe and polygon based true perspective
graphics scenes. These aren’t related to Mazes, but can be used to create nice
displays of Mazes or other things.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menufile>DAEDALUS MENU COMMANDS - </a>FILE MENU</p>

</div>

<p class=A><span class=M>File Menu:</span> This menu contains all commands
dealing with loading to or saving from the main bitmap. It also deals with
settings for files, and has system commands dealing with the program in general
such as the About dialog.</p>

<p class=A><span class=N>Open...:</span> This allows one to open any file into
the program so long as Daedalus supports its format. Daedalus will determine
what type of file is being opened and do the right thing with it. This is
basically a union of the Open Bitmap, Open Text, Open X11 Bitmap, Open 3D
Bitmap, Open Script, Open Targa, Open Wireframe, and Open Patches commands.</p>

<p class=A><span class=M>Run Script:</span> This submenu allows automatically
running any of the 28 scripts that come with the program. To run a script, you
can also manually select the script file in the Open or Open Script dialogs, or
double click the file for the script outside the program altogether. All
scripts also have an icon in the Daedalus program group created by setup, that
will run it. Note in every script that comes with Daedalus, you can press F1 to
display a help message, listing what all the keys defined in that script do,
and without affecting anything else in the script.</p>

<p class=B><span class=N>Demos:</span> This script displays a menu of 18
demonstrations of Daedalus features. Once the script is loaded, press the
following:</p>

<p class=C>F2: Animates yourself randomly moving though a Maze with different
colored walls. Notice the gradual changes between day and night.<br>
Shift+F2: Animates yourself moving through a 3D Maze.<br>
F3: Displays a series of random Mazes created with different algorithms, one
after another.<br>
Shift+F3: Creates a series of Mazes in different algorithms, in which you can
see the Mazes get generated.<br>
F4: Draws an orthographic view looking across a Maze with 3D walls.<br>
Shift+F4: Draws a perspective view of looking down on a Maze from above.<br>
F5: Draws a Planair style Maze on the surface of six cubes, seen face on.<br>
Shift+F5: Draws a Planair style Maze on the surface of eight cubes, seen edge
on.<br>
F6: Draws a rainbow colored Chartres Cathedral pattern Labyrinth. Press “i” to
enter first person view in which you can walk through it.<br>
Shift+F6: Draws a rainbow colored classical seven circuit Labyrinth.<br>
F7: Animates you flying over a Maze with 3D walls, seen in perspective and color.<br>
Shift+F7: Animates you flying over a 2D Maze drawn on the ground, seen in
perspective and monochrome.<br>
F8: Draws an orthographic view of the Escher room in the ESCHER.D3 sample file.<br>
Shift+F8: Draws an orthographic view of the castle from the CASTLE.D3 sample
file.<br>
F9: Does animations of a random cyclic cellular automaton, in which colors of
the rainbow flow into each other.<br>
Shift+F9: Does a colored animation of random sequences of the game of “Life”.<br>
F10: Draws a perspective scene of geometrical shapes, from the SOLIDS.DP sample
file.<br>
Shift+F10: Animates you flying around the scene of geometrical shapes.</p>

<p class=B><span class=N>Word Mazes:</span> This script creates Mazes in the
shapes of words. You specify a line of letters or characters you want to use to
form the Maze. The Maze can be drawn inside letters, be a rectangular Maze with
letter shaped open spaces within, or the letters can spell out the solution to
the Maze in an obvious or hidden fashion.</p>

<p class=B><span class=N>World's Largest Maze:</span> This script allows you to
explore a Maze, however the Mazes created here are enormous, and measure at
least a billion passages on each side, and have one quintillion or
1,000,000,000,000,000,000 or 10^18 cells total! A life size version of one of
these Gigamazes, with five feet between passages, would cover the surface of
the Earth over 4500 times. Visiting one cell per second, it would take over 31
years just to walk from one side of the Maze to the opposite side, and that’s
assuming no walls are in your way. Wall following to actually solve the Maze
will take on average 31 billion years. A bitmap of one of these Mazes would
require 500 million gigabytes of RAM to store in memory all at once, therefore
only the parts of the Maze near your location are actually loaded into memory
at any one time, like a view under a magnifying glass. Each Maze is perfect
with exactly one solution, and although the Maze is “virtual”, each section of
a given Maze will be generated the same way every time you visit it. This script
has the option to use different algorithms to generate the parts of the Maze
being viewed, which are nested cell fractal, binary tree, recursive division,
unicursal Labyrinth, classical Labyrinth, and Hilbert curve Labyrinth. The
Mazes here can be considered the largest finite Mazes ever created, and perhaps
the hardest puzzles ever too. The above is only for 2D Mazes: You can also explore
3D Mazes of a billion x billion x billion passages, for one octillion or
1,000,000,000,000,000,000,000,000,000 or 10^27 cells total, and a life size
version would fill the Earth’s volume over three million times!</p>

<p class=B><span class=N>4D Mazes:</span> This script allows you to explore a
four dimensional Maze from a first person perspective! The fourth dimension is
represented by magic portals which go forward and back through time or space,
so the 4D Maze is seen as a sequence of 3D Mazes. This is one of the few games
that allow you to experience a 4D Maze in first person.</p>

<p class=B><span class=N>5D Mazes:</span> This script creates Mazes in multiple
dimensions. You can create a Maze with anywhere from 2 to 18 dimensions, and
you see a 5 dimensional Maze to begin with upon starting the script.
Multidimensional Mazes are expressed in wireframe form here, with a line for
each passage. Each dimension has its own horizontal and vertical offsets, like
the 3 axes of a cube have when a cube is drawn on a plane. The whole Maze
animates by default too, which helps distinguish different dimensions which may
overlap at times. Note watching Mazes or cubes with a high number of dimensions
animate may cause dizziness or headaches. Don’t say you weren’t warned! ;)</p>

<p class=B><span class=N>Dragonslayer Game:</span> This script is a dungeons
and dragons type game taking place within a multiple level Maze. It’s a
simplified first person perspective version of computer games like Rogue or
Nethack. Your goal is to find your way down to an evil dragon, and slay him.
You can fight 26 different monsters and use 50 different items. For more about
this game see <a href="http://www.astrolog.org/labyrnth/daedalus/dragon.htm">http://www.astrolog.org/labyrnth/daedalus/dragon.htm</a>.</p>

<p class=B><span class=N>Pac-Man Game:</span> This script is a reproduction of
the old arcade video game of the same name, with the exact same Maze and all,
but you play from a 3D first person view. Your goal is to eat all the dots in
the Maze, avoiding the monsters which want to eat you.</p>

<p class=B><span class=N>Sokoban Game:</span> This script is a 3D first person
view version of the box pushing game Sokoban (Japanese for “warehouse keeper”).
There are 85 levels total, which are the standard 85 levels seen in some other
Sokoban implementations. I’ve given a unique title to each level.</p>

<p class=B><span class=N>The Hunger Games:</span> This script is inspired by “The
Hunger Games”, as seen in the novels by Suzanne Collins and the movies by
Lionsgate Films. This simulation is a last person standing fight, where you and
23 computer controlled opponents (number customizable) engage in a massive “battle
royal”. As in the Hunger Games, there’s a central “cornucopia” building filled
with melee and ranged weapons along with food and other gear, surrounded by wilderness
in which one can hide or forage. The arena landscape includes forest, meadows,
mountains, lakes, and rivers, along with options for desert, plains, swamp, island,
buildings, and a giant Maze. Tributes can climb things such as trees and
mountains, dig up things from the ground or chip them off mountains, and swim
in water. You can also form alliances, and backstab or be backstabbed by your
allies. Beware of the aggressive “muttation” monsters roaming the arena. For
more about this game see <a
href="http://www.astrolog.org/labyrnth/daedalus/hunger.htm">http://www.astrolog.org/labyrnth/daedalus/hunger.htm</a>.</p>

<p class=B><span class=N>Survivor Maze #1:</span> This script is a Maze solving
game, where you have to find and visit five checkpoints located within a Maze
in order and then exit, all as fast as you can. This is a copy of the Maze from
the episode 5 immunity challenge in the CBS TV show “Survivor II: The
Australian Outback”.</p>

<p class=B><span class=N>Survivor Maze #2:</span> This script is similar to the
first Survivor Maze game. You start in the center of a circular Maze, where you
must visit five checkpoints in order, and after each checkpoint you must return
to the center. Returning to the center after the final checkpoint finishes the
game and will display your time, and you’re rewarded by getting to climb the
central stand and look out over the Maze. This is a copy of the Maze from the
episode 6 immunity challenge in the CBS TV show “Survivor IV: Marquesas”.</p>

<p class=B><span class=N>Survivor Maze #3:</span> This script is another
similar Maze game. You start in the center of a diamond shaped Maze, where you
must visit four checkpoints in the four corners in any order, then return to
the center when done. You have the option of trying to solve the Maze
blindfolded, where you get messages when you move into or feel a wall next to
you. This is a copy of the Maze from the final four immunity challenge in the
CBS TV show “Survivor VI: Amazon”.</p>

<p class=B><span class=N>Survivor Maze #4:</span> This script is similar to the
other Survivor Maze games. You start in the center of a star shaped Maze, where
you must visit eight checkpoints in the eight points in any order, returning to
the center after each. Note some passages are clogged with pole obstacles you
have to weave through. This is a copy of the Maze from the final four immunity
challenge in the CBS TV show “Survivor VIII: All Stars”.</p>

<p class=B><span class=N>Survivor Maze #5:</span> This script is similar to the
other Survivor Maze games. You start outside at the base of an eight level
vertical Maze, where you must visit ten checkpoints within the Maze in any
order, returning to the outside after each. This is a copy of the Maze from the
final four immunity challenge in the CBS TV show “Survivor IX: Vanuatu”.</p>

<p class=B><span class=N>Survivor Maze #6:</span> This script is similar to the
other Survivor Maze games. The Maze is in the shape of the Seven Macaw, an
ancient Maya bird deity. You start at its tail, where you must visit six
checkpoints within the Maze in any order, visiting the pyramid in the middle
after each. This is a copy of the Maze from the final four immunity challenge
in the CBS TV show “Survivor XI: Guatemala”.</p>

<p class=B><span class=N>Survivor Maze #7:</span> This script is similar to the
other Survivor Maze games. You need to navigate your way through five Mazes in
sequence, finding a key within each before exiting. You have the option of
trying to solve the Mazes blindfolded, where everything is dark and you can
only see (i.e. feel) the walls directly in front of you. This is a copy of the
Maze from the final five immunity challenge in the CBS TV show “Survivor XIV: Fiji”.</p>

<p class=B><span class=N>Survivor Maze #8:</span> This script is similar to the
other Survivor Maze games. You need to navigate your way through the Maze,
finding four checkpoints within it in any order, before reaching the center.
You have the option of trying to solve the Maze blindfolded, where everything
is dark and you can only see (i.e. feel) the walls directly in front of you.
This is a copy of the Maze from the final four immunity challenge in the CBS TV
show “Survivor XX: Heroes vs. Villains”. A video of the Survivor contestants in
the real life version of this Maze can be seen at <a
href="https://www.youtube.com/watch?v=fp6DgPHBkkA">https://www.youtube.com/watch?v=fp6DgPHBkkA</a>.</p>

<p class=B><span class=N>Survivor Maze #9:</span> This is one more script
similar to the other Survivor Maze games. You need to navigate your way through
the Maze, finding four checkpoints within it in any other, before reaching the
goal. You have the option of trying to solve the exact Maze the Survivors went
through, or solving a randomly generated Maze. This is a copy of the Maze from
the final four immunity challenge in the CBS TV show “Survivor XXII: Redemption Island”. A video of the Survivor contestants in the real life version of this
Maze can be seen at <a href="https://www.youtube.com/watch?v=_x6HVvdOq5g">https://www.youtube.com/watch?v=_x6HVvdOq5g</a>.</p>

<p class=B><span class=N>Survivor Maze #10:</span> This is one final script
similar to the other Survivor Maze games. You need to navigate your way through
the Maze, finding four checkpoints within it in any order, before reaching the finish.
You have the option of trying to solve the Maze blindfolded, where everything
is dark and you can only see (i.e. feel) the walls directly in front of you. This
is a copy of the Maze from the final five immunity challenge in the CBS TV show
&quot;Survivor XXX: World’s Apart&quot;. A video of the Survivor contestants in
the real life version of this Maze can be seen at <a
href="https://www.youtube.com/watch?v=DAow6IWqkcI">https://www.youtube.com/watch?v=DAow6IWqkcI</a>.</p>

<p class=C>The table below summarizes the ten Survivor Maze scripts available in
Daedalus. Listed is the season number and season name of Survivor that the real
life version of the Maze appeared in, the number of checkpoints the Survivors
had to find within the Maze, whether the Maze is 3D and has passages that cross
over other passages, whether the script can create randomized versions of the
Maze with alternate passage arrangements or checkpoint positions, whether the
Survivors had to do the Maze blindfolded meaning the user has the option to do
so as well, and finally the number of players or teams that were trying to
solve the real life version of the Maze.</p>

<p class=Fixed style='margin-left:1.0in'><b>#   Survivor Season       
Checkpoints  3D   Random  Blind  Players  Winner</b></p>

<p class=Fixed style='margin-left:1.0in'>1   2 Outback             
5            no   Yes     no     2        Ogakor tribe</p>

<p class=Fixed style='margin-left:1.0in'>2   4 Marquesas           
5            no   Yes     no     2        Rotu tribe</p>

<p class=Fixed style='margin-left:1.0in'>3   6 Amazon              
4            no   no      Yes    4        Jenna</p>

<p class=Fixed style='margin-left:1.0in'>4   8 All Stars           
8            no   no      no     4        Amber</p>

<p class=Fixed style='margin-left:1.0in'>5   9 Vanuatu             
10           Yes  no      no     4        Chris</p>

<p class=Fixed style='margin-left:1.0in'>6   11 Guatemala          
6            Yes  no      no     4        Rafe</p>

<p class=Fixed style='margin-left:1.0in'>7   14 Fiji                5           
no   no      Yes    5        Yau-Man</p>

<p class=Fixed style='margin-left:1.0in'>8   20 Heroes vs Villains 
4            no   no      Yes    4        Russell</p>

<p class=Fixed style='margin-left:1.0in'>9   22 Redemption Island  
4            no   Yes     no     4        Boston Rob</p>

<p class=Fixed style='margin-left:1.0in'>10  30 World's Apart      
4            no   no      Yes    5        Mike</p>

<p class=B><span class=N>Carleton Farm Maze #1:</span> This script simulates
the 2009 Carleton Farm corn Maze near Everett, WA. This Maze has passages in
the shape of a horse drawn carriage, and in it you seek out 10 checkpoints in
any order to spell out a hidden message.</p>

<p class=B><span class=N>Carleton Farm Maze #2:</span> This script simulates
the 2010 Carleton Farm corn Maze near Everett, WA. This Maze has passages in
the shape of two bees, and in it you seek out 10 checkpoints in any order to
spell out a hidden message.</p>

<p class=B><span class=N>Stocker Farms Maze:</span> This script simulates a
corn Maze plan grown at Stocker Farms in Snohomish, Washington. The cornfield
actually contains two separate Mazes, both of which have their entrances and
exits marked in a starting courtyard. There are two bridges within the Mazes,
one of which you can pass under as well as climb over. There’s also a Halloween
themed “Field of Screams” passage, which causes the day scene to turn into dark
night when you enter it. :)</p>

<p class=B><span class=N>Glacier Maze:</span> This script simulates Glacier
Maze, a wooden fence Maze located outside Glacier National Park, Montana. Your goal is to enter the Maze, find four different colored checkpoints located in
towers in each of the four corners in any order, then find the exit. This is a
good demonstration of the variable height walls feature of Daedalus, where you
can climb over and go under bridges, enter towers and buildings, bump into
fences and picnic tables, and so on.</p>

<p class=B><span class=N>Safari Maze:</span> This script simulates an imaginary
Maze where you need to hunt down and visit the four checkpoints in any order
and then find the exit. The Maze has several 3D aspects to it, specifically
bridges to climb over and go under, and a high central tower you start on along
with tunnels that go through that tower. A video of a playthrough of this game can
be seen at <a href="https://www.youtube.com/watch?v=-oixyRd1hAc">https://www.youtube.com/watch?v=-oixyRd1hAc</a>.</p>

<p class=B><span class=N>Mouse Maze:</span> This script plays a game where you
move the mouse pointer through a mostly unicursal Maze as fast as possible,
while avoiding bumping into walls.</p>

<p class=B><span class=N>Survivor Squares Game:</span> This script plays a
non-Maze game where you move on a game board and try to run the other seven
computer players out of room before running out of room yourself. Squared Off
reproduces the episode 9 immunity challenge from the original CBS “Survivor”
series. You can customize the board dimensions in squares, the number of
players competing, whether players are allowed to move diagonally, and the
difficulty. Higher difficulty means computer players will make more intelligent
moves, and notice larger spaces with more available squares to move into.</p>

<p class=B><span class=N>Mandelbrot Set Fractal:</span> This non-Maze related
script demonstrates the famous Mandelbrot set fractal. You can zoom in on parts
of the fractal, display 3D overviews of it, and even walk among a 3D version of
the fractal in the perspective inside view.</p>

<p class=B><span class=N>Pentris Game:</span> This non-Maze related script
implements the game of Pentris. Pentris is like Tetris but more challenging
because it includes five (and even six) square polyominoes in addition to the
standard four square tetrominoes, and you can select which sizes of polyominoes
you want to include in a game.</p>

<p class=B><span class=N>Grippy Socks:</span> This non-Maze related script is a
mental health psych ward simulation. You experience a hospital environment, in
which your objective is to find the right medication and other treatments, and
then use them so that you can get released. For more details about this script
see <a href="http://www.astrolog.org/labyrnth/daedalus/gripsox.htm">http://www.astrolog.org/labyrnth/daedalus/gripsox.htm</a>.</p>

<p class=A><span class=N>Open Bitmap...:</span> This loads a Windows bitmap
file into either the main bitmap or color bitmap. If the file is a monochrome
bitmap it gets loaded into the main bitmap, and if color it gets loaded into
the color bitmap.</p>

<p class=A><span class=N>Save Bitmap...:</span> This saves the main bitmap to a
monochrome Windows bitmap file. Colors used in the file will be the current
colors for on and off pixels from the Set Colors dialog. If Show Color Bitmap
is on, this instead saves the color bitmap to a 24 bit color Windows bitmap
file.</p>

<p class=A><span class=N>Open Text...:</span> This loads a plain text file into
the main bitmap. Each space character in the file becomes an off pixel, while
each character with an ASCII value of “#” or higher becomes an on pixel. The
length of the longest line in the file becomes the horizontal size of the
bitmap, while the number of lines in the file becomes the vertical size. Lines
shorter than the maximum line length are filled in with off pixels.</p>

<p class=A><span class=N>Save Text...:</span> This saves the active bitmap to a
plain text file. For monochrome bitmaps, on pixels become “#” characters while
off pixels become spaces. For color bitmaps, this produces a crude ASCII art
version of the image. As with monochrome bitmaps, one character represents one
pixel, where the character used for a pixel is based on the darkness of its
color. The characters used will be one of the following 16, ranked in order
from darkest to lightest: #MN@O$7%?*;:+,.[space]</p>

<p class=B>If the Bitmap Is 3D setting is on, this instead saves the 3D Maze in
the main bitmap to a plain text file, formatted such that the different levels
and passages between them are easily seen. The dimensions of the 3D Maze are
taken from the appropriate fields in the Size or Maze Size dialogs. In the text
file, each level is written in sequence. Within a level, “#” characters are
walls, spaces are passages, “\” indicates a passage down to the next lower
level, “/” indicates a passage up to the next higher level, and “X” indicates
passages both up and down at that point. These files may only be exported, and
can’t be loaded back into Daedalus as 3D bitmaps. The “3D Bitmap X Cutoff”
value in the File Settings dialog is used to control how many levels are placed
side by side in the text file before going to subsequent rows.</p>

<p class=A><span class=M>DOS Text:</span> This submenu has commands to save the
main bitmap to a plain text file composed of DOS graphics characters. Hence
they can really only be displayed in a DOS command prompt. These files may only
be exported, and can’t be loaded back into Daedalus.</p>

<p class=B><span class=N>Save Blocks...:</span> This uses DOS block characters
to compose the bitmap. Each character covers two pixels. Since DOS characters
are typically twice as tall as they are wide, this makes each pixel nearly
square, making for a nice looking display.</p>

<p class=C>If the Line Chars In Text Bitmaps flag in File Settings is set, it
will cause the file to be saved using normal ASCII instead of DOS graphics
characters. Each character will still cover two pixels. This format lends
itself to saving Mazes, and is a more compact form of the text generated by the
Save Text command.</p>

<p class=B><span class=N>Save Lines...:</span> This uses DOS line characters to
compose the bitmap. Since the center of each character is a wall intersection,
each DOS character basically covers four pixels. Note there are no DOS line
characters for wall endpoints, hence any walls that end will look longer than
they should. Bitmaps that have been run through the Accent Boundaries command
(and hence have no wall endpoints) look better in this display.</p>

<p class=B><span class=N>Save Double Lines...:</span> This is just like Save
Lines but uses the DOS double line characters consisting of two parallel lines
close together.</p>

<p class=A><span class=M>X11 Bitmap:</span> This submenu has commands to load
and save files like as created with the “bitmap” command on Unix X11 systems.
These files are plain text and looks like fragments of C source code. If you’re
not transferring files to or from Unix systems, this format isn’t useful to
you.</p>

<p class=B><span class=N>Open...:</span> This opens an X11 bitmap file into the
main bitmap.</p>

<p class=B><span class=N>Save Normal...:</span> This saves the main bitmap to
an X11 bitmap file. The file will look exactly as created with the “bitmap”
command.</p>

<p class=B><span class=N>Save Compressed...:</span> This is just like Save
Normal but removes extra whitespace characters from the generated file. The
result may still be loaded into the “bitmap” command.</p>

<p class=B><span class=N>Save Supercompressed...:</span> This is like Save
Compressed but writes the content in a different manner which results in a
still smaller file. This file is not compatible with being loaded back into the
“bitmap” command, but may still be displayed with the “xsetroot” command.</p>

<p class=A><span class=M>3D Bitmap:</span> This submenu has commands to load
and save the 3D bitmap as represented in the main bitmap. This uses a private
file format that’s basically a list of plain text representations of each level
in the 3D bitmap.</p>

<p class=B><span class=N>Open...:</span> This loads a 3D bitmap file into the
main bitmap. The dimensions of the 3D bitmap loaded may be seen in the Size or
Maze Size dialogs.</p>

<p class=B><span class=N>Save Normal...:</span> This saves the 3D bitmap such
that each pixel is represented by one character in the file, similar to what
the Save Text command does for standard bitmaps. The 3D bitmap is written one
level at a time through the Z axis. This format, though larger, is the easiest
to understand and to make other programs understand.</p>

<p class=B><span class=N>Save Supercompressed...:</span> This saves the 3D
bitmap such that each character in the file covers six or more pixels.</p>

<p class=A><span class=M>Save as Wallpaper:</span> This submenu has commands
which allow one to automatically set the background picture of their Windows
desktop to be the current monochrome or color bitmap. One can make a Daedalus
bitmap be their desktop background manually, by doing Save Bitmap to create a
bitmap file, then going into the Display Properties Windows control panel, and
pointing the background bitmap to the file created. This command however does
all that automatically, where a bitmap file called “Daedalus.bmp” will be
written to the Windows directory.</p>

<p class=B><span class=N>Center Bitmap:</span> This centers the active bitmap
in the middle of the Windows desktop.</p>

<p class=B><span class=N>Tile Bitmap:</span> This tiles or tessellates the
active bitmap across and down the Windows desktop area.</p>

<p class=B><span class=N>Stretch Bitmap:</span> This stretches or shrinks the
active bitmap to cover the entire screen.</p>

<p class=B><span class=N>Fit Bitmap:</span> This stretches or shrinks the
bitmap to just fit within the desktop while preserving proportion, and will
leave space on the horizontal or vertical edges if the proportions are
different from the background. Note this command will only work on Windows 7 or
later, which supports this style of background.</p>

<p class=B><span class=N>Fill Bitmap:</span> This stretches or shrinks the
bitmap to completely fill the desktop area while preserving proportion, and
will clip content on the horizontal or vertical edges of the bitmap if its
proportions are different from the background. Note this command will only work
on Windows 7 or later, which supports this style of background.</p>

<p class=A><span class=N>Print...:</span> This prints the main or color bitmap,
whichever is being shown, from within the program, and brings up the standard
Windows Print dialog. The image printed will be a one page graphic of the
bitmap, scaled to be as large as possible within the bounds of the page. The
window’s horizontal and vertical scrollbars determine where on the page the
image will be positioned, e.g. the vertical scrollbar centered means the image
will be vertically centered. Note that the colors in the window will be the
colors on the paper, where you might want to invert the bitmap or change the
color palette so that walls are black and passages white, instead of the
default of the reverse, so the Maze will print as black on a white background.
Note even with this command available, one may still prefer to use the
clipboard or file features of Daedalus to copy the bitmap, and print it from
another program, such as a word processor or desktop publishing program, to
have full control over positioning and all.</p>

<p class=A><span class=N>Print Setup...:</span> This brings up the standard
Windows Print Setup dialog, allowing one to select settings such as the printer
to print to and whether the page will be oriented in portrait or landscape
mode. This is also accessible from the Print dialog itself via the Setup
button, but is made available separately here.</p>

<p class=A><span class=N>File Settings...:</span> This dialog allows changing
of various settings dealing with files.</p>

<p class=B><span class=O>Current Generation:</span> Every time a new infinite
Maze section is created, this value is incremented by one. Starting a new
infinite Maze resets this value to one. There’s no reason to change this,
unless you exit the program part way through creating an infinite Maze, and
want to restore things to the way they were later.</p>

<p class=B><span class=O>Generation Cutoff:</span> If this value is more than
zero, then whenever the Current Generation reaches or passes this value, the
current infinite Maze will be finished. An end section instead of a middle
section will be created when the Infinite Continue command is run. This allows
one to make an infinite Maze of a certain size without having to carefully
watch the Current Generation value and then manually end the infinite Maze at
the right time.</p>

<p class=B><span class=O>New File Cutoff:</span> This value only plays a role
when Save Infinite To File below is set. Normally when saving an infinite Maze
to file, the entire Maze will be written to a single file. When the number here
is more than zero, the Maze sections will be written to multiple files. The
number indicates how many generations or sections should be saved to each file
before going on to the next file. The first file will be called “inf00000.txt”,
the second “inf00001.txt”, and so on. This is useful when creating extremely
large infinite Mazes, where for example on older Windows file systems an
individual file can’t exceed two gigabytes in size.</p>

<p class=B><span class=O>Use Eller's Algorithm:</span> When this is set, each
infinite Maze section will be created using Eller’s Algorithm, instead of the
slower Hunt and Kill Algorithm. Because Eller’s Algorithm creates a Maze one
row at a time, having this on while creating an Infinite Maze will always fill
up both halves of the bitmap with passages, instead of leaving the bottom half
partly carved.</p>

<p class=B><span class=O>Don't Autostart Infinite:</span> Normally the Infinite
Continue command, if there’s no current infinite Maze being created, will start
a new infinite Maze, like as if the Infinite Start command were selected. When
this is set, the Infinite Continue command will do nothing if the program’s not
in the middle of creating an infinite Maze. You’ll need to actually select
Infinite Start to start a new Maze. This allows one to create an infinite Maze
of a certain size by setting the Generation Cutoff, and then doing Autorepeat
on Infinite Continue, without a new Maze immediately being created once the end
is reached.</p>

<p class=B><span class=O>Don’t Save to File:</span> When this option is
selected, infinite Maze sections will only exist in memory, and not be written
to any file.</p>

<p class=B><span class=O>Save as Text:</span> When this option is selected,
each infinite Maze section will be written to the file “infinite.txt” in the
current directory. Starting a new infinite Maze will create or replace this
file, while continuing or ending an infinite Maze will append to this file.</p>

<p class=B><span class=O>Save as DOS Text:</span> When this option is selected,
infinite Maze sections will be written to the file as DOS graphics characters,
instead of as plain text characters. The DOS characters used will be the same
as in the Save Blocks command.</p>

<p class=B><span class=O>Save as Bitmaps:</span> When this option is selected,
infinite Maze sections will be saved as a sequence of bitmap files. The first
file will be called “inf00000.bmp”, the second “inf00001.bmp”, and so on.</p>

<p class=B><span class=O>2D Bitmap X Cutoff &amp; 2D Bitmap Y Cutoff:</span>
Daedalus has the ability to export a bitmap as an array of smaller bitmaps.
This can be used to print out a very large Maze on multiple sheets of paper.
These two values are used to set the size of these smaller bitmaps. They will
affect the Save Bitmap and Save Text commands. By default these values are the
largest sized bitmap allowed in Daedalus, meaning each bitmap is always written
out as a single file. When two or more files are generated, four digits will be
added to each filename, e.g. saving as “maze.bmp” will result in files like “maze0000.bmp”,
“maze0001.bmp”, and so on. Each subbitmap will always be the size of the cutoff
values. If the size of the main bitmap isn’t a multiple of the cutoff values,
the bottom/right rows/columns of the bottom/right subbitmaps will be filled in
with the dot drag color.</p>

<p class=B><span class=O>3D Bitmap X Cutoff:</span> This is used by the Save
Text command when saving 3D bitmaps, to control how many 3D levels are written
side by side in a row, before going to the next rows in the file to write
subsequent levels.</p>

<p class=B><span class=O>Save Text Bitmaps Clipped:</span> When this is set,
text files written will never end in spaces, i.e. any space characters that
would otherwise be at the ends of lines will be dropped. This makes the files
smaller but will still display and load back into Daedalus the same. This will
also not export the final newline at the end of the last line for DOS text
files, making it so in a DOS window there’s no extra blank line after the
display of such a file before the prompt.</p>

<p class=B><span class=O>Line Chars in Text Bitmaps:</span> This affects the
Save Text command. When set, on pixels won’t always just be written as “#”
characters, but rather horizontal walls will be “-”, vertical walls will be “|”,
and everything else will be “+”.</p>

<p class=B><span class=O>Save Text Bitmaps Tabbed:</span> This adjusts plain
text format bitmap file saves and clipboard copies to have a tab in between
each character. That allows text bitmaps to be more easily opened or pasted
into Microsoft Excel, with one cell per bitmap pixel.</p>

<p class=A><span class=N>Open Documentation:</span> This launches the default
Web browser and has it automatically open this Daedalus documentation file.</p>

<p class=A><span class=M>More Help:</span> This submenu has commands which show
additional more advanced or more specialized documentation.</p>

<p class=B><span class=N>Open Scripting:</span> Launches the default Web
browser and has it automatically open the scripting documentation file.</p>

<p class=B><span class=N>Open Changes:</span> Launches the default Web browser and
has it automatically open the Daedalus latest changes file.</p>

<p class=B><span class=N>Open License:</span> Launches the default Web browser
and has it open the Daedalus license file, displaying legal information on how
you can use the program. Daedalus uses the GNU General Public License (GPL).</p>

<p class=B><span class=N>Open Website:</span> Launches the default Web browser
and has it automatically open the Daedalus Web site at <a
href="http://www.astrolog.org/labyrnth/daedalus.htm">http://www.astrolog.org/labyrnth/daedalus.htm</a>.</p>

<p class=B><span class=N>Open Website Mirror:</span> Launches the default Web
browser and has it automatically open the alternate Daedalus Web site at <a
href="http://www.magitech.com/astrolog/labyrnth/daedalus.htm">http://www.magitech.com/astrolog/labyrnth/daedalus.htm</a>.</p>

<p class=A><span class=M>Setup:</span> This submenu has commands which help
setup the program in the Windows environment.</p>

<p class=B><span class=N>Create Program Group (User):</span> Creates a “Daedalus”
folder on the Windows Start / All Programs menu. In this folder will be
shortcuts to the Daedalus executable, shortcuts to the three documentation
files (standard program usage, scripting, and latest changes), and a shortcut
to the Daedalus Web site. It will also contain a Scripts subfolder containing
shortcuts to the 28 scripts that come with the program. This program group will
only be visible to the current user.</p>

<p class=B><span class=N>Create Program Group (All):</span> This is identical
to the Program Group (User) command, except the folder created is visible to
all users logged into Windows instead of just the current user. The former
command should always succeed, while permission to create a program group for
all users may be restricted on Vista and newer versions of Windows. Hence
Daedalus may need to be run as Administrator to avoid this command failing and
displaying an error message.</p>

<p class=B><span class=N>Create Desktop Icon:</span> Creates a shortcut on the
Windows desktop pointing to the current location of the Daedalus executable.
For the DAE34HGS.EXE “Hunger Games” download which includes an extra directory
of bitmap and sound files for the “Hunger Games” script, this command will also
produce a desktop icon pointing to that script.</p>

<p class=B><span class=N>Install File Extensions:</span> Registers Daedalus in
the system registry as the owner for the file extensions .ds (Daedalus
scripts), .d3 (Daedalus 3D bitmaps), .dp (Daedalus patch files), and .dw
(Daedalus wireframe files). Double clicking on such files, or right clicking
their icon and selecting “Open”, will have Daedalus launch and open them. Right
clicking Daedalus files and selecting “Edit” will have Notepad launch and open
the file. These files will also be given a Daedalus icon of a simple Maze.</p>

<p class=B><span class=N>Uninstall File Extensions:</span> This command can be
used to help uninstall Daedalus. It will remove all Daedalus specific
information from the Windows registry, undoing that which was added by the Install
File Extensions command.</p>

<p class=A><span class=N>About Daedalus...:</span> This dialog brings up the
About box for Daedalus which contains static text showing the credits and
copyrights for the program, and whether the program is 32 or 64 bit. Note that
if you compile and run the debug version of the program, the title bar of this
dialog will have the text “(DEBUG)” added to it.</p>

<p class=A><span class=N>Exit:</span> This immediately terminates and closes
the program.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menuedit>DAEDALUS MENU COMMANDS - EDIT MENU</a></p>

</div>

<p class=A><span class=M>Edit Menu:</span> This deals with all low level
operations of the program. This includes clipboard commands, random number
settings, and the program’s timer. It also deals with fundamental display
settings, such as the color palette being used, and how to draw the current
bitmap being viewed.</p>

<p class=A><span class=N>Repeat Command:</span> This runs again the most recent
command selected, regardless of whether it was invoked from a menu or a
keyboard shortcut. This can be used to do multiple times a menu command that
doesn’t already have a keyboard shortcut.</p>

<p class=A><span class=N>Autorepeat:</span> This makes the program enter a mode
where it will continually repeat over and over the most recent command selected
that’s autorepeatable. Run this command again to turn off autorepeat. Basically
any command that has a visible effect when done multiple times can be
autorepeated. For example inverting the screen or moving the dot in some
direction can be autorepeated, however just clearing the screen or teleporting
the dot to the corner of the bitmap can’t be. Autorepeat can for example be
used to do a Maze “spree” and generate new random Mazes one after another. The
individual commands on the Infinite submenu are Maze types, where you can enter
Autorepeat mode after running the Infinite Continue command once, to keep on
making an infinite Maze larger. See the Autorepeat Randomizes Wall Color
checkbox in the Set Colors dialog for a way to make each Maze a different
color. Other good autorepeatable commands are Left, Right, and Random; these
make for a good demo, especially in the 3D first person inside view. For
example, turn on View Inside, do Move Random once, then turn on Autorepeat, and
watch yourself continually wander through the Maze taking random choices at
junctions.</p>

<p class=A><span class=M>Macros:</span> Daedalus features its own macro
language, which can be used to automate actions, and even design whole games or
other programs using Daedalus as a platform. This submenu allows access to
these features. Note the following definitions: A command line is a string of
text containing a sequence of actions. An action is an individual instruction
that tells Daedalus to run a menu command, set a dialog variable, or even
access an extra feature which isn’t available through the standard user
interface. A macro is a command line stored in a special place which can be
executed at any time. A script is a file containing a sequence of command
lines. An event is an occurrence in the program which can be made to
automatically trigger a macro execution.</p>

<p class=B><span class=N>Enter Command Line...:</span> This dialog allows one
to enter a command line, to either be executed right away or assigned to a
macro.</p>

<p class=C><span class=O>Enter Command Line Below:</span> Enter the command
line string you want to have executed or assigned to a macro in this field. If
the dialog is closed with the OK button, the contents of this command line will
immediately be executed. The format of the actions composing a command line is
complex, where details of the Daedalus scripting language are covered in the
separate documentation file script.txt.</p>

<p class=C><span class=O>Get Macro:</span> This button will get the contents of
the Macro specified by the Number field, and populate the Enter Command Line
field with it, and also the Menu Text field with the current menu text for it
from the appropriate Run Macro submenu. This allows examining or modifying
existing macros.</p>

<p class=C><span class=O>Define Macro:</span> This button will change the
contents of the Macro specified by the Number field to be the contents of the
Enter Command Line field, and also set the menu text for that macro’s menu
command to be the text in the Menu Text field. Note macros defined through this
button persist even if the dialog is closed with Cancel.</p>

<p class=C><span class=O>Number:</span> When assigning or getting the contents
of a macro through the Define Macro or Get Macro buttons, enter the number of
the macro to set or query here. Note that this field may also be a command line
expression. For example, if the World’s Largest Maze script has been loaded,
then instead of having to be a specific number, it can be an expression like
“%FHelp”, in which case the custom constant will be evaluated, instead of one
having to manually determine the macro slot number containing the command line
labeled FHelp.</p>

<p class=C><span class=O>Menu Text:</span> When assigning or getting the
contents of a macro through the Get Macro or Define Macro buttons, the menu
text for the macro’s command on the appropriate Run Macro submenu goes in this
field. Note the “&amp;” character here means a keyboard accelerator, which on
the menu gets displayed as an underscore beneath the character following it.
There are 48 menu commands, however Daedalus supports any number of macros. If
you assign or get a macro not between 1 and 48, the Menu Text field is ignored.</p>

<p class=C>Note a command line is automatically run every time Daedalus starts.
Any text after the program name in a Windows shortcut, or anything after the
program name if Daedalus is started from a DOS command prompt, will be treated
as a command line and executed once the program begins. The icons which run the
Daedalus demos and games are just shortcuts to the Daedalus executable, with a
command line appended to open the appropriate script on startup.</p>

<p class=B><span class=N>Open Script...:</span> This opens a Daedalus script
file and runs it. Daedalus comes with a number of sample scripts which demo
features of the program or play games.</p>

<p class=B><span class=M>Run Macro:</span> There are four Run Macro submenus,
each of which contain twelve commands to run a particular macro. Daedalus has
48 macro slots attached to menu commands, which start out empty, but can have
command lines assigned to them automatically by script files or manually
through the Enter Command Line dialog. Usually a macro will be invoked through
its keyboard shortcut, e.g. press F1 through F12 to run macros 1 through 12,
Shift+F1 through Shift+F12 for macros 13 through 24, and so on.</p>

<p class=C>Note some macro commands have the same keyboard shortcuts as system
behavior. If a macro exists in such a slot, the Daedalus behavior will replace
the system behavior. Pressing Alt+F4 will run macro #40 if present, else it
exits the program. Pressing F1 will do the same as the Open Documentation
command, if there isn’t already something defined in macro slot #1. One can
press F1 in any script as well as the program itself to get help for the
current environment.</p>

<p class=B><span class=N>Macro Events...:</span> This dialog allows macros to
be assigned to various events in the program, which get automatically executed
whenever the trigger condition occurs. If a field is set to zero, that means no
macro will run for that event, otherwise the specified macro will run.</p>

<p class=C><span class=O>On Move off Bitmap:</span> This event occurs whenever
the dot is on the bitmap, and is moved off one of the edges. Note if Edge
Behavior is set to Stop At Edge, the dot will automatically stop before this
gets a chance to run.</p>

<p class=C><span class=O>On Move into Wall:</span> This event occurs whenever
the dot runs into a wall, i.e. it’s directed to move to an on pixel and that
movement is prevented. Note if Walls Impassable is off, this event will never
run since the dot will be able to move through walls.</p>

<p class=C><span class=O>On Move to New Cell:</span> This event occurs whenever
the dot is about to move to a new cell or pixel. Minor movement within a cell
in the Free Movement modes in perspective inside view won’t trigger this.</p>

<p class=C><span class=O>After Move to New Cell:</span> This event occurs after
the dot moves to a new cell or pixel. This event always happens soon after the
On Move To New Cell event.</p>

<p class=C><span class=O>On Follow to New Cell:</span> This event is similar to
On Move To New Cell, and occurs whenever the dot is about to automatically move
to a new cell due to following a passage when the Follow Passages setting is
on, or when Follow Passages is simulated by pressing Shift+up or down in first
person view to run to the next junction.</p>

<p class=C><span class=O>After Redraw Inside:</span> This event happens
whenever a screen redraw happens in the perspective inside view. This can for
example be used to add custom text on the screen, e.g. your score in a game
script.</p>

<p class=C><span class=O>On Redraw Inside:</span> This event happens whenever a
screen redraw happens in the perspective inside view. It happens after the
bitmap is created in color bitmap -4, but before the After Redraw Inside events
is fired allowing one to add text on top of the bitmap. This allows one to
modify color bitmap -4, before it gets displayed.</p>

<p class=C><span class=O>On Run Command:</span> This event occurs whenever any
command is run, selected from either a menu or a keyboard shortcut.</p>

<p class=C><span class=O>On Left Mouse Click:</span> This event happens
whenever the left mouse button is clicked inside the drawable or client area of
the window.</p>

<p class=C><span class=O>On Right Mouse Click:</span> This event happens
whenever the right mouse button is clicked inside the drawable or client area
of the window.</p>

<p class=C><span class=O>On Middle Mouse Click:</span> This event happens
whenever the middle mouse button is clicked inside the drawable or client area
of the window. For most Microsoft mice, this means pressing down the mouse
wheel.</p>

<p class=C><span class=O>On Previous Mouse Click:</span> This event happens
whenever the “previous” mouse button is clicked inside the drawable or client
area of the window. For some mice, this is the small button on the left hand
side of the mouse closest to you or toward the bottom.</p>

<p class=C><span class=O>On Next Mouse Click:</span> This event happens
whenever the “next” mouse button is clicked inside the drawable or client area
of the window. For some newer mice, this is the small button on the left hand
side of the mouse farthest away from you or toward the top.</p>

<p class=C><span class=O>On Mouse Move:</span> This event happens whenever the
mouse pointer is moved within the Daedalus window. It covers both simple motion
and when a mouse button is held down while dragging.</p>

<p class=C><span class=O>On Program Exit:</span> This event occurs whenever the
program is about to terminate.</p>

<p class=A><span class=N>Copy Bitmap:</span> This copies the main bitmap to the
Windows clipboard as a monochrome Windows bitmap. If Show Color Bitmap is on,
this instead copies the color bitmap to the Windows clipboard as a 24 bit color
Windows bitmap. The contents put on the clipboard are the same as generated by
the Save Bitmap command. Note an alternate way to print out a bitmap if you don’t
like the behavior of the Print command, is to copy it to the clipboard, paste
it into another program such as Paint or Word, and print from there. Or save
the bitmap and then load it into the other program.</p>

<p class=A><span class=N>Copy Text:</span> This copies the main bitmap to the
Windows clipboard as plain text. The contents put on the clipboard are the same
as generated by the Save Text command.</p>

<p class=A><span class=N>Paste:</span> This pastes from the Windows clipboard
into the program. A bitmap on the clipboard will be pasted into the main or
color bitmap appropriately, where this behaves like the Open Bitmap command. If
there is no bitmap in the clipboard, then if there’s text on the clipboard, it
will be pasted into the main bitmap, and will behave like the Open Text
command.</p>

<p class=A><span class=N>Display Settings...:</span> This dialog sets how to
display the current bitmap being viewed, and also deals with other low level
redraw and screen update settings.</p>

<p class=B><span class=O>Entire Bitmap:</span> This is a radio button in the “what
to draw” group. When selected, the entire bitmap will always be drawn in the
window.</p>

<p class=B><span class=O>Certain Number of Pixels:</span> This is a radio
button in the “what to draw” group. When selected, a particular number of
bitmap pixels will always fill the window. Resizing the window won’t show any
more of the bitmap, but will instead change the size of those pixels seen. The
number of horizontal and vertical pixels is specified in the Horizontal &amp;
Vertical Pixel Value settings. The display of the bitmap will also be centered
on the dot.</p>

<p class=B><span class=O>Certain Size of Pixels:</span> This is a radio button
in the “what to draw” group. When selected, all bitmap pixels will be a certain
number of screen pixels in size. Resizing the window won’t change the size of
the pixels, but will instead show more or fewer pixels of the bitmap. The
number of horizontal and vertical pixels is specified in the Horizontal &amp;
Vertical Pixel Value settings. The display of the bitmap will also be centered
on the dot.</p>

<p class=B><span class=O>Fixed Size of Pixels:</span> This is a radio button in
the “how to draw it” group. This sets the screen size of each pixel in the
bitmap, where the horizontal and vertical size is specified in the Horizontal
and Vertical Pixel Value settings. Selecting this only plays a role when “what
to draw” is set to Entire Bitmap.</p>

<p class=B><span class=O>Largest Square Size:</span> This is a radio button in
the “how to draw it” group. When selected, whatever part of the bitmap is being
drawn will have each bitmap pixel be the largest square size it can be and
still fit inside the window. In other words each bitmap pixel will be the same
size, and each will be a square.</p>

<p class=B><span class=O>Largest Rectangular Size:</span> This is a radio
button in the “how to draw it” group. When selected, whatever part of the
bitmap is being drawn will have each bitmap pixel be the largest rectangular
size it can be and still fit inside the window. In other words each bitmap
pixel will be the same size, however they may be rectangles instead of squares
depending on the size of the window.</p>

<p class=B><span class=O>Stretch to Window:</span> This is a radio button in
the “how to draw it” group. When selected, whatever part of the bitmap is being
drawn will be stretched to exactly fill the window. This may make each bitmap
pixel cover a slightly different amount of area of the screen. Note for this
setting only, the dot will never be shown, even when the Show Dot flag is on.</p>

<p class=B><span class=O>Horizontal Pixel Value &amp; Vertical Pixel Value:</span>
These numbers indicate the screen size of each bitmap pixel, or the number of
bitmap pixels to show. They are only used when Certain Number Of Pixels,
Certain Size of Pixels, or Fixed Size of Pixels are set.</p>

<p class=B><span class=O>Show Color Bitmap:</span> This does the same thing as
the menu command of the same name on the Color menu. Having it here too allows
you to see and set all these display related settings at once.</p>

<p class=B><span class=O>Horizontal Size &amp; Vertical Size:</span> These
values indicate the horizontal and vertical pixel size of the Daedalus window
itself. You can change these to resize the window.</p>

<p class=B><span class=O>Horizontal &amp; Vertical Offset:</span> These two
values indicate the horizontal and vertical screen pixel location of the upper
left corner of the Daedalus window itself. You can change these to move the
window. The Size Is Drawable Area flag controls whether this means the corner
of the drawable or client area in the window, or the entire Daedalus window
including the title bar and border.</p>

<p class=B><span class=O>Horizontal &amp; Vertical Scroll:</span> These two
fields indicate the position of the window’s horizontal and vertical
scrollbars. You can change these to move the scrollbars. The scrollbars can be
in 17 possible positions, where a value of zero means all the way to the left
or top, and 16 means all the way to the right or bottom.</p>

<p class=B><span class=O>Size Is Drawable Area:</span> When this is set, the
Horizontal &amp; Vertical Size values above indicate the size of the drawable
or client area in the Daedalus window. When this is unset, the Horizontal &amp;
Vertical Size values indicate the size of the entire Daedalus window including
the title and menu bars, window border, and so on.</p>

<p class=B><span class=O>Window Always on Top:</span> When this is set, the
Daedalus window will always be on top of every other window on the screen,
including the Windows taskbar and even when the Daedalus window is not active.
The full screen mode feature automatically sets this.</p>

<p class=B><span class=O>Hide Menu:</span> This controls whether the menu bar
is displayed at the top of the window. When off, the main menu can no longer be
pulled down, although commands can still be run through keyboard shortcuts.
Game scripts often turn off the menu, to create a less cluttered environment.</p>

<p class=B><span class=O>Hide Scrollbars:</span> This controls whether the
scroll bars are displayed at the bottom and right of the window. When off, the
scrollbars can no longer be seen or manipulated, although their existing
positions still take effect. Game scripts often turn off the scrollbars, since
the scrollbar positions don’t affect the first person view any.</p>

<p class=B><span class=O>Redraw When Bitmap Edited:</span> Normally whenever
you do an operation which changes the contents of a bitmap, the screen will
immediately update to reflect the current state of the bitmap. When this is
unset, the screen won’t update until you tell it to with the Redraw Now menu
command. This allows you to do things such as create a Maze to solve without
giving yourself any hint as to what it looks like ahead of time.</p>

<p class=B><span class=O>Allow Partial Screen Updates:</span> Normally whenever
you run a command, the screen won’t update until the command is completely
finished. Certain commands, such as most of the Maze creation methods, reach
intermediate states during their running. When this is set, the screen will
update to the current state of the bitmap at each of these points. This can
allow you to see more things happening while running a command that takes a
while to finish.</p>

<p class=B><span class=O>Show Individual Pixel Edits:</span> This is a more
extreme version of Allow Partial Screen Updates. When this is set, each and
every time a bitmap pixel changes during any command you’ll see it happen on
the screen. This allows you to see every thing a command does, e.g. you can see
how certain Maze creation or solving algorithms work. However, computationally
intensive operations on the bitmap like Maze creation will run about five times
slower.</p>

<p class=C>This setting also affects the perspective inside view. For the
Simple Perspective inside view mode, one can watch the scene get drawn. For the
other inside view modes, this has no effect except one may notice the compass,
location, or script produced text flicker during redraws.</p>

<p class=B><span class=O>Pixel Display Delay:</span> This is an animation delay
for when Show Individual Pixel Edits is active. This delay also applies when
Follow Passages in the Dot Settings dialog is on, and the dot is being shown.
The higher the value, the longer the delay between visible pixel changes, and
the longer the delay between automatic movement of the dot down a passage. Note
a big number here can make whatever action take a long time to finish. See the
Redraw Window command for a way to gain control again if the action is taking
too long.</p>

<p class=B><span class=O>Error Check Pixel Operations:</span> When this is set,
the program will make various checks to assert the program state and commands
are running as expected, and display an Assert error message if anything is
bad. It will also check to ensure no memory gets leaked by the program, which
means if there are any bugs where a piece of memory doesn’t get freed, an error
message will be displayed when the program exits.</p>

<p class=B><span class=O>Hourglass Cursor on Redraw:</span> When this is set,
then commands that may take a long time to complete such as Maze creation will
bring up the wait or hourglass mouse pointer during their execution. Having
this off might be preferred when Autorepeat is on, where you may not want the pointer
flashing all the time as Mazes or whatever are created over and over.</p>

<p class=B><span class=O>Autorepeat Last Command:</span> This does the same
thing as the Autorepeat menu command on the Edit menu.</p>

<p class=B><span class=O>Repeat Delay in Msec:</span> This value indicates the
time interval in milliseconds that the program will try to automatically do
certain operations. This includes commands repeated by the Autorepeat command,
dot movement done when the Chase Mouse Point checkbox is set, and screen
updates during the Very Free Movement perspective inside mode. If this is set
to 1000 for example, then the Autorepeat command will generate no more than one
Maze or whatever per second. Lowering this value can speed these things up.</p>

<p class=C>This field may be set to zero, which will make the program not pause
at all between successive iterations of the operation being autorepeated, and
continually do them in a tight loop until you specify otherwise. On Windows 9x
systems Daedalus won’t even ever yield to other programs and give them a chance
to do anything, and even on newer systems Daedalus will use maximum CPU time.
When not doing anything else with your computer a zero timer delay can be
useful, and make the program run around twice as fast as when it’s set to
anything higher.</p>

<p class=B><span class=O>Pause Timer:</span> This does the same thing as the
menu command of the same name on the Edit menu.</p>

<p class=B><span class=O>Skip Message Display:</span> This does the same thing
as the Ignore Messages menu command on the Edit menu.</p>

<p class=B><span class=O>Allow Sound Playing:</span> When this is off, all
sound playing is disabled. This setting is used by the “Hunger Games” script
which plays sounds, allowing all sound playback to be turned off at once.</p>

<p class=A><span class=M>Cell Viewport Span:</span> This submenu has commands
with which one can easily zoom in or out on the dot in the display. Each
command will automatically set the Display Settings dialog “what to draw”
section to Certain Size Of Pixels, and will increase or decrease the Horizontal
and Vertical Pixel Values. In other words the display will become centered on
the dot if not already, and the number of screen pixels each bitmap pixel
covers on the screen, will go up or down a certain amount.</p>

<p class=B><span class=N>Decrease By 1 &amp; Increase By 1 &amp; Decrease By 10
&amp; Increase By 10:</span> These four commands take the screen pixel size of
each bitmap pixel and increase or decrease them by one or ten.</p>

<p class=A><span class=M>Window:</span> This submenu has commands that affect
the Daedalus window.</p>

<p class=B><span class=N>Size Window Full Screen:</span> This toggles the
program in and out of full screen mode. In full screen mode the entire screen
is covered by the drawable or client area of the Daedalus window, where no
other window or even the program’s menu bar will be visible. The menu still
exists off the top of the screen, and can be pulled down and viewed with the
Alt and arrow keys. Note that this command may generate an error message,
because some versions of Windows don’t support entering full screen mode, at
least not unless the program is running as Administrator or with elevated privileges.</p>

<p class=B><span class=N>Size Window to Bitmap:</span> This resizes the window
to be the same size as the active bitmap at its current pixel zoom. It’s the
same as if the window were resized so that all of the bitmap is visible and no
border area is showing around the bitmap in the window.</p>

<p class=B><span class=N>Size Bitmap to Window:</span> This resizes the bitmap
to be the same size as the window’s drawable or client area. It’s the same as
using the Size dialog to set the dimensions of the active bitmap to the
horizontal and vertical size of the window as seen in Display Settings.</p>

<p class=B><span class=N>Update Window:</span> This forces the screen to
redraw. If the Redraw When Bitmap Edited flag is off, the screen won’t normally
update when a command is run, in which case this command will update the screen
to the state of the bitmap.</p>

<p class=B><span class=N>Redraw Window:</span> This simply redraws the current
screen. Most often this will have no visible effect, although it will trigger
the After Redraw Inside macro event if set.</p>

<p class=C>Pressing the space bar, i.e. running this Redraw Window command,
will interrupt moving down a passage in Follow Passages mode. When moving down a
passage to the next junction, that can sometimes take a while, say in a large
Unicursal Maze. If you want to stop the animation and get control again, press
space to stop the dot in its tracks. Pressing the space bar also affects the
Show Individual Pixel Edits setting when the Pixel Display Delay is non-zero. A
large Pixel Display Delay can make whatever command take a long time to finish.
If you want to stop waiting, press space to drop the Pixel Display Delay value
to zero.</p>

<p class=B><span class=N>Scroll Page Up:</span> This move the vertical
scrollbar half way up.</p>

<p class=B><span class=N>Scroll Page Down:</span> This moves the vertical
scrollbar half way down.</p>

<p class=B><span class=N>Scroll to Beginning:</span> This moves both scrollbars
to the upper left corner of the window.</p>

<p class=B><span class=N>Scroll to End:</span> This moves both scrollbars to
the lower right corner of the window.</p>

<p class=A><span class=N>Set Colors...:</span> This dialog allows changing the
colors used in the various displays in the program.</p>

<p class=B><span class=O>Border:</span> The border color is the color used for
all parts of the window not covered by the bitmap, i.e. what covers the
remainder when the section of bitmap displayed doesn’t fill the entire window.</p>

<p class=B><span class=O>Passage:</span> The passage color is the color of
passages in Mazes, i.e. the general “off” pixel color for monochrome bitmaps.
This is also the color of informational text displayed in perspective inside view.</p>

<p class=B><span class=O>Wall:</span> The wall color is the color of walls in
Mazes, i.e. the general “on” pixel color for monochrome bitmaps. This is also
the background color surrounding text displayed in perspective inside view. If
Passage and Wall color are the same, then the text will be drawn with a
transparent background.</p>

<p class=B><span class=O>Dot:</span> When the dot is visible over one of the
pixels as when Show Dot is on, this is the color of the dot.</p>

<p class=B><span class=O>Overlay:</span> For the 3D first person view, this is
the color of walls in the map overlay.</p>

<p class=B><span class=O>Inside Wall:</span> For the 3D first person view, this
is the color of the walls for 2D Mazes. It’s also the color of floor markings
as set with Mark ‘X’ At Dot for 3D Mazes.</p>

<p class=B><span class=O>Inside Sky:</span> For the 3D first person view, this
is the color of the sky or ceiling for 2D Mazes. It’s also the color of the sky
or ceiling on the top level of 3D Mazes.</p>

<p class=B><span class=O>Inside Ground:</span> For the 3D first person view,
this is the color of the ground or floor.</p>

<p class=B><span class=O>Inside Line:</span> For the 3D first person view, this
is the color of edges or corners between walls when in Simple Perspective mode.
It’s also the color of entrances and exits when Sealed Entrances is set.</p>

<p class=B><span class=O>Inside 3D Wall:</span> For the 3D first person view,
this is the color of the walls for 3D Mazes. It’s also the color of floor
markings as set with Mark ‘X’ At Dot for 2D Mazes.</p>

<p class=B><span class=O>Inside 3D Ceiling:</span> For the 3D first person
view, this is the color of the ceiling for all levels excluding the top level
of 3D Mazes.</p>

<p class=B><span class=O>Inside Mountain:</span> For the 3D first person view,
this is the color of mountains, as seen when Mountains in Inside Settings is
on.</p>

<p class=B><span class=O>Inside Fog:</span> For the 3D first person view, this
controls what color walls fade into in the distance, as seen when Fog Distance
in Inside Settings is active. The color black works well with a black night
sky, where the walls seem to disappear into darkness. The color gray works well
with a gray sky, where walls appear to emerge from mist.</p>

<p class=B><span class=O>Autorepeat Randomizes Wall Color:</span> If this is
set, then when the Autorepeat command is active, the wall color will be set to
a random color of the rainbow before whatever command is run. In other words
when autorepeating a Maze generation command this makes each Maze a different
color.</p>

<p class=A><span class=N>Ignore Messages:</span> Daedalus commands sometimes
bring up message boxes giving information about what it just did. For example,
the Mark Dead Ends command will tell how many sections were marked. This
command toggles whether such messages are displayed. When Ignore Messages is
checked, no such messages will pop up. If for example you want to do the Mark
Dead Ends command over and over, having to dismiss the message box again and
again would be inconvenient, in which case turning on Ignore Messages would be
useful. Note this doesn’t prevent the display of error messages, or commands
such as Count Pixels whose sole purpose is to print a message.</p>

<p class=A><span class=N>Query Timer:</span> Daedalus keeps track of how much
time has elapsed since the program was started. This displays the value of that
timer to the nearest second.</p>

<p class=A><span class=N>Reset Timer:</span> This resets the timer back to
zero. An example use is to time how long it takes you to get through a Maze.
Create or load a Maze, do Reset Timer, solve it, then Query Timer and see how
long it took you.</p>

<p class=A><span class=N>Pause Timer:</span> This toggles whether the timer is
paused. Do the command once to pause the timer. Do the command again to unpause
it. While paused the amount of seconds elapsed will not increase. An example
use is if you need to answer the phone while in the middle of timing yourself
through a Maze.</p>

<p class=A><span class=N>Random Settings...:</span> This dialog allows changing
of settings related to the random number generator in Daedalus.</p>

<p class=B><span class=O>Random Seed:</span> This specifies what sequence of
numbers will be produced by the random number generator. If you have set this set
to a particular number and then create random Mazes, the same Mazes will always
be produced in the same sequence. If this field is blank, then the random
number seed won’t be set and the current state of the random number generator
won’t be touched.</p>

<p class=B><span class=O>Random Bias:</span> This allows most styles of random
Mazes created to be passage biased. A biased Maze has straightaways that tend
to go along one axis more often than at other angles. When this value is
positive, Mazes will be horizontally biased, and when this is negative, Mazes
will be vertically biased. The farther the value from zero, the more extreme
the bias. A value of zero means no bias. For 3D and 4D Mazes, a large bias will
cause there to be fewer jumps between levels.</p>

<p class=B><span class=O>Random Run:</span> This allows some styles of random
Mazes created to have a “run” factor. The run of a Maze means how long
straightaways tend to go before forced turnings present themselves. A Maze with
a low run won’t have straight passages for more than three or four cells, and
will look very random. A Maze with a high run will have long passages going
across a good percentage of the Maze, and will look similar to a microchip. The
more this value is greater than zero, the higher the run.</p>

<p class=A><span class=N>Randomize Seed:</span> This truly randomizes the
Random Seed setting, by setting it to a random number based on the system
clock. If you do Randomize Seed then create a Maze, the Maze that’s created
will be different each time. Without doing Randomize Seed, Daedalus will always
create the same sequence of Mazes. This command also causes the stars,
mountains, and clouds in perspective inside view to be randomly regenerated, in
the same way their positions are randomly set when starting the program.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menudot>DAEDALUS MENU COMMANDS - DOT MENU</a></p>

</div>

<p class=A><span class=M>Dot Menu:</span> This contains everything dealing with
“the dot”. The dot is like a cursor positioned over a particular pixel on the
bitmap. The dot can be moved around, the bitmap can be edited based on the dot,
and special displays can be centered on the dot like the 3D first person inside
view where the dot indicates where you are.</p>

<p class=A><span class=N>Dot Settings...:</span> This dialog controls many
settings related to the dot. This means its location, how the dot moves, and
how to draw on the screen using the dot as a paintbrush. The dialog contains a
line of text telling what color pixel the dot is over. This will either be
on/off or the appropriate color or RGB value, depending on whether the color
bitmap is active.</p>

<p class=B><span class=O>Horizontal &amp; Vertical:</span> These values contain
the X and Y pixel locations of the dot. The upper left corner is coordinate (0,
0).</p>

<p class=B><span class=O>Height:</span> This value contains the Z location of
the dot. This only plays a role in 3D bitmaps.</p>

<p class=B><span class=O>Direction:</span> This value contains the direction
the dot is facing. The number 0 means Up or North, 1 means Left or West, 2
means Down or South, and 3 means Right or East. When you move the dot, this is
updated to the direction the dot last moved. This is used in the 3D first
person inside view to indicate which way you’re facing.</p>

<p class=B><span class=O>2nd Horizontal &amp; 2nd Vertical &amp; 2nd Height:</span>
These values contain the location of the second dot. See the 2nd Dot submenu
for more information about this second dot.</p>

<p class=B><span class=O>Bitmap Is 3D:</span> This does the same thing as the
menu command of the same name on the Bitmap menu. Having it here too allows you
to see and set all these dot related settings at once.</p>

<p class=B><span class=O>Show Dot:</span> This does the same thing as the menu
command of the same name on the Dot menu.</p>

<p class=B><span class=O>Dot Is Circle:</span> If this is set, then when the
dot is visible, it will be drawn as a circle over the pixel instead of a
square. This makes the dot look more like a dot and also allows seeing some of
the pixel behind it.</p>

<p class=B><span class=O>Dot Shows Arrow:</span> If this is set, an arrow will
be drawn on the dot in the direction the dot is facing, assuming the dot is
visible and large enough. The arrow will be drawn in the inside Line color from
the Set Colors dialog. If the Line color is the same as the Dot color, then
only the arrow will be drawn and the dot itself will be transparent.</p>

<p class=B><span class=O>Dot Size:</span> The size of the dot can be controlled
with this field. Normally when Show Dot is on, the dot covers just a single
pixel. The value here indicates the number of extra pixels to cover surrounding
the center pixel. For example, a value of 1 means to cover a 3x3 block of
pixels, 2 covers a 5x5 block, etc.</p>

<p class=B><span class=O>Walls Impassable:</span> This does the same thing as
the menu command of the same name on the Dot menu.</p>

<p class=B><span class=O>No Corner Hopping:</span> This setting only plays a
role when Walls Impassable is set. If this is set, you won’t be able to move
diagonally when the two adjacent pixels are on. In other words, picture a 2x2
grid of pixels, where two opposite corners are off and the other two opposite
corners are on. You will only be allowed to move diagonally from one off pixel
to the other one when this setting is unchecked. For Maze types which make use
of non-orthogonal walls like Crack Mazes you probably want this on. For Maze
types which make use of diagonal passages like Zeta Mazes you probably want
this off. Note No Corner Hopping also plays a role in a number of other
commands, where on usually means the command considers orthogonal connections
only, and off means diagonal connections are allowed too.</p>

<p class=B><span class=O>Glancing Blows:</span> If this is set, then when
moving diagonally, if the dot can’t move to the desired pixel (because it’s on
when Walls Impassable is set, or is off the screen when Stop At Edge is set)
the dot will move horizontally or vertically if possible. For example, if moving
the dot diagonally down and to the right, and it runs into a horizontal wall,
the diagonal movement commands will make the dot move to the right along the
wall.</p>

<p class=C>In addition to the standard overhead view, this setting also affects
the perspective inside view, where if you move into a wall, you’ll slide along
the wall as if it were made of ice, as opposed to stick to the wall as if it
were made of glue.</p>

<p class=B><span class=O>Chase Mouse Point:</span> When this is set, the dot
will continually try to move to where the mouse is pointing. This will only
happen when the dot is actually visible, and the dot will move one pixel at a
time at the rate indicated in the Repeat Delay value in the Display Settings
dialog. This allows you to move through a Maze, or draw on the screen, just by
moving the mouse around. Clicking the right mouse button will toggle this
setting. In 3D first person inside view, this setting will act as if you’re
continually clicking the left mouse button in the window. See the Mouse Clicks
section for information on how clicking the mouse moves you in 3D inside view.</p>

<p class=C>If Glancing Blows and Walls Impassable are set too, the dot will
more readily flow around obstacles of on pixels. The dot will consider and
prioritize all directions that lead closer to the mouse, taking the first
option that’s unblocked.</p>

<p class=B><span class=O>No Mouse Diagonal:</span> When Chase Mouse Point is
on, having this set means the dot won’t move diagonally as it moves toward the
mouse pointer, but rather will only move horizontally or vertically. This helps
when drawing the solution to a Maze with the mouse, as it will ensure the
passages are orthogonal.</p>

<p class=B><span class=O>Follow Passages:</span> If this is set, then a dot
movement command will keep moving down the current passage through any turnings
until the next junction, instead of just moving one pixel at a time. This only
works for standard orthogonal 2D Mazes with passages one pixel wide. If when
automatically following a passage a dead end is reached, the dot will turn
around and go back the way it came. This allows you to move through Mazes much
faster, where all you have to do is make choices at the junctions. Note the
automatic moving down a passage will stop if the dot is ever over the location
of the second dot.</p>

<p class=B><span class=O>Radar Length:</span> This value only plays a role when
Follow Passages is set. With this, not only will the dot follow passages for
you, but it will also automatically pick which way to go at junctions in
certain cases. Basically the dot will use what amounts to “radar” and send
invisible feelers down each passage at a junction. If that passage is a short
blind alley, the dot will know not to consider going down it. For example, at a
junction where one way is a short dead end, and the other leads to the rest of
the Maze, the dot will go past that junction without stopping. The value here
indicates how far down each passage to look. A value of one means to skip all
dead ends one unit long. The higher the value, the more down each passage the
dot will scan to see if it’s a blind alley.</p>

<p class=B><span class=O>Move Count:</span> This value gets incremented every
time you move the dot with one of the Move Dot or Move Relative commands. This
is useful when solving a Maze, where you can set this field to zero, go through
the Maze, and see how many moves it took.</p>

<p class=B><span class=O>Move by Two &amp; Drag Move Dot &amp; Drag Is Erase
&amp; Drag Big Dot &amp; Drag by Two:</span> These do the same things as the
menu commands of the same name on the Dot menu. Having them here too allows you
to see and set all these settings at once.</p>

<p class=B><span class=O>Do Drag on Temp:</span> This affects the Drag Move Dot
setting as well as the Set At Dot command, and will cause it to edit the
temporary instead of the main or color bitmaps as you move the dot around. This
works well with the perspective inside view, where as you move around the
passages you visit will automatically be marked.</p>

<p class=B><span class=M>Edge Behavior:</span> This section of radio buttons
controls what the dot does when it runs off the edge of the bitmap.</p>

<p class=C><span class=O>Move into Void:</span> The dot can move off the bitmap
and can keep going in any direction forever.</p>

<p class=C><span class=O>Stop at Edge:</span> The dot can’t move off the
bitmap, and will stop when it reaches the bitmap edge as if it were a wall.</p>

<p class=C><span class=O>Torus Wrapping:</span> Moving the dot off the left
edge of the bitmap will make it reappear at the right edge and vice versa. The
top and bottom edges will wrap around to each other as well. Note Torus
Wrapping behaves the same as Move Into Void in the perspective inside view.</p>

<p class=A><span class=M>Move Dot:</span> This submenu contains the main
movement commands which move the dot by a single pixel.</p>

<p class=B><span class=N>Down Left &amp; Down &amp; Down Right &amp; Left &amp;
Right &amp; Up Left &amp; Up &amp; Up Right:</span> When a bitmap is being
shown, these eight commands move the dot by one pixel in each of the eight
compass directions. You’ll probably find it more convenient to use the keyboard
accelerators to move instead of selecting the commands from the menu. When
using the keyboard, you can use either the number keys, or the numeric keypad
(both with Num Lock on and Num Lock off). For the four main compass directions,
the four arrow keys will work too. The “5” key will do the same as the “2” key,
and can be used to move down as well. The orthogonal move commands will update
the Direction field in Dot Setting to be the direction moved in. The diagonal
move commands can update the direction too, and if need be will rotate it 90
degrees to ensure it’s one of the two compass directions adjacent to the diagonal.
For example if the current direction is west, and the dot moves southeast, the
direction will be set to south.</p>

<p class=C>In the 3D first person inside view, these commands will move the dot
relative to the direction you’re currently facing. Specifically Up will move
forward, Down will back up, Left will rotate left, and Right will rotate Right.
The diagonal movement commands will do a rotate plus a move: The Up Left and Up
Right commands will rotate left or right then move forward, and the Down Left
and Down Right commands will rotate right or left then back up. In the Free
&amp; Very Free inside display modes, and also in the Move with Arrow Keys mode
of the wireframe and patch renderings, the behavior is the same except moving
happens before rotating.</p>

<p class=B><span class=N>Raise &amp; Lower:</span> These two commands move the
dot up one level (to the next lower numbered level) and down one level (to the
next higher numbered level). When looking at the 3D first person inside view of
a 3D Maze, these commands are how you climb up through the ceiling or drop
through the floor to adjoining levels. Note this command only does something
when Bitmap Is 3D is set.</p>

<p class=A><span class=M>Move Relative:</span> The standard movement commands
on the Move Dot submenu do different things depending on what display mode you’re
in. The commands on this submenu move either relatively or absolutely
regardless of mode.</p>

<p class=B><span class=N>Forward:</span> This moves the dot forward by one
pixel in the direction the dot is facing. This is the same as Up on the Move
Dot submenu when in 3D inside view.</p>

<p class=B><span class=N>Back:</span> This moves the dot backwards by one
pixel, opposite the direction the dot is facing, while still facing forward.
This is the same as Down on the Move Dot submenu when in 3D inside view.</p>

<p class=B><span class=N>Turn Around:</span> This turns the direction the dot
is facing around 180 degrees. This affects overhead view, perspective inside
view, and the Move with Arrow Keys mode when moving around in a wireframe or
patch rendering. In the Smooth Movement perspective inside mode, the view will
rotate to the right or left at random when turning around.</p>

<p class=B><span class=N>Left:</span> This will follow the left wall for one
pixel. This means the dot will move one pixel to the left with respect to the
direction the dot is facing. If the space to the left is blocked by a wall, the
dot will move forward. If the space forward is blocked too, the dot will move
to the right. If the space to the right is yet again blocked, the dot will turn
around and move backward. This command works in 3D Mazes. Wall following can be
done in a deterministic way in a 3D Maze by projecting the 3D passages onto the
2D plane, i.e. by pretending up passages actually lead northwest and down lead
southeast, and then applying normal wall following rules.</p>

<p class=B><span class=N>Right:</span> This the same as Left, however the dot
will follow the right wall for one pixel.</p>

<p class=B><span class=N>Random:</span> This moves the dot one pixel in a
random direction. The dot won’t turn around and reverse its current direction,
or go through a wall i.e. through set pixels unless it has to. Also when
entering a room, the dot will stay next to and follow along an edge, so it
doesn’t wiggle randomly in the middle of the room.</p>

<p class=B><span class=N>North &amp; South &amp; West &amp; East:</span> These
four commands move the dot up, down, to the left, and to the right by one
pixel. These are the same as the Up, Down, Left, and Right commands on the Move
Dot submenu when in standard bitmap viewing mode.</p>

<p class=A><span class=M>Jump Dot:</span> This submenu has commands to move the
dot by a larger number of pixels at once.</p>

<p class=B><span class=N>Down Left &amp; Down &amp; Down Right &amp; Left &amp;
Right &amp; Up Left &amp; Up &amp; Up Right:</span> These eight commands are
like the corresponding commands on the Move Dot submenu, however these will
move the dot by 16 pixels at a time instead of just one. The same accelerator
keys for that submenu can be used here, except here the shift key needs to be
down.</p>

<p class=C>In 3D first person inside view, the Left and Right commands will
sidestep or strafe to the left and right. The Jump Up and Jump Down commands
will move forward and back up like how the standard Move Up and Move Down
commands do, however you’ll move as if the Follow Passages setting in the Dot
Settings dialog were toggled. In other words this is a quick way to follow a
passage to the next junction, without having to manually turn Follow Passages
on. The diagonal jump commands do nothing in 3D inside view.</p>

<p class=A><span class=M>Teleport Dot:</span> This submenu has commands to
teleport the dot to a particular location on the bitmap. They will also center
the dot within its current cell and snap its direction to the nearest compass
point, visible in the Free Movement perspective inside modes where your
direction and position within a cell can be arbitrary.</p>

<p class=B><span class=N>UL Corner &amp; UR Corner &amp; LL Corner &amp; LR
Corner:</span> These four commands move the dot to the four corners of the
bitmap, i.e. the upper left, upper right, lower left, and lower right.</p>

<p class=B><span class=N>Entrance:</span> This moves the dot to the entrance of
the Maze, assuming the bitmap contains a standard orthogonal Maze. This means
moving the dot to the first passage i.e. off pixel in the top row.</p>

<p class=B><span class=N>Exit:</span> This moves the dot to the exit of the
Maze, assuming the bitmap contains a standard orthogonal Maze. This means
moving the dot to the first passage i.e. off pixel in the bottom or second from
bottom row.</p>

<p class=B><span class=N>Left Entrance:</span> This is like the Entrance
command except it moves the dot to the first off passage in the leftmost
column.</p>

<p class=B><span class=N>Right Exit:</span> This is like the Exit command
except it moves the dot to the first off passage in the second from the right
column.</p>

<p class=B><span class=N>Middle:</span> This moves the dot to the center of the
bitmap, or the center of the middle level for a 3D bitmap.</p>

<p class=B><span class=N>Random:</span> This moves the dot to a random cell location
on the bitmap. If Solve Fillers Check Every Pixel in Maze Settings is on, this
will teleport to a random pixel within the bitmap area, instead of only
teleporting to pixels corresponding to the centers of cells.</p>

<p class=A><span class=N>2nd Dot:</span> This moves the dot to the location of
the second dot. See the 2nd Dot submenu for more information about the second
dot.</p>

<p class=A><span class=N>Show Dot:</span> When this is checked, the location of
the dot will be visible. The bitmap pixel corresponding to the dot will be
covered with the Dot color as indicated in the Set Colors dialog.</p>

<p class=A><span class=N>Walls Impassable:</span> When this is checked, the dot
movement commands will do nothing if they would cause the dot to move onto an
on pixel i.e. a wall. This allows you to solve a Maze by moving the dot through
it, while preventing you from accidentally moving through walls.</p>

<p class=A><span class=N>Move by Two:</span> When this is checked, the dot
movement commands will move the dot by two pixels instead of just one. Having
this on is useful when manually drawing a standard orthogonal Maze, because it
can keep the dot on even or odd numbered coordinates corresponding to walls or
passages. For example, combine this with Drag Big Dot, and have the dot on odd
numbered coordinates, to easily draw the outline of a Maze.</p>

<p class=A><span class=N>Drag Move Dot:</span> When this is checked, the dot
movement commands will cause the bitmap pixel under the dot to be set. This
allows you to draw on the bitmap by moving the dot around like a paintbrush.
When the color bitmap is being displayed, this will draw on the color bitmap,
and set pixels to either the Wall Color or the Passage Color as defined in the
Set Colors dialog, based on the Drag Is Erase setting.</p>

<p class=A><span class=N>Drag Is Erase:</span> When this is checked, having
Drag Move Dot on will turn the pixels under the dot off. When unchecked, having
Drag Move Dot on will turn the pixels under the dot on.</p>

<p class=A><span class=N>Drag Big Dot:</span> When this is checked, having Drag
Move Dot on will cause a 3x3 pixel rectangle around the dot to get set. In the
normal case when unchecked, just the pixel under the dot will get set. Having
this on is useful when manually drawing the outline for a standard orthogonal
Maze, because the three pixel wide brush is the width of a single passage with
a wall on either side.</p>

<p class=A><span class=N>Drag by Two:</span> This is similar to Move By Two in
that when checked the dot movement commands will move by two pixels instead of
one. Here however when Drag Move Dot is on this will set both dots moved over
instead of just the last one. Having this on is useful when manually drawing
the solution to a standard orthogonal Maze. Combine this with Drag Move Dot and
Drag Is Erase, and have the dot on the odd numbered coordinates corresponding
to passages, to easily draw passages while staying on odd numbered coordinates.</p>

<p class=A><span class=N>Set at Dot:</span> This simple command sets the pixel
at the location of the dot to the Drag Is Erase color. This is a simpler way of
setting a single pixel than turning Drag Move Dot on and moving once.</p>

<p class=A><span class=M>Zap Dot:</span> This submenu contains commands which
affect pixels in front of the direction the dot is facing. It’s as if the dot
shoots a weapon which does something to the first wall in front of it.</p>

<p class=B><span class=N>Destroy Wall:</span> This will turn off the first set
pixel in front of the direction the dot is facing. If you’re frustrated with
the difficulty of a Maze, this can allow you to smash through the wall you’re
looking at. ;) The above assumes the dot is over an off pixel. If the dot is
over a set pixel, this will do the opposite, and scan for the first off pixel
in front of the dot and turn it on.</p>

<p class=B><span class=N>Make Wall Semitransparent:</span> This will make the
first wall in front of the direction the dot is facing semitransparent. A semitransparent
wall can make a Maze easier to solve because you can see what’s behind it. See
the Semitransparent Walls section of the Inside Settings dialog for more
information on semitransparent walls.</p>

<p class=B><span class=N>Make Unsemitransparent:</span> This will make the
first semitransparent cell in front of the direction the dot is facing opaque.
This will make a semitransparent wall opaque and “clear away the fog” in the
case of a semitransparent passage.</p>

<p class=A><span class=M>2nd Dot:</span> This submenu has commands involving
the “second dot”. The second dot is like the dot, in that it’s an invisible
cursor positioned over a particular pixel on the bitmap. Some of the commands
here make use of two pixel locations, such as the line drawing command which
requires two points to draw the line between. All of these commands (except
Draw Disk and Circle) will instead operate on the color bitmap if the color
bitmap is being shown.</p>

<p class=B><span class=N>Set To Dot:</span> This sets the location of the
second dot to the location of the main dot.</p>

<p class=B><span class=N>Draw Line:</span> This draws a line between the main
dot and the second dot, in the color indicated by the Drag Is Erase setting.</p>

<p class=B><span class=N>Draw Block:</span> This draws a filled in rectangle
whose opposite corners are indicated by the main dot and second dot, in the
color of the Drag Is Erase setting. In 3D bitmaps this will draw a solid 3D
block between opposite corners of a cube.</p>

<p class=B><span class=N>Draw Box:</span> This draws a one pixel wide rectangle
whose opposite corners are indicated by the dot and second dot, in the color of
the Drag Is Erase setting.</p>

<p class=B><span class=N>Draw Disk:</span> This draws a filled in circle or
ellipse inside the bounding box whose opposite corners are indicated by the dot
and second dot, in the color of the Drag Is Erase setting.</p>

<p class=B><span class=N>Draw Circle:</span> This draws a one pixel wide circle
or ellipse inside the bounding box whose opposite corners are indicated by the
dot and second dot, in the color of the Drag Is Erase setting.</p>

<p class=B><span class=N>Get Section:</span> This takes the contents of the
main bitmap within the rectangle whose opposite corners are indicated by the
dot and second dot, and puts a copy of it in the temporary bitmap. This can
then be pasted back onto the main bitmap using the commands below to make
copies of sections of the bitmap.</p>

<p class=B><span class=N>Put at Dot:</span> This takes the contents of the
temporary bitmap, and copies it on top of the main bitmap. The contents will be
pasted at the location of the dot, where the dot will be the upper left corner
of the pasted section.</p>

<p class=B><span class=N>Put with Or:</span> This is like Put At Dot except the
contents of the temporary bitmap will be copied onto the main bitmap with a “logical
or” operation, where the pixels (or bits within pixels in the case of the color
bitmap) will be set if they’re set in either the main or the temporary bitmap.</p>

<p class=B><span class=N>Put with And:</span> This is like Put At Dot except
the contents of the temporary bitmap will be copied onto the main bitmap with a
“logical and” operation, where the pixels (or bits within pixels in the case of
the color bitmap) will only be set if they’re set in both the main and the
temporary bitmap.</p>

<p class=B><span class=N>Put with Xor:</span> This is like Put At Dot except
the contents of the temporary bitmap will be copied onto the main bitmap with a
“logical exclusive or” operation, where the pixels (or bits within pixels in
the case of the color bitmap) will be set if they’re set in the main bitmap or
the temporary bitmap, but not both.</p>

<p class=A><span class=N>View Inside:</span> When this is checked the window
will contain a 3D first person perspective view from inside the bitmap. When
unchecked, the window will contain the standard overhead view of the bitmap.
The perspective inside view will be drawn as if you’re standing within the
bitmap at the location of the dot, where on pixels are walls and off pixels are
passages or open spaces. This view is designed to allow you to solve a Maze as
if you were walking inside its passages. See the Inside Settings dialog for
additional information about and settings related to this view. Many of the
colors in this view can be changed in the Inside section of the Set Colors
dialog. If the dot is on a set pixel, i.e. you’re inside of a wall, the screen
will be filled with the color of the wall, which is like if the wall is a hedge
and you’re forcing your way through it.</p>

<p class=B>If the Edge Behavior setting in the Dot Settings dialog is set to
Torus Wrapping, then the inside view won’t stop at the edges of the bitmap, but
wrap around to the opposite edge like the surface of a torus. That makes the
inside view appear to repeat copies of the bitmap off into the distance
forever.</p>

<p class=A><span class=N>Map Inside:</span> This shows a map of the current
Maze overlaying the first person inside view (or the current level of the Maze
for 3D Mazes). This is not unlike the standard overhead view of the bitmap,
however the walls are always one pixel thick, the Maze is rotated so the
direction the dot is facing is up, and the Maze is offset so the dot is in the
middle of the screen. Most settings that affect the standard overhead view
affect the map overlay too. The dot will be shown with the same color and
shape, and the size of the passages are defined by the Horizontal &amp;
Vertical Pixel Value fields in Display Settings, i.e. are affected by the
commands on the Cell Viewport Span submenu.</p>

<p class=A><span class=N>Mark 'X' at Dot:</span> This allows you to mark your
path or “leave a trail of breadcrumbs” in the first person perspective inside
view. This will cause the floor section you’re over to be drawn in a different
color, or in the Simple Perspective inside display mode this will cause there
to be a large ‘X’ on the floor at your current location. Note you may not be
able to see an ‘X’ that’s at your feet because you’re looking forward, however
if you move and look back at the cell you were in you can see it. This is
implemented by turning on the pixel in the temporary bitmap at the location of
the dot. Basically every set pixel in the temporary bitmap that’s not set in
the main bitmap, will cause there to be a marking at that location in the
perspective inside view.</p>

<p class=A><span class=N>Erase 'X' at Dot:</span> This is like Mark ‘X’ At Dot
except it will erase any marking at your current location. In other words this
turns off the pixel in the temporary bitmap at the location of the dot.</p>

<p class=A><span class=N>Inside Settings...:</span> This dialog accesses all
settings dealing with the first person perspective inside view.</p>

<p class=B><span class=M>Inside Display Mode:</span> This section of radio
buttons controls whether and in what form the first person perspective inside
view is shown.</p>

<p class=C><span class=O>None:</span> When selected, this turns off the
perspective inside view. Instead the standard overhead view of the bitmap will
be shown.</p>

<p class=C><span class=O>Jumpy Movement:</span> When selected, this turns on
the perspective inside view. This is a genuine perspective rendering, and can
display open spaces, passages wider than a single pixel, or any other
arrangement of pixels accurately. This view is available for 2D and 3D bitmaps,
where in 3D bitmaps pits will be visible in the floor and ceiling indicating
passages to adjoining levels. In this mode, the walls will be shaded based on
what direction they’re facing. South facing walls will be lighter in color and
North facing walls will be darker. There are no separate lines drawn to
indicate edges, but the different sky and ground colors, along with the
shading, make the corners apparent. If the color bitmap exists, the color to
use for each wall piece, will be taken from the color at that location on the
color bitmap, instead of everything being based on the Inside Wall color in the
Set Colors Dialog. For example, run the Get From Bitmap command to copy the
main to the color bitmap, then bring up the Replace Color dialog and replace
the wall color i.e. white with one of the special blend sequences, and you’ll
have the wall colors gradually change as you go through the Maze. Passages
marked with the Mark ‘X’ At Dot command will have that whole floor section
drawn in a different color. The floor color here will be taken from the color
bitmap in the same way wall colors are.</p>

<p class=C><span class=O>Smooth Movement:</span> This is like Jumpy Movement
but will instead smoothly animate when you move and rotate. You will always be
in the center of a cell facing in one of the four compass directions, however
when you move or rotate you’ll see a number of intermediate frames. This can be
considered a combination of Jumpy Movement above where your vantage point is
always from the center of a cell facing in one of the compass directions, and
Free Movement below where you can be anywhere facing in any direction. This can
be considered the best of both worlds, where it takes a minimum of key presses
to move through the Maze, but the animation isn’t jumpy.</p>

<p class=C><span class=O>Free Movement:</span> This is a more advanced version
of Jumpy Movement, as it allows you to face in any direction instead of just
the four main compass directions, and allows you to stand at any location,
instead of only in the very middle of pixels. Because of this, the location and
direction of the dot is no longer enough to determine exactly where you are,
where the Offset fields in the Free Movement section of the dialog indicate where
within the current pixel you are and how far away from the nearest compass
direction you’re facing.</p>

<p class=C><span class=O>Very Free Movement:</span> This is just like Free
Movement, however moving around the Maze will feel more fluid, like playing a
video game. You don’t have to wait for key repeat to kick in, which means
holding down a key immediately continuously moves, and you can also hold down
two keys at once (e.g. move forward plus rotate) and have them both take
effect. The speed at which continuous movement happens is controlled by the
Repeat Delay In Msec field in Display Settings.</p>

<p class=C><span class=O>Simple Perspective:</span> This behaves like Jumpy
Movement, but the display will be created with a different algorithm. The
inside view here won’t be a true perspective rendering, and won’t display views
of open spaces within a Maze very well. It’s really only good for views down
one pixel wide passages in standard orthogonal Mazes. In this mode, the walls
are always the same coloring, where there are lines drawn to indicate edges.
That can make this mode more suitable for black and white printing. If the
color bitmap exists, the color to use for all walls, will be taken from the
color at your location on the color bitmap, instead of from the Inside Wall
value in the Set Colors Dialog. Passages marked with the Mark ‘X’ At Dot
command will show a large ‘X’ on that floor section. When the Stars setting is
set, stars will show up on all pixels in the top half of the screen that are
equal to the sky color. Hence you probably want to ensure the inside sky color
is different from the inside wall color and inside line color, so stars are
only drawn where they’re expected. Some Inside Settings have no effect in this
mode, such as Sealed Entrances, Sun and Moon, and Semitransparent Walls.</p>

<p class=B><span class=O>Compass:</span> If this is set, the direction you’re
facing will be printed at the bottom of the screen in perspective inside view.
This will always be one of the four main compass directions, or one of the
eight directions for the Free Movement modes where you can look in any angle.</p>

<p class=B><span class=O>Compass Is Exact:</span> If this is set, then when the
compass direction is being displayed, its precise angle in degrees from 0 to
360 will be included too, where due North is 0, West is 90, and so on.</p>

<p class=B><span class=O>Cell Location:</span> If this is set, the horizontal
and vertical pixel location of where you’re at in perspective inside view (and
your height or Z location when Bitmap Is 3D is checked) will be printed at the
bottom of the screen. When Narrow Walls Inside is set, the coordinates will be
of the dot’s cell location instead of pixel location, i.e. the pixel
coordinates will be divided by two, so the movement commands which move by two
pixels when Narrow Walls is set, will still cause the location to change by one
unit at a time.</p>

<p class=B><span class=O>Map Overlay:</span> This does the same thing as the Map
Inside menu command on the Dot menu, however the menu command also turns on
View Inside if not on already.</p>

<p class=B><span class=O>Sealed Entrances:</span> When this is set, looking out
the entrance or exit of a Maze in inside view will show a solid color (which
can be considered a special wall, a door, or open void) instead of a distant
horizon. The sealed entrance or exit will be in the Line color as defined in
the Set Colors dialog.</p>

<p class=B><span class=O>Mountains:</span> When this is set, mountains will be
drawn in the background of the inside view. Their color is defined by the
Mountain field in the Set Colors dialog. You’ll always see the same mountains
when looking in a particular direction, although a new set will be generated
each time the program is started, or when the Randomize Seed command is run.</p>

<p class=B><span class=O>Peak Height:</span> This value controls how tall the
mountains are drawn, as a percentage from the horizon to the top of the screen.</p>

<p class=B><span class=O>Cloud Count:</span> This field allows clouds to appear
in the perspective inside view. When set to a non-zero value, that many clouds
will be drawn in the background. Their color is taken from the Cloud field in
the Set Colors dialog. You’ll always see the same clouds when looking in a
particular direction, although a new set will be generated each time the
program is started, or when the Randomize Seed command is run. Note the first
16 clouds will never be placed due south or north, so they will never block the
Sun or Moon.</p>

<p class=B><span class=O>Sun and Moon:</span> When this is set, the inside view
will show the Sun or Moon in the sky or ceiling area when facing south. If the
Stars checkbox is off the Sun will be shown, and if Stars is on a crescent Moon
will be shown.</p>

<p class=B><span class=O>Rainbow:</span> When this is set, the inside view will
display a rainbow in the sky when facing north.</p>

<p class=B><span class=O>Stars:</span> If this is set, stars will be randomly
drawn in the sky or ceiling area of the perspective inside view. The stars will
be of different brightnesses, ranging from dim gray to bright white. Some will
have a red, yellow, or blue tint. It’s recommended to have the Inside Sky color
in the Set Colors dialog be a dark color like black in combination with this.
You’ll always see the same stars when looking in a particular direction,
although a new set will be generated each time the program is started. or when
the Randomize Seed command is run. Note that wireframe and patch renderings as
accessed via the Draw menu can also show background stars, in which whether
stars are displayed and if so how many are taken from this and the Star Count
fields.</p>

<p class=B><span class=O>Star Count:</span> This value controls how many stars
to draw when Stars Inside is set. Daedalus can draw up to 8000 stars.</p>

<p class=B><span class=O>Meteor Rate:</span> This field allows shooting stars
to sometimes be drawn in perspective inside view. This will happen when the
Stars setting is on, and if this field is more than zero, where the percentage
chance of one or more meteors happening in any screen redraw is controlled by
this field. Meteors like the stars can be bright or dim, occasionally colored,
can be long or short, and hidden behind mountains or foreground objects, so
watching for them can be like looking for real meteors. :)</p>

<p class=B><span class=O>Motion Frames:</span> This only plays a role when
Inside Display Mode is set to Smooth Movement. It sets the number of frames to
animate when moving from cell to cell each time a motion command is run.</p>

<p class=B><span class=O>Rotation Frames:</span> This only plays a role when
Inside Display Mode is set to Smooth Movement. It sets the number of frames to
animate when rotating each time a turning command is run.</p>

<p class=B><span class=O>Up Down Frames:</span> This only plays a role when
Inside Display Mode is set to Smooth Movement. It sets the number of frames to
animate when moving vertically between 3D levels each time the Raise or Lower
command is run.</p>

<p class=B><span class=O>Motion Velocity:</span> This only plays a role when
Inside Display Mode is set to Free or Very Free Movement. It sets the number of
inside units to move each time a motion command is run. Note if the Move By Two
dot editing flag is on, movement will happen at twice the rate as is normal,
allowing that setting to act as a “run” or “turbo” mode for the first person
view. This is implemented by moving twice internally per screen update, where
if the first move doesn’t actually move the dot, e.g. it bumped into a wall,
the second move will be skipped.</p>

<p class=B><span class=O>Rotation Velocity:</span> This only plays a role when
Inside Display Mode is set to Free Movement. It sets the number of degrees to
rotate each time a turning command is run. Note if the Drag By Two dot editing
flag is on, rotation in place will happen at twice the rate as normal.</p>

<p class=B><span class=O>Up Down Velocity:</span> This only plays a role when
Inside Display Mode is set to Free Movement. It sets the number of inside units
to move up or down each time the Raise or Lower command is run.</p>

<p class=B><span class=O>Horizontal &amp; Vertical Offset:</span> These only
play a role when Inside Display Mode is set to Free Movement. They indicate the
number of inside units the viewing location is from the center of the pixel.
You probably don’t want to manually change these, where it’s easier to just use
the arrow keys to move around, which will automatically update them.</p>

<p class=B><span class=O>Up Down Offset:</span> This only plays a role when
Inside Display Mode is set to Free Movement. It indicates the number of inside
units the vertical or Z-coordinate of the viewing location is above or below
the center of the level. You probably don’t want to manually change this, where
it’s easier to just use the Raise and Lower commands to move up and down, which
will automatically update this.</p>

<p class=B><span class=O>Direction Offset:</span> This only plays a role when
Inside Display Mode is set to Free Movement. It indicates the number of degrees
the viewing angle is different from the dot’s current compass direction. You
probably don’t want to manually change this, where it’s easier to just use the
Left and Right commands to rotate your view, which will automatically update
this.</p>

<p class=B><span class=O>Up Down Smooth Not Free:</span> This flag only has an
effect when the inside display mode is set to Free Movement or Very Free
Movement, and the Maze is 3D. It causes vertical movement between levels to be
smoothly animated as in the Smooth Movement mode, while 2D movement is
unchanged. In other words it allows fast switches between levels that ensure
you never get stuck part way between them, while still allowing fine control of
your location and direction within a level.</p>

<p class=B><span class=O>Narrow Walls:</span> If this is set, walls will be
narrower than passages in the perspective inside view, specifically they’ll be
1/8 the width. If this is unset, walls will be the same thickness as passages.
In other words pixels in even numbered rows and columns will be drawn thinner
than odd numbered rows and columns. When set, the dot movement commands will
also move by two pixels instead of one, i.e. you’ll always move between odd
numbered rows and columns, and hence move down passages faster.</p>

<p class=B><span class=O>Cell Size:</span> This sets the number of inside units
within each pixel. For example if Cell Size is set to 20, and Motion Velocity
is set to 4, it will take five moves to travel from one cell to its neighbor.
This also sets the number of inside units within each level. For example, if
Cell Size is set to 18, and Up Down Velocity is set to 3, it will take six
moves to travel from one level to the next.</p>

<p class=B><span class=O>Narrow Cell Size:</span> This only plays a role when
Narrow Walls Inside is set. This sets the number of inside units within walls
or pixels in even numbered rows and columns. For example, if Cell Size is 16
and Narrow Cell Size is 8, walls will be 1/2 the thickness of passages.</p>

<p class=B><span class=O>Wall Height:</span> This sets the height of walls. The
number is relative to Cell Size, e.g. doubling Cell Size will have the same
visual effect as halving Wall Height.</p>

<p class=B><span class=O>Viewing Height:</span> Daedalus supports seeing the
Maze from any height in the perspective inside view. Normally eye level is
always half way between the bottom and tops of walls, but eye level can be set
to anywhere, even high enough to look over the tops of walls and see other
passages. This field controls the viewing elevation. Positive values will
increasingly make you seem to float higher in the air, while negative will make
you seem underground or with the Maze floating in midair. A Viewing Height of
half the Wall Height will make eye level even with the tops of walls. A non-zero
wall height may seem to draw slower, since the visible set of passages can
increase to include the entire Maze, so it works best on a faster computer.
Note ceiling markings become invisible if the View Height is positive, while
floor markings become invisible if View Height is negative. Technically, eye
level is always at the center of walls, where an alternate viewing height is
implemented using the variable height walls ability, by treating all walls
taller internally, combined with chopping the tops off, allowing one to look
over them.</p>

<p class=C>The Raise and Lower commands, i.e. pressing the “u” and “d” keys,
will change the Viewing Height (for 2D Mazes that is, where in 3D Mazes these
commands change levels.) The Viewing Height will be adjusted by the number of
units in the Up Down Velocity free movement setting, allowing one to fly up or
down. Being able to see over the tops of walls won’t affect any other behavior,
i.e. walls will still block movement if the Walls Impassable dot setting is on.</p>

<p class=B><span class=O>Step Height:</span> This field in the Inside Settings
dialog controls a simple physics model, allowing one to climb on walls and be
affected by gravity, and will automatically adjust the Viewing Height as one
moves around. If non-negative, the field indicates how many inside units one
can climb up at a time. A Step Height of at least half the Wall Height will
allow one to climb on any block they can see over the top of, while a Step
Height of at least the Wall Height will allow one to climb over default height
walls. Note if one steps off an edge, they’re allowed to fall any distance.
Variable height walls may be defined so that a block is suspended in air, in
which case you will go underneath it if the bottom of the block is above eye
level. This allows one to go over and well as under bridges. When active,
actions that teleport the dot such as clicking the mouse will also set the
Viewing Height so one is standing on the block at that location, whatever its
height. If Step Height is -1, then this feature will be disabled, resulting in
the old behavior of the Viewing Height always being the same, where movement is
only affected by whether a wall is present. Note if the Walls Impassable dot
setting is off, this field will also have no effect, where one will always be
able to move through walls or space like a ghost without the Viewing Height
changing.</p>

<p class=B><span class=O>Allow Texture Mapping:</span> Daedalus supports
texture mapping in the first person view, which means having walls, floor
cells, or the background decorated with pictures instead of just solid colors.
Texture mapping draws slower than solids, so if it makes screen updates happen
too slowly it can be turned off altogether. If this setting is off, no texture
mapping will happen, where even things that have textures defined for them will
show as just a solid color.</p>

<p class=C>For a good demo of texture mapping, run the “Dragonslayer Game”
script, where you can see brick and stone walls among other things. Texture
mapped walls can also be seen on the sides of pits in the floor and ceiling.
For example, in the “Dragonslayer Game” script, make your way to the pit down
the next level, and notice its sides show a stone pattern too.</p>

<p class=B><span class=O>Light Factor:</span> This indicates how much lighter
or darker south and north facing walls should be from the general wall color.
The lower the value, the more similar the colors. If this value is negative,
north facing walls will be lighter and south darker instead of vice-versa, and
also the Sun or Moon will be displayed to the north instead of south, which can
simulate a southern hemisphere location.</p>

<p class=B><span class=O>Fog Distance:</span> Daedalus supports fog effects in
the first person view. If this field is non-zero, the color of walls will
increasingly fade the farther away they are. This gives better depth
perception, where even walls of all the same base color will be shaded
differently based on their distance from you. The larger the number, the
greater the distance before the wall color will completely fade. Specifically
it’s equal to one tenth the number of inside units before the fade limit is
reached, e.g. a Fog Distance of 320 with a Cell Size of 160 means walls will
completely fade after a distance of 20 cells. See the Fog field in the Set
Colors dialog for the color things fade to.</p>

<p class=B><span class=O>Clipping Plane:</span> This contains the clipping
plane distance or how many pixels to look in each direction for a wall. If
objects seem to suddenly pop into view in the distance, you might want to
increase this. If the screen is taking a long time to update while in open
spaces, you might want to decrease this.</p>

<p class=B><span class=O>Viewing Span:</span> This sets how many degrees the
inside view covers on either side of the direction being faced. For example, if
this value is 50, your total viewing span will be 100 degrees. Low numbers give
a “tunnel vision” effect, while high numbers do the opposite. Note changing
this setting won’t affect the apparent height of walls, allowing one to change
this setting without having to then adjust the Wall Height to avoid distortion.
As the angle being viewed decreases or increases, walls will seem to approach
or recede.</p>

<p class=B><span class=O>Stereo Width:</span> The perspective inside view
supports stereoscopic 3D graphics. When this is non-zero, the window will be
split into two displays, showing the scene from slightly different viewpoints.
When the two images are looked at together, with one image for each eye, the
result in a true 3D effect. Classic 3D glasses, modern 3D movies, Google
Cardboard, and random dot stereograms work the same way. The value indicates
the distance in cell size units that the two views are from each other. If the
value is negative, the leftmost image will be on the right half instead of on
the left. This setting will affect the Render Perspective Wireframe and Render
Perspective Patch commands too.</p>

<p class=B><span class=M>Semitransparent Walls:</span> Walls in the perspective
inside view can be semitransparent or translucent. They will look like large
sections of colored class or forcefields where you can see what lies behind
them, but tinted with the color of the wall. If you look through a blue
semitransparent wall behind which is a red semitransparent wall, objects behind
both walls will have a purplish tint. Passage cells can be displayed
semitransparent too, and will look just like semitransparent walls, with the
only difference being you can walk through them. Semitransparent walls or
passages are indicated by having set pixels at that location in the extra
bitmap.</p>

<p class=C><span class=O>None:</span> This radio button disables display of
semitransparent walls. All walls will appear opaque regardless of the contents
of the extra bitmap.</p>

<p class=C><span class=O>Fast Drawing:</span> This radio button enables display
of semitransparent walls. Every pixel’s color will be a blend between the wall’s
color at that point and what’s behind it.</p>

<p class=C><span class=O>Thorough Drawing:</span> This also enables display of
semitransparent walls. It shows slightly more detail than Fast Drawing, and
will include transitions between adjacent semitransparent blocks. Fast Drawing
won’t do this, even if they’re different colors or have a texture.</p>

<p class=C><span class=O>Very Thorough:</span> This is the same as Thorough
Drawing except the thickness of semitransparent walls will also be apparent.
Objects seen through the top and bottom of the wall section will be drawn
slightly darker than those seen though the back of the wall section. With Fast
and Thorough Drawing only the front faces of walls are colored, which can make
the wall look more like a sheet of paper than a solid block.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menubitmap>DAEDALUS MENU COMMANDS - BITMAP MENU</a></p>

</div>

<p class=A><span class=M>Bitmap Menu:</span> This contains general graphics
commands that operate on the bitmap as a whole, such as clearing, resizing,
zooming, and copying. They affect the main monochrome bitmap, and will do a
similar action on the color bitmap if the color bitmap is being shown.</p>

<p class=A><span class=N>Size...:</span> This dialog allows changing the size
or dimensions of the active bitmap.</p>

<p class=B><span class=O>Set Lower Right Bound:</span> When this radio button
is selected, you resize the bitmap by specifying the new horizontal and
vertical pixel size of it. This will either add to or remove from the bottom
right corner depending on whether you’re making the bitmap larger or smaller.
When making the bitmap larger, rows and columns of off or black pixels are
added to the bottom right corner.</p>

<p class=B><span class=O>Shift Down and Right By:</span> When this radio button
is selected, you resize the bitmap by specifying how much larger or smaller you
want it to be, i.e. how many columns and rows to add. This will either add to
or remove from the top left corner of the bitmap depending on whether you enter
positive or negative numbers. When making the bitmap larger, rows and columns
of off or black pixels are added to the top left corner.</p>

<p class=B><span class=O>Horizontal &amp; Vertical Size:</span> These two
values indicate the current size of the bitmap. Change these values to the new
size of the bitmap, or the amount that you want to enlarge the bitmap by, to
resize it. When Set Lower Right Bound is set, these numbers can be negative,
and will resize the bitmap down by that amount, e.g. -10 will subtract ten
pixels from the bitmap’s size. Daedalus bitmaps may potentially be up to 2^31-1
or 2147483647 pixels in each dimension. Note the largest bitmaps may cause out
of memory errors in allocating the bitmap itself, or errors in displaying such
bitmaps in a window. For example, a monochrome bitmap may be 81000x81000 pixels,
and a color bitmap may be 20000x20000 pixels, before the memory allocation
exceeds one gigabyte, which is the single allocation limit on some systems. Some
features and commands require bitmaps smaller than a certain size (such as 64K
by 64K pixels, or the limitations of the Windows bitmap file format) but in
that case the command itself will check for an appropriate size before
proceeding.</p>

<p class=B><span class=O>Clear Bitmap After Sizing:</span> When this is set,
after the bitmap is resized, all pixels in it will be set to off or black.
Internally Daedalus resizes a bitmap by creating a new bitmap of the
destination size, then copying the contents of the old bitmap to the new one.
When dealing with very large bitmaps, this copying can take a few seconds.
Having this set can make the resize faster.</p>

<p class=B><span class=M>3D Bitmap:</span> This section contains the size or
dimensions of the 3D bitmap within the main bitmap. These fields are used when
creating 3D Mazes, 4D Mazes, and Planair Mazes, and should be set to the
desired values before creating such Mazes.</p>

<p class=C><span class=O>X:</span> This contains the number of horizontal
pixels within each level or section in a 3D or 4D or Planair Maze. The number
of horizontal passages will be one less than half this number. Loading a 3D
bitmap with the 3D Bitmap Open command will set this value.</p>

<p class=C><span class=O>Y:</span> This contains the number of vertical pixels
within each level or section in a 3D or 4D or Planair Maze. The number of
vertical passages will be one less than half this number. Loading a 3D bitmap
with the 3D Bitmap Open command will set this value.</p>

<p class=C><span class=O>Z:</span> This contains the number of 3D levels in a
3D or 4D Maze. This is the number of actual bitmap sections, which includes
sections between passage levels indicating the passage connections between the
levels. The number of actual passage levels will be half this number. Loading a
3D bitmap with the 3D Bitmap Open command will set this value. For Planair
Mazes this field is ignored.</p>

<p class=C><span class=O>W:</span> For 3D and Planair Mazes this contains the
number of sections per row. This allows the sections to be arranged in a grid
instead of having to be in a single line. This affects the arrangement of
sections when loading a 3D bitmap as well as when creating a 3D or Planair
Maze. For 4D Mazes this contains the number of levels along the 4th axis or
through the 4th dimension. This is the number of actual bitmap sections, where
the number of 4D passage levels will be half this number. 4D Mazes are arranged
as a 2D grid of 2D sections or levels.</p>

<p class=A><span class=M>Common Sizes:</span> This submenu allows automatically
resizing the bitmap to any one of 19 predefined sizes.</p>

<p class=A><span class=M>All:</span> This submenu allows doing things to all
the pixels in the main or color bitmaps.</p>

<p class=B><span class=N>Clear All:</span> This clears or turns off all pixels
in the bitmap.</p>

<p class=B><span class=N>Set All:</span> This sets or turns on all pixels in
the bitmap.</p>

<p class=B><span class=N>Invert All:</span> This inverts or reverses all pixels
in the bitmap, where all off pixels become on and vice versa.</p>

<p class=B><span class=N>Random All:</span> This randomly sets all pixels in
the main bitmap, with a 50% chance of any pixel being on or off. This
percentage is modified by the Random Bias setting, which is added to the
percentage of pixels being on. For example, a Random Bias field of -10 means a
40% chance each pixel will be on. When the color bitmap is being shown, this will
instead set each pixel in the color bitmap to a random 24 bit color.</p>

<p class=A><span class=N>Zoom...:</span> This dialog is similar to the Size
dialog in that it resizes the active bitmap, however here you’re zooming or
stretching the contents of the bitmap instead of just adding rows and columns
to it.</p>

<p class=B><span class=O>Zoom by Factor:</span> When this radio button is
selected, you zoom the bitmap by specifying the factor or ratio by which you
want its horizontal and vertical size enlarged. For example, entering 2 and 2
will double the dimensions of the bitmap, where each pixel in the old bitmap
zooms to a 2x2 section of pixels in the new bitmap. You may enter floating
point numbers here to zoom by a non-integer percentage.</p>

<p class=B><span class=O>Zoom to Size:</span> When this radio button is
selected, you zoom the bitmap by specifying its new horizontal and vertical
pixel size. The bitmap will be resized, and its contents will be stretched or
shrunk to fit in the new size, with rows and columns being duplicated or
dropped as needed.</p>

<p class=B><span class=O>Horizontal &amp; Vertical:</span> Set these values to
either the horizontal and vertical factor to zoom the bitmap by, or the new
pixel size to zoom the bitmap to. Note these fields can also be negative. When
Zoom by Factor is set, negative numbers will shrink the bitmap to that
fraction, e.g. -3 will shrink the bitmap down to one third of its original
size. When Zoom To Size is set, negative numbers will shrink the size of the
bitmap by that amount, e.g. -10 will shrink the bitmap down by ten pixels.</p>

<p class=B><span class=O>Drop Lines When Shrinking:</span> When set, then when
shrinking or zooming the bitmap down, certain rows and columns will just be
dropped.</p>

<p class=B><span class=O>Preserve On When Shrinking:</span> When set, in
monochrome bitmaps priority will be given to any on pixels when zooming the
bitmap down. This means in each section of pixels that will become a single pixel
in the new smaller bitmap, if any pixel in that section is on, the new pixel
will be on. Only if all pixels in a section are off, will the new pixel be off.
Normally when shrinking, Zoom will just pick the first pixel from each section.
For example, assume you have a solution to a very large Maze, consisting of a
thin line of on pixels; with this checkbox set, you can shrink it to a smaller
bitmap, and still see a continuous path without any part of it having been dropped
or lost in the shrinking.</p>

<p class=C>When this is set in color bitmaps, pixels will be set to the blended
mixture of all pixels mapping to it. When zooming a color bitmap to an equal or
larger dimension, this setting will make pixels be a gradual gradient between
adjacent colors. In other words each destination pixel will be proportionally
blended from the four source pixels located closest to it.</p>

<p class=B><span class=O>Tessellate Instead of Zoom:</span> When set, zooming
won’t stretch the bitmap at all to whatever size, but will rather tile or
tessellate the bitmap’s old contents through the new size.</p>

<p class=A><span class=M>Flip and Rotate:</span> This submenu has commands to
flip and rotate the contents of the main or color bitmaps.</p>

<p class=B><span class=N>Flip Horizontal:</span> This flips the bitmap from
left to right.</p>

<p class=B><span class=N>Flip Vertical:</span> This flips the bitmap from top
to bottom.</p>

<p class=B><span class=N>Transpose:</span> This flips the bitmap across the
main diagonal that runs from the upper left corner to the lower right.</p>

<p class=B><span class=N>Rotate Right:</span> This rotates the bitmap to the
right 90 degrees.</p>

<p class=B><span class=N>Rotate Left:</span> This rotates the bitmap to the
left 90 degrees.</p>

<p class=B><span class=N>Rotate Across:</span> This rotates the bitmap 180
degrees, turning it upside down.</p>

<p class=B><span class=N>3D Bitmap...:</span> This dialog allows flipping and
rotating the 3D bitmap stored in the active bitmap. This can be used to view
other sides of the 3D bitmap in the Render Bitmap Overview command.</p>

<p class=C><span class=O>X &amp; Y &amp; Z:</span> These radio buttons in the
Axis group indicate which axis of the 3D bitmap to operate on.</p>

<p class=C><span class=O>Flip:</span> This radio button in the Operation group
means to flip the 3D bitmap through the axis specified above.</p>

<p class=C><span class=O>Rotate Left or Forward &amp; Rotate Right or Backward &amp;
Rotate Across &amp; Transpose:</span> These radio buttons in the Operation
group mean to do the same as the Rotate Left, Rotate Right, Rotate Across, and
Transpose commands, however they do that to all layers of the 3D bitmap along
the axis specified above.</p>

<p class=A><span class=M>Temp Bitmap:</span> This submenu has commands
involving the temporary bitmap. When the color bitmap is being displayed, these
commands deal with the the temporary color bitmap, otherwise they affect the
temporary main bitmap.</p>

<p class=B><span class=N>Get:</span> This copies the main bitmap to the
temporary bitmap. This can be used as an undo feature. If you make a mistake
when editing the main bitmap, you can go back to this copy you made by using
the Put command below.</p>

<p class=B><span class=N>Put:</span> This copies the temporary bitmap to the
main bitmap.</p>

<p class=B><span class=N>Swap:</span> This swaps the main bitmap and the
temporary bitmap with each other.</p>

<p class=B><span class=N>Or:</span> This is like Put except the contents of the
temporary bitmap will be copied on top of the main bitmap with a “logical or”
operation, where the pixels (or bits within pixels in the case of the color
bitmap) will be set if they’re set in either the main or the temporary bitmap.</p>

<p class=B><span class=N>And:</span> This is like Put except the contents of
the temporary bitmap will be copied on top of the main bitmap with a “logical
and” operation, where the pixels (or bits within pixels in the case of the
color bitmap) will only be set if they’re set in both the main and the
temporary bitmap.</p>

<p class=B><span class=N>Xor:</span> This is like Put except the contents of
the temporary bitmap will be copied on top of the main bitmap with a “logical
exclusive or” operation, where the pixels (or bits within pixels in the case of
the color bitmap) will be set if they’re set in the main or the temporary
bitmap, but not both.</p>

<p class=B><span class=N>Blend:</span> This edits the main bitmap by combining
the temporary bitmap with it. When Show Color Bitmap is off, the combined
bitmap takes every other pixel from the original main bitmap and every other
from the temporary. When the color bitmap is active, the combined bitmap’s
colors are half way between the original color bitmap and the temporary color
bitmap.</p>

<p class=B><span class=N>Tessellate:</span> This is like the Put command in
that it copies the contents of the temporary bitmap to the main bitmap, except
this doesn’t change the size of the main bitmap, but rather tiles or
tessellates copies of the temporary bitmap across and down it. This is a quick
way to make a mosaic of a small bitmap pattern within a larger bounds.</p>

<p class=B><span class=N>Delete:</span> This deletes the temporary bitmap,
returning it to the way it is when the program starts. This is a quick way to
make the contents of this bitmap no longer affect other commands or displays, e.g.
this will remove all floor markings in the perspective inside view.</p>

<p class=A><span class=M>Extra Bitmap:</span> This submenu has commands
involving the extra bitmap. The extra bitmap is like another temporary bitmap,
and like it may be used for general bitmap editing purposes. When the color
bitmap is being displayed, these commands deal with the extra color bitmap,
otherwise they affect the extra main bitmap.</p>

<p class=B><span class=N>Get:</span> This copies the main bitmap to the extra
bitmap.</p>

<p class=B><span class=N>Put:</span> This copies the extra bitmap to the main
bitmap.</p>

<p class=B><span class=N>Swap:</span> This swaps the main bitmap and the extra
bitmap with each other.</p>

<p class=B><span class=N>Delete:</span> This deletes the extra bitmap,
returning it to the way it is when the program starts. This is a quick way to
make the contents of this bitmap no longer affect other commands or displays, e.g.
this will remove all semitransparent sections in the perspective inside view.</p>

<p class=A><span class=N>Collapse to Set:</span> This makes the active bitmap
smaller, such that all blank rows and columns (i.e. entirely composed of off or
black pixels) on the edges of the bitmap are removed. In other words this trims
off any blank rows and columns from the top, left, bottom, and right edges. If
the Bitmap Is 3D command is checked, this will treat the bitmap as 3D and
remove off pixels from all six faces around a 3D block containing on pixels.</p>

<p class=A><span class=N>Smooth Zoomed:</span> This attempts to make diagonal
lines in a zoomed bitmap look smoother. This command first automatically zooms
the bitmap by a factor of two. After zooming by 200%, diagonal lines will be
composed of 2x2 blocks and hence look like stairs. This command will set the
pixels inside the “stairs” between two blocks, turning it into a thick diagonal
line. This is best used with a Maze type that involves non-orthogonal walls
such as a Crack Maze. Create a Crack Maze, then select Smooth Zoomed and notice
how less rough the walls look.</p>

<p class=B>When No Corner Hopping is off, Smooth Zoomed will set additional
pixels. Sometimes where there are three of four pixels set in a 2x2 block, this
will set the pixel in the corner. The logic is to still do smoothing if there
are branches along a diagonal line, but to leave sharp right angle corners
alone.</p>

<p class=A><span class=N>Smooth Corners:</span> This smoothes the corners in
the bitmap by turning off pixels that are at corners. This is best used after
zooming a Maze or other bitmap by a certain factor, to make the corners of
walls look rounder. This command may be run multiple times to further round off
the corners. Note this only smoothes walls or sections of the bitmap composed
of on pixels. You can smooth passages or off sections of the bitmap by
reversing the bitmap with Invert All, running Smooth Corners, then inverting
the bitmap back.</p>

<p class=A><span class=N>Thicken:</span> This makes everything in the main
bitmap appear thicker. Basically every set pixel will expand into a 2x2 block,
absorbing the off pixels next to it. This doesn’t resize the bitmap any. This
command may be run multiple times to further fatten everything. This works well
with Maze types such as Omega Mazes and Labyrinths when drawn in a high
resolution bitmap, to make those Maze’s one pixel wide lines not appear so
thin.</p>

<p class=B>If the color bitmap is being shown, this will instead operate on the
color bitmap and do a blur effect, and blend the color of each pixel with the
pixels surrounding it. If the Edge Behavior setting in the Dot Settings dialog is
set to Torus Wrapping, this command when applied to a color bitmap will wrap
around while considering adjacent pixels.</p>

<p class=A><span class=N>Make Thinner:</span> This is roughly an inverse of the
Thicken command. This makes all content in the bitmap thinner, where usually
nothing left is more than one pixel wide, with few or no 2x2 blocks anywhere.
This won’t fundamentally change the structure of content, i.e. it won’t divide
objects, add holes, or make anything shorter. For example, running this on a
solid 10x20 rectangle will result in a length 10 horizontal line intersecting a
length 20 vertical line. This can be a good command to run before Graph Walls,
as that works on one pixel wide walls, and this converts everything to one
pixel wide walls. If the No Corner Hopping setting is off, this will remove
even more pixels, by allowing removals that only leave pixels connected
diagonally, where this will remove most 2x2 blocks of on pixels that weren’t
carved into before.</p>

<p class=B>When the color bitmap is being shown, the Make Thinner command will
map each pixel to the nearest color of the rainbow. If the Special To Pattern
setting in the Replace Color dialog is set to Straight Color Blend, this will
instead convert the image to a maximum contrast version of itself. All colors
will be converted to the nearest of eight colors, i.e. all combinations of RGB values whose components are either 0 or 255.</p>

<p class=A><span class=N>Accent Boundaries:</span> This basically zooms the
active bitmap by 200%, making it about twice the size of the old bitmap, but
does it in a special way. Boundaries or edges between sections of on pixels and
sections of off pixels in the old bitmap, become lines of on pixels in the new
bitmap, while boundaries between pixels that are the same in the old bitmap,
become off in the new bitmap. There is one off pixel in the new bitmap
corresponding to the middle of each pixel in the old bitmap. For example, an on
pixel completely surrounded by off pixels (as well as an off pixel surrounded
by on pixels) will become a small one pixel wide rectangle of set pixels. When
applied to color bitmaps, black pixels are considered off, and non-black are
on.</p>

<p class=A><span class=N>Fill at Dot:</span> This fills in the area or object
that the dot is within, regardless of its shape. If the dot is over an off
pixel, this will fill the area with on pixels until walls of on pixels are hit,
like dumping a bucket of paint into it. If the dot is over an on pixel, this
will do the opposite and fill in the area with off pixels until boundaries of
off pixels are hit. If the Bitmap Is 3D setting is on, this will do a 3D fill,
and will look in the four main directions as well as up and down for additional
pixels to fill.</p>

<p class=B>If Show Color Bitmap is on, this instead fills in the area that the
dot is within on the color bitmap, with the color of the dot. The area to be
filled is indicated by the color that the dot is over. All other colors will
mark the boundary to stop filling at.</p>

<p class=A><span class=N>Flood at Dot:</span> This is like Fill At Dot except
here the filling can proceed diagonally. The Fill At Dot command only looks in
the four main directions for additional pixels to fill. This command looks in
all eight directions. A one pixel wide diagonal line will stop the Fill At Dot
command, but Flood At Dot will bleed through and keep going. Like Fill At Dot,
this also works on the color bitmap.</p>

<p class=A><span class=N>Slide to Dot:</span> This edits the active bitmap by “sliding”
it so that the pixel under the dot becomes centered in the bitmap. This doesn’t
change the bitmap’s size or lose any data, where pixels that move off one edge
of the bitmap reappear on the other.</p>

<p class=A><span class=M>Row Column Edits:</span> This submenu has commands to
insert or delete rows or columns in the bitmap.</p>

<p class=B><span class=N>Insert Column at Dot:</span> This takes the column at
the horizontal location of the dot, and duplicates or makes a copy of it,
making the bitmap that much larger.</p>

<p class=B><span class=N>Delete Column at Dot:</span> This takes the column at
the horizontal location of the dot, and removes it, making the bitmap that much
smaller.</p>

<p class=B><span class=N>Insert Row at Dot:</span> This takes the row at the
vertical location of the dot, and duplicates it.</p>

<p class=B><span class=N>Delete Row at Dot:</span> This takes the row at the
vertical location of the dot, and removes it.</p>

<p class=B><span class=N>Insert Columns at Dots:</span> This takes the columns
between the horizontal locations of the dot and second dot, and duplicates
them.</p>

<p class=B><span class=N>Delete Columns at Dots:</span> This takes the columns
between the horizontal locations of the dot and second dot, and removes them.</p>

<p class=B><span class=N>Insert Rows at Dots:</span> This takes the rows
between the vertical locations of the dot and second dot, and duplicates them.</p>

<p class=B><span class=N>Delete Rows at Dots:</span> This takes the rows
between the vertical locations of the dot and second dot, and removes them.</p>

<p class=A><span class=N>Bitmap Is 3D:</span> This is a general setting
indicating whether the bitmap should be treated as a 3D bitmap. When checked,
the first person perspective inside view will be of the 3D bitmap within the
main bitmap instead of just of the 2D main bitmap itself. This will cause there
to seem to be pits or holes in the floor and ceiling, i.e. passages going up
and down, in addition to passages in the four compass directions. Creating a 3D
Maze and other commands that operate on or have as their result a 3D Maze will
automatically turn this setting on. Similarly creating a 2D Maze and other
commands that treat the bitmap as a 2D plane will automatically turn this off.
Note this should only be turned on for 3D Mazes. Trying to view a 2D Maze or any
other bitmap as a 3D Maze will result in what looks like random garbage. This
setting affects other features of the program too, such as mouse clicks.</p>

<p class=A><span class=N>Count Pixels:</span> This counts the number of set and
reset pixels in the main bitmap. The total number of pixels will be printed,
along the number that are on and the number that are off, and their
percentages. If the color bitmap is being shown, this command will instead
operate on the color bitmap, and display the number of pure black, pure white,
other grayscale, and actual colored pixels, along with the percentage red,
green, and blue intensities of the average pixel.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menucolor>DAEDALUS MENU COMMANDS - COLOR MENU</a></p>

</div>

<p class=A><span class=M>Color Menu:</span> This contains all commands
affecting the color bitmap, such as the ability to load or copy to it, and save
or copy from it. Most commands set the color bitmap in an interesting way based
on other bitmaps, although some operate on the color bitmap itself.</p>

<p class=A><span class=N>Show Color Bitmap:</span> When this menu item is
checked, the window will show the color bitmap. When this is unchecked, the
window will show the main monochrome bitmap. Note most commands on this menu
will automatically switch to showing the color bitmap. Also most commands here,
if the color bitmap doesn’t already exist, will automatically copy the main
bitmap to the color bitmap before continuing. Similarly most commands that only
operate on the main bitmap, such as Maze creation, will automatically turn this
setting off and switch to showing the main monochrome bitmap.</p>

<p class=A><span class=M>Color Bitmap File:</span> This submenu has commands to
load and save the color bitmap.</p>

<p class=B><span class=N>Save Targa...:</span> This saves the color bitmap to a
24 bit color targa graphics file. This is not a Windows specific format so may
be used to transfer files to or from non-Windows systems.</p>

<p class=B><span class=N>Open Targa...:</span> This loads a targa graphics file
into the color bitmap. The file must be in 24 bit color.</p>

<p class=A><span class=M>Bitmap:</span> This submenu has commands to transfer
content between the main bitmap and the color bitmap.</p>

<p class=B><span class=N>Get from Bitmap:</span> This copies the main bitmap to
the color bitmap. Off pixels in the main bitmap will become the Passage color
as set in the Set Colors dialog, and on pixels will become the Wall color.</p>

<p class=B><span class=N>Put to Bitmap:</span> This copies the color bitmap to
the main bitmap. Only color bitmap pixels that are pure black will become off
pixels; all other colors will become on pixels.</p>

<p class=B><span class=N>Put to Bitmap (Nearest):</span> This copies the color
bitmap to the main bitmap, where color bitmap pixels that are closer to black
than white in brightness will become off pixels; all others will become on
pixels.</p>

<p class=B><span class=N>Put to Bitmap (Dither):</span> This copies the color
bitmap to the main bitmap, where color bitmap pixels of a particular color will
become either on or off pixels in an appropriate percentage and distribution
based on the color’s brightness.</p>

<p class=B><span class=N>Or from Bitmap:</span> This is like Get From Bitmap
except the contents of the main bitmap will be copied on top of the color
bitmap with a “logical or” operation, where the bits in the RGB values of the main and color bitmap pixel colors will be merged with a logical or.</p>

<p class=B><span class=N>And from Bitmap:</span> This is like Get From Bitmap
except the contents of the main bitmap will be copied on top of the color
bitmap with a “logical and” operation, where the bits in the RGB values of the main and color bitmap pixel colors will be merged with a logical and.</p>

<p class=B><span class=N>Xor from Bitmap:</span> This is like Get From Bitmap
except the contents of the main bitmap will be copied on top of the color
bitmap with a “logical exclusive or” operation, where the bits in the RGB values of the main and color bitmap pixel colors will be merged together with a logical
exclusive or.</p>

<p class=A><span class=N>Blend from 2 Bitmaps:</span> This sets the color
bitmap to an overlay of the main and temporary bitmaps. Pixels that are on in
both the main and temporary bitmaps become white in the color bitmap, and
pixels that are off in both bitmaps become black. Pixels that are on in the
main bitmap (but not the temporary) become red in the color bitmap, and pixels
that are on in the temporary bitmap (but not the main) become cyan. This can be
used to show a Maze and its solution together. Copy a Maze to the temporary
bitmap, solve it so its solution is in the main bitmap, then do Blend From 2
Bitmaps, and see the Maze in the color bitmap with passages in one color and
its solution in another.</p>

<p class=A><span class=N>Blend from 3 Bitmaps:</span> This is an extended version
of Blend From 2 Bitmaps. It will blend three bitmaps together into the color
bitmap: the main bitmap, the temporary bitmap, and the extra bitmap. The pixels
in the color bitmap will be set to RGB values, where the main bitmap is the red
component, the temporary is the green component, and the extra the blue
component. For example, pixels set in only the main bitmap will be red, and
pixels set in the main and temporary bitmaps but not the extra will be yellow
(i.e. red + green). Note this command does the same thing as Blend From 2
Bitmaps when the temporary and extra bitmaps are identical.</p>

<p class=A><span class=N>Graph Distance:</span> This is designed to analyze the
passages in a Maze to show how far it is to reach certain points relative to
other points. The color bitmap will be set to a copy of the main bitmap, and
then all passages or areas reachable from the start will be filled in with
varying colors indicating their distance from the start. The starting point is
the location of the dot. If the dot is not over an off pixel, the first off
pixel in the main bitmap will be used instead. The colors used will be based on
the colors in the special blend pattern section in the Replace Color dialog. In
other words it will be a blend through colors of the rainbow, or a straight
blend from one color to another. The blend start color will be for pixels next
to the dot, while the blend end color will be for the pixels farthest away from
the dot, where all other pixels are colored proportionally based on their
distance. You can use the Replace Color dialog to replace a color with itself
if you want to just set the blend color setting to use. For 2D bitmaps, if No
Corner Hopping in Dot Settings is off, passage connections can happen
diagonally as well as orthogonally.</p>

<p class=B>Note you can also do Graph Distance with multiple start locations.
If the temporary bitmap exists, and is the same size as the main bitmap, and
all off pixels in the temporary bitmap are also off in the main bitmap, and
there’s at least one pixel on in the main bitmap that’s off in the temporary
(in other words the set of off pixels in the temporary bitmap is a proper
subset of the off pixels in the main bitmap) then all off pixels in the
temporary bitmap will be starting points like the dot. For example, one can
graph how far away pixels are from the solution path to a Maze, by having the
Maze in the main bitmap, the solution in the temporary, and then doing Graph
Distance, so that the graphing simultaneously starts from every pixel along the
solution path. This command will print the longest distance to any point from
the starting point or points. Note the longest distance from the set of points
along the solution path is one way to measure the difficulty of a Maze, where
longer distances often mean a harder Maze, since one can get farther off the
right path before having to backtrack.</p>

<p class=A><span class=N>Graph Walls:</span> Similar to Graph Distance, this is
a good way to see the internal structure of a Maze, and see roughly the
solution and main false paths. This will instead flood along the tops of walls,
and make the color bitmap be a copy of the main bitmap with appropriately
colored walls. Flooding starts at all wall endpoints, and changes color as it
moves down the tree of walls. Any walls that form loops, marking out
inaccessible sections (along with walls between such loops) are never colored.
If No Corner Hopping in Dot Settings is off, walls are allowed to connect
diagonally. This basically shows the importance of each wall segment, or the
distance it takes to walk from one side of a wall segment to the opposite side.
Unimportant walls that are easy to get around get early colors, while
significant walls that define the main sections in the Maze get late colors,
while necessary walls that mark out inaccessible locations aren’t colored at
all. The colors used for walls come from the blend in the Replace Color dialog.
A straight color blend, say from the passage color to a bright color, works
best for this command, where unimportant walls will be dim and important walls
will be bright.</p>

<p class=A><span class=M>Antialias From Bitmap:</span> This submenu has
commands to set the color bitmap to an antialiased version of the main bitmap.
The color bitmap will be smaller than the main bitmap, where each pixel will be
the passage color, the wall color, or an appropriate shade in between. Each color
pixel will cover a certain section of pixels in the main bitmap, where the more
on pixels in that section, the closer the shade to the wall color. There are
seven commands on this submenu, which deal with 2x2 to 8x8 areas in the main
bitmap. Antialiasing can make things such as thick diagonal lines look very
smooth, because boundary pixels can be shades of gray instead of everything
having to be either black or white. This works best with Maze types involving
non-orthogonal lines such as Omega Mazes and Labyrinths. For example, create a
Labyrinth in a large bitmap such as 500x500, run the Thicken command a few
times to thicken the walls, then do a 2x2 Antialias which will make the color
bitmap be 250x250. Compare the smoothness of the result with another 250x250
Labyrinth drawn in the monochrome main bitmap.</p>

<p class=B>Note everything available on this menu and then some can also be
done in the Zoom dialog. Simply copy the monochrome bitmap to the color bitmap,
then zoom the color bitmap down by the appropriate scale with the Preserve On
When Shrinking checkbox set.</p>

<p class=A><span class=M>Dot Color:</span> This submenu does various things to
the color bitmap with the color of the dot as defined in the Set Colors dialog.</p>

<p class=B><span class=N>Set to Color:</span> This sets all pixels in the color
bitmap to the color of the dot.</p>

<p class=B><span class=N>Or with Color:</span> This merges the color of the dot
with all pixels in the color bitmap using a “logical or” operation.</p>

<p class=B><span class=N>And with Color:</span> This merges the color of the
dot with all pixels in the color bitmap using a “logical and” operation.</p>

<p class=B><span class=N>Xor with Color:</span> This merges the color of the
dot with all pixels in the color bitmap using a “logical exclusive or”
operation.</p>

<p class=B><span class=N>Add with Color:</span> This adds the dot’s color to
each pixel, where if an RGB component reaches 255 it will stay there.</p>

<p class=B><span class=N>Subtract with Color:</span> This sets each pixel to
the difference between its and the dot’s color.</p>

<p class=B><span class=N>Multiply with Color:</span> This sets each pixel to
the product of its and the dot’s color, where if an RGB component reaches 255
it will stay there.</p>

<p class=B><span class=N>Min with Color:</span> This sets each pixel to the
minimum of its and the dot’s color, each RGB component being considered
separately.</p>

<p class=B><span class=N>Max with Color:</span> This sets each pixel to the
maximum of its and the dot’s color, each RGB component being considered
separately.</p>

<p class=B><span class=N>Blend with Color:</span> This sets each pixel to the
midpoint between its and the dot’s color.</p>

<p class=A><span class=M>Color Bitmap:</span> This submenu has commands
involving the temporary color bitmap and additional commands affecting the
color bitmap itself.</p>

<p class=B><span class=N>Add with Temp:</span> This edits the color bitmap by
combining the temporary color bitmap with it. The combined bitmap’s pixels will
have RGB values set to the sum of those in the original color and temporary
color bitmaps. The new image will be lighter than before, where some areas may
become solid white.</p>

<p class=B><span class=N>Subtract with Temp:</span> This is like Add except the
combined bitmap’s pixels will have RGB values set to the difference between
those in the original color and temporary color bitmaps.</p>

<p class=B><span class=N>Alpha with Temp:</span> This is similar to the Blend
command on the Temp Bitmap submenu. Instead of the main color bitmap being half
way between the main and temporary color bitmaps, this uses the extra color
bitmap as a transparency indicator or alpha channel. Each pixel in the extra
bitmap indicates how much to bias each RGB component between the main and
temporary bitmaps, ranging from 0 (entirely main bitmap) to 255 (entirely
temporary bitmap).</p>

<p class=B><span class=N>Delete:</span> This just deletes the color bitmap,
returning it to the way it is when the program starts. This is a quick way to
make the contents of this bitmap no longer affect other commands or displays,
i.e. this removes all localized color from walls and floor markings in the
perspective inside view.</p>

<p class=A><span class=N>Make Grayscale:</span> This turns the color bitmap
into a black and white or grayscale version of itself. Each pixel will turn
into a shade of gray corresponding to its brightness.</p>

<p class=A><span class=M>Apply Texture:</span> This submenu has commands to use
bitmaps to texture map parts of the first person view, or set block elevations
within it. These just give the same texture to every spot, where taking full
advantage of the program’s texture mapping capabilities requires knowledge of
the Daedalus scripting language, described in the script.txt file.</p>

<p class=B><span class=N>Background:</span> This applies a texture to the
background area, or the part of the first person view that composes the sky or
ceiling half. A copy of the current contents of the color bitmap will be used
as the background for 2D Mazes and for the top level in 3D Mazes, instead of
the solid inside sky color. If the temporary color bitmap exists, it will be
used as the background for all levels in 3D Mazes except the top level, instead
of the inside 3D ceiling color. Decorations such as mountains and stars will
still be drawn when appropriate, just on top of the background texture instead
of whatever solid color. If the fSkyAll macro setting is on, the background
texture will be applied over the whole background, covering the ground half in
addition to the sky half. The default behavior is better, as it avoids an
unchanging picture on the ground as you move forward or backward.</p>

<p class=B><span class=N>Color Walls:</span> This applies a color texture map
to the walls. A copy of the current contents of the color bitmap will be used
as the texture for all walls, covering them like wallpaper. If the Narrow Walls
setting is on, then a copy of the temporary color bitmap will be instead used
for the narrower wall segments. If one of the color bitmaps doesn’t exist, then
a copy of the other bitmap clipped or tessellated appropriately will be used in
its place. This behavior prevents textures from appearing unnaturally stretched
or compressed on faces of different sizes. If Light Factor in Inside Settings
is non-zero at the time the command is run, then the textures created will be
shaded the same amount.</p>

<p class=B><span class=N>Overlay Walls:</span> This is a monochrome version of
Color Walls, except here the bitmap texture doesn’t totally cover the old wall
color. The bitmap texture appears as either a black or white overlay on top of
whatever solid wall color, like a tattoo. If Drag Is Erase in Dot Settings is
off, then off pixels in the bitmap texture will appear as black on walls, and
on pixels in the texture will appear as whatever the wall’s untextured color
is. If Drag Is Erase is on, then on pixels in the texture will appear as white
on walls, and off pixels will be the wall’s color. A copy of the current
contents of the temporary monochrome bitmap is used as the texture overlay. If
Narrow Walls is on, then a copy of the extra bitmap will be instead used for
the narrow wall segments. If one of the monochrome bitmaps doesn’t exist, then
a copy of the other clipped or tessellated appropriately will be used in its
place. For a demo of monochrome texture overlays, run the “Survivor Squares
Game” script, which has black numbers drawn on the eight players.</p>

<p class=B><span class=N>Color Overlay Walls:</span> This is a combination of
Color Walls and Overlay Walls. It does an overlay on top of the existing wall
color like Overlay Walls, but overlays with different colors instead of always
in black or white. This uses a copy of the color bitmap (and temporary color
bitmap if Narrow Walls is on) for the actual overlay, and uses the temporary
monochrome bitmap (and extra monochrome bitmap if Narrow Walls is on) for the
mask. If Drag Is Erase in Dot Settings is off, then on pixels in the mask
bitmap will appear as pixels from the color texture, and off pixels will be the
wall’s color. If Drag Is Erase is on, then off pixels in the mask will appear
from the color texture, and on pixels will be the wall’s color.</p>

<p class=B><span class=N>Color Ground &amp; Overlay Ground &amp; Color Overlay
Ground:</span> Daedalus supports texture mapped floors in the perspective
inside view, where floor squares can be decorated with bitmap patterns. This
ability can be demoed with these commands, which do the same thing as the Color
Walls, Overlay Walls, and Color Overlay Walls commands, but affect the floor instead
of walls. These commands take the bitmap and overlay from the color bitmap
(using the main bitmap if the color bitmap doesn’t exist) and temporary
monochrome bitmap (using the main bitmap if it doesn’t exist). If the Narrow
Walls inside setting is set, cells that are thinner horizontally, vertically,
or both will be textured with versions of the input bitmaps truncated or
tessellated appropriately. For a demo of monochrome floor texture overlays, run
the “Dragonslayer Game” script, which has textures for objects on the ground
and open doors.</p>

<p class=B><span class=N>Color Blocks &amp; Overlay Blocks &amp; Color Overlay
Blocks:</span> Daedalus supports texture mapping on the top and bottom surfaces
of wall blocks in the perspective inside view, where these squares can be
decorated with bitmap patterns like ground squares can. This can be demoed with
these commands, which do the same thing as the Color Ground, Overlay Ground,
and Color Overlay Ground commands, but affect blocks instead of the ground. As
with the Ground commands, these commands make use of the color bitmap (using
the main bitmap if the color bitmap doesn’t exist) and temporary monochrome
bitmap (using the main bitmap if it doesn’t exist). For a demo of block texture
overlays, run the “Survivor Maze #7” or “Survivor Maze #8” scripts, which have
textures for blocks in places such as on the tops of guideposts and key
stations.</p>

<p class=B><span class=N>Ceiling:</span> Daedalus supports colored markings on
the ceiling in the perspective inside view, in the same way that it supports
markings on the ground. This command will completely cover the ceiling area of
the bitmap. Any colors or textures on the ground will also appear on the
ceiling, where the default ceiling color for places that have no ground marking
will be the 3D Wall color. If the color bitmap exists when the command is run,
the ceiling will contain and show a separate copy of those colors, and won’t
change if ground colors later change. If the color bitmap doesn’t exist,
ceiling colors will always be the same as corresponding ground colors, changing
when they change.</p>

<p class=B><span class=N>Variable Height Walls:</span> This command will apply
an elevation to every pixel in the bitmap. This will make the Maze to appear to
be on a hill, instead of on a flat plain. The elevations will be based on the
most recent special pattern used in the Replace Color dialog. Red in the
rainbow or Blend color #1 defines the highest elevation, and Cyan or Blend
color #2 the lowest. By default this will make the Maze appear to be in a
circular valley, high on the edges and low in the middle, allowing one to see
walls on the opposite side of the Maze as they move around. If however, for
example, you do a replace with pattern “#”, combined with setting the Rainbow
Start field to 360, then the result will be the Maze on the surface of a
pyramid, with the apex in the middle. Note the same maximum height is given
regardless of bitmap size, so if the bitmap is too small or a too irregular
Replace Color pattern was defined, some passages may be too steep to navigate,
or some walls may be low enough to climb.</p>

<p class=B><span class=N>Ground Elevation:</span> This command will show random
hills in the perspective inside view. This display demos the ability for the
ground to have variable elevation, which is a feature independent of the
existing variable height walls. If the color bitmap is active, the ground
colors will be set based on the elevation of each cell, using the pattern from
the Replace Color dialog. The scene will take into account where blocks or on
pixels are in the main monochrome bitmap. The end result will be rolling hills,
with blocks placed above them and made tall enough so movement won’t
accidentally step one on top of a wall. You can even change which pixels are
set, such as by making a new Maze, and newly appearing blocks will have
appropriate elevations.</p>

<p class=B><span class=N>Delete:</span> This deletes any texture bitmaps in
memory, such that the background and all walls in the first person view will
have no textures defined for them, and will display in solid colors. Texture
bitmaps are stored separately from the main, temporary, and extra bitmaps, so changing
the three standard bitmaps after running the commands above won’t affect the
textures any.</p>

<p class=A><span class=N>Brightness...:</span> This dialog allows one to
brighten or darken all pixels in the color bitmap, along with additional
transformations.</p>

<p class=B><span class=O>Brighten All by Factor:</span> When selected, all
pixels will be brightened or darkened by the same factor. The Transform Amount
field will indicate the factor to apply to each pixel, and ranges from -1.0 to
1.0, where negative numbers darken and positive brighten. </p>

<p class=B><span class=O>Brighten All by Offset:</span> When selected, all
pixels will be brightened or darkened by the same offset. The Transform Amount
field will indicate the amount to be added to the red, green, and blue parts of
each pixel’s color, and ranges from -255 to 255.</p>

<p class=B><span class=O>Brighten All by Multiplier:</span> When selected, all
pixels will have their components multiplied by the same factor. The Transform
Amount field will indicate the factor to be multiplied to the red, green, and
blue parts of each pixel’s color, with component numbers capping at 255. For
example a Transform Amount of 1.5 will convert RGB 50 100 200 to RGB 75 150 255. A negative Transform Amount will do the same but with the differences of each
component from 255. For example -0.5 will convert RGB 245 128 0 to RGB 250 192 128.</p>

<p class=B><span class=O>Limit Brightness to Value:</span> When selected, this
will prevent the brightness of each pixel from being higher or lower than a
limit, and will darken or brighten those pixels beyond the limit appropriately.
The Transform Amount field if positive indicates the maximum allowed sum for
the RGB values of a pixel, and ranges up to 765 (255 times three). If negative
it indicates the minimum allowed sum for a pixel’s RGB values, e.g. an entry of
-100 will prevent any pixel from being darker than or having an RGB sum less than 100.</p>

<p class=B><span class=O>Rotate All by Degree:</span> When selected, all pixels
in the bitmap will be rotated clockwise by the number of degrees specified in
the Transform Amount field. Pixels rotated from off the bitmap will be black.</p>

<p class=B><span class=O>Twist Middle by Degree:</span> When selected, this
will rotate pixels at the center of the bitmap by the number of degrees
specified, and gradually rotate concentric rings around the middle by a lesser
amount until the edge of the bitmap is reached, which isn’t rotated at all.</p>

<p class=B><span class=O>Transform Amount:</span> This means different things
depending on which of the options above is selected.</p>

<p class=A><span class=N>Replace Color...:</span> This dialog allows replacing
all instances of one color in the color bitmap with another color.</p>

<p class=B><span class=O>From:</span> This indicates the color to be replaced.</p>

<p class=B><span class=O>To:</span> This indicates the color to replace all
instances of the From color with.</p>

<p class=B>In addition to replacing a color with another solid color, you can
also replace that color with a pattern of colors. To do this, enter one of the
special values below in the To field. These “colors” are usually a single
special character whose shape resembles the type of pattern done. The specific
colors to use in the pattern are defined by the rest of the fields in the
dialog. The available patterns themselves are as follows:</p>

<p class=C><span class=P>O:</span> The value “O” means to have rings of color
starting from the center of the bitmap and ending in the corners of the bitmap.</p>

<p class=C><span class=P>X: </span>The value “X” means to have spokes of color
radiating from the center of the bitmap, starting at the right edge, and
swinging in a circle around the bitmap clockwise to end at the right edge
again.</p>

<p class=C><span class=P>*: </span>The value “*” is like “X” except the colors
will also be lightened the closer they are to the middle. Colors in the center
of the bitmap will be lightened so they’re almost white, while colors in the
corners of the bitmap will be darkened so they’re almost black.</p>

<p class=C><span class=P>|: </span>The value “|” means to have rows of color
arranged vertically starting at the top edge and ending at the bottom edge.</p>

<p class=C><span class=P>-: </span>The value “-” means to have columns of color
arranged horizontally starting at the left edge and ending at the right edge.</p>

<p class=C><span class=P>\: </span>The value “\” means to have 45 degree
diagonal lines of color starting at the upper left corner and ending at the
lower right.</p>

<p class=C><span class=P>/: </span>The value “/” means to have 45 degree
diagonal lines of color starting at the lower left corner and ending at the
upper right.</p>

<p class=C><span class=P>#:</span> The value “#” is like “O” except it has
square rings instead of circular rings starting from the center of the bitmap.</p>

<p class=C><span class=P>+:</span> The value “+” is like “O” except it has
diamond shaped rings instead of circular rings starting from the center of the
bitmap.</p>

<p class=C><span class=P>@:</span> The value “@” will make a spiral pattern,
similar to “X” except the spokes of color spiral instead of shoot directly
outward from the center of the bitmap. The spiral will have a radius indicated
by the distance of the dot from the center. If the dot is above the center,
colors will spiral out counterclockwise, otherwise they will spiral clockwise.</p>

<p class=C><span class=P>o:</span> The value “o” is like “O” except the rings
of color start from the location of the dot and end in the farthest corner of the
bitmap from the dot.</p>

<p class=C><span class=P>8: </span>The value “8” is like “o” except rings of
color start from both the dot and second dot, each pixel taking its color based
on which dot is closer to it.</p>

<p class=C><span class=P>x: </span>The value “x” is like “X” except the spokes
of color radiate from the location of the dot.</p>

<p class=C><span class=P>?: </span>The value “?” means to make each pixel
changed become a random color within the type of blend done, e.g. when doing a
rainbow blend each pixel will be a random color of the rainbow.</p>

<p class=C><span class=P>??:</span> The value “??” means to make each pixel
changed become a random color of any type. Unlike all the other patterns, the
other fields in the dialog have no effect on the colors chosen here.</p>

<p class=C><span class=P>?????:</span> The five characters “?????” will make
each pixel changed become a random color somewhere between the colors in the
Blend1 &amp; Blend2 fields.</p>

<p class=B><span class=O>Swap Instead of Replace:</span> When this is set, the
dialog will exchange instances of the colors in the From and To fields with
each other, instead of just replacing instances of the To color with the From
color. When set, the To field must be a solid color as opposed to one of the
color patterns.</p>

<p class=B><span class=O>Rainbow Blend:</span> This is a radio button in the
Special To Pattern group. When selected, and when replacing a color with a
pattern, the colors in that pattern will be a blend through the colors of the
rainbow.</p>

<p class=B><span class=O>Straight Color Blend:</span> This is a radio button in
the Special To Pattern group. When selected, and when replacing a color with a
pattern, the colors in that pattern will be a gradient starting with one color
and ending with a second color.</p>

<p class=B><span class=O>Rainbow Start:</span> This value only plays a role
when a color is being replaced with a pattern. When Rainbow Blend is selected,
this indicates the color of the rainbow to start the blend with. The value here
can range from 0 to 360, where 0 is red, 120 is green, and so on through the
rainbow. When Straight Color Blend is selected, this indicates where the start
the blend from, where the value 0 corresponds to the color in Blend1 and 360
with Blend2.</p>

<p class=B><span class=O>Rainbow Distance:</span> This value only plays a role
when a color is being replaced with a pattern. When Rainbow Blend is selected,
this indicates how much of the rainbow to blend through between the start and
end of the pattern. The value 360 means to go forward through the entire
rainbow once. Making the value -720 for example would mean to go backwards
through the rainbow twice. When Straight Color Blend is selected, instead of
the color gradient always going from the color in the Blend1 field to Blend2,
it can go back and forth between them multiple times. For example, if Rainbow
Start is 0 and Rainbow Distance is 720, the gradient will go from Blend1 to
Blend2 then back to Blend1.</p>

<p class=B><span class=O>Blend1:</span> This value only plays a role when
Straight Color Blend is selected. This indicates the color to start blending
from at the start of the pattern.</p>

<p class=B><span class=O>Blend2:</span> This value only plays a role when
Straight Color Blend is selected. This indicates the color to end blending with
at the end of the pattern.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menumaze>DAEDALUS MENU COMMANDS - MAZE MENU</a></p>

</div>

<p class=A><span class=M>Maze Menu:</span> This is similar to the Bitmap menu
but contains commands that operate on the main bitmap that are associated with
Mazes. This includes Maze generation commands that use what’s already on the
screen as a basis of what they do.</p>

<p class=A><span class=N>Maze Size...:</span> This dialog is like the Size
dialog in that it allows changing the size of the active bitmap. Here however
you specify the size in terms of the number of Maze passages that fit within
the bitmap, instead of the pixel size of the bitmap itself.</p>

<p class=B><span class=O>Horizontal &amp; Vertical Size:</span> These two
values indicate the current size of the bitmap in passages. The size of a
bitmap in passages is one less than half the size in pixels. The size of a
bitmap in pixels is one or two more than twice the size in passages. Basically
each passage requires two pixels: one for the passage itself, and one for the
wall next to it. Finally there’s one more pixel for the wall on the other size
of the last passage, and then one more after that if the bitmap size is even.
The numbers here can be negative, in which this will resize the Maze down by
that many passages, e.g. -5 will subtract five passages or ten pixels from the
Maze’s size.</p>

<p class=B><span class=O>Clear Maze After Sizing:</span> When this is set,
after the bitmap is resized, all pixels in it will be set to off. This
corresponds to the Clear Bitmap After Sizing checkbox in the Size dialog.</p>

<p class=B><span class=O>Maze Total Pixel Size Even:</span> When this is set,
the resized Maze bitmap will have an even number of horizontal and vertical
pixels. Even means there will a blank row and column of pixels at the right and
bottom edges. This flag is initially set based on the whether the original
bitmap has odd or even pixel dimensions.</p>

<p class=B><span class=M>3D Maze:</span> This section contains the passage size
or dimensions of the 3D Maze bitmap within the active bitmap. These fields are
used when creating 3D Mazes, 4D Mazes, and Planair Mazes, and should be set to
the desired values before creating such Mazes.</p>

<p class=C><span class=O>X:</span> This contains the number of horizontal
passages within each level or section in a 3D or 4D or Planair Maze. The number
of horizontal pixels will be one or two more than twice this number. Loading a
3D bitmap with the 3D Bitmap Open command will set this value.</p>

<p class=C><span class=O>Y:</span> This contains the number of vertical
passages within each level or section in a 3D or 4D or Planair Maze. The number
of vertical pixels will be one or two more than twice this number. Loading a 3D
bitmap with the 3D Bitmap Open command will set this value.</p>

<p class=C><span class=O>Z:</span> This contains the number of 3D levels in a
3D or 4D Maze. This is the number of actual passage levels, which doesn’t
include sections between passage levels indicating the passage connections
between the levels. The number of actual bitmap sections will be one less than
twice this number. Loading a 3D bitmap with the 3D Bitmap Open command will set
this value. For Planair Mazes this field is ignored.</p>

<p class=C><span class=O>W:</span> For 3D and Planair Mazes this is half the
number of sections per row. This allows the sections to be arranged in a grid
instead of having to be in a single line. This affects the arrangement of
sections when loading a 3D bitmap as well as when creating a 3D or Planair Maze.
For 4D Mazes this contains the number of levels along the 4th axis or through
the 4th dimension. This is the number of 4D passage levels, where the actual
bitmap sections will be one less then twice this number. 4D Mazes are arranged
as a 2D grid of 2D sections or levels.</p>

<p class=A><span class=N>Zoom Bias...:</span> This dialog is like the Zoom
dialog in that it zooms the active bitmap by a certain factor, however this
zooms even and odd rows and columns by different amounts. This allows making a
Maze bitmap where the passages are a different thickness than the walls.
Usually you’ll want to make walls thinner than passages, to say use less ink
when printing or to make the Maze look more like one drawn with a pen.</p>

<p class=B><span class=O>Even Horizontal Bias &amp; Even Vertical Bias:</span>
Set these values to the horizontal and vertical factors to zoom even numbered
pixels i.e. walls by.</p>

<p class=B><span class=O>Odd Horizontal Bias &amp; Odd Vertical Bias:</span>
Set these values to the horizontal and vertical factors to zoom odd numbered
pixels i.e. passages by.</p>

<p class=A><span class=M>Add:</span> This submenu has commands to add things to
the Maze.</p>

<p class=B><span class=N>Add Entrance:</span> This adds one entrance to the
Maze. This means searching for and turning off a random on pixel in the top row
of the bitmap. Daedalus usually considers the top of a Maze to be the start.
This will only create entrances at positions that connect with existing
interior passages. If the top row doesn’t contain a wall, this will move to the
next row down and keep trying until it’s able to turn off a pixel. If Entrance
Positioning in Maze Settings is set to Corners, this will try to select a
location nearest the upper left corner for the entrance. If Entrance
Positioning is set to Middle, this will try to select a location nearest the
middle of the top edge for the entrance.</p>

<p class=B><span class=N>Add Exit:</span> This is like Add Entrance but adds
one exit to the Maze. This means turning off a pixel in either the bottom or
second from bottom row of the bitmap. Daedalus usually considers the bottom of
a Maze to be the end. If the bottom row doesn’t contain a wall, this will move
to the next row above and keep trying until it’s able to turn off a pixel. If
Entrance Positioning in Maze Settings is set to Corners, this will try to
select a location nearest the bottom right corner for the exit. If Entrance
Positioning is set to Middle, this will try to select a location nearest the
middle of the bottom edge for the exit.</p>

<p class=B><span class=N>Add Passage:</span> This adds a passage to the Maze,
by randomly turning off one wall pixel. This won’t add any entrances, but will
always affect the interior of the Maze. Each time this is run, it will add a
passage loop or detached wall to the Maze, or open up an inaccessible section.
This does nothing if no valid wall segments can be found.</p>

<p class=B><span class=N>Add Wall:</span> This adds a wall segment to the Maze,
by randomly turning on one passage pixel. This won’t seal off any entrances,
but will always affect the interior of the Maze. Each time this is run, it will
create an inaccessible section within the Maze, or connect a detached wall i.e.
remove a passage loop.</p>

<p class=A><span class=M>Remove:</span> This submenu has commands to remove all
instances of something from the Maze.</p>

<p class=B><span class=N>Crack Isolations:</span> This removes all inaccessible
or isolated sections within the Maze, by adding passages to connect them with
the rest of the Maze. For each isolated section, a passage will be randomly
added to connect it with whatever surrounds it. This won’t touch solid block
areas without passages that aren’t part of the Maze.</p>

<p class=B><span class=N>Connect Detachments:</span> This removes all passage
loops or detached walls within the Maze, by adding walls to connect them with
the rest of the Maze. For each detached wall, a wall segment will be randomly
added to connect it with whatever surrounds it. This won’t touch rooms or parts
of the bitmap not covered by Maze passages.</p>

<p class=B><span class=N>Crack Dead Ends:</span> This removes all dead ends
from the Maze, turning it into a Braid Maze, by randomly removing a wall
segment at the end of each dead end, so the dead end passage continues. Note
this will cause many loops or detached walls to be added to the Maze. When
picking which wall at the end of a dead end to remove, this will avoid creating
a “pole” or single pixel wall segment in the Maze if possible.</p>

<p class=B><span class=N>Seal Entrances:</span> This removes all entrances from
the Maze, by adding wall segments to seal them off. An entrance is considered
to be any passage pixel that has part of the Maze on one side of it, and an
open space (or the edge of the bitmap) on the other side.</p>

<p class=B><span class=N>Connect Poles:</span> This removes all “poles” from
the Maze, or single pixel wall segments surrounded by a small loop, by adding
wall segments to connect them with the rest of the Maze. When adding walls,
this will avoid creating dead ends with the new wall segment if possible.</p>

<p class=B><span class=N>Remove Poles:</span> This is like Connect Poles,
except here the poles are simply deleted leaving open spaces, as opposed to
connected with adjacent walls.</p>

<p class=B><span class=N>Crack Cells:</span> This removes all internal walls
from the Maze, leaving just a bunch of poles. This leaves boundary walls around
the edge of the Maze alone. This can be used to create a Braid Maze with an
irregular boundary. Start with a filled in area, run Crack Cells to carve out the
interior, then Connect Poles to start adding wall segments, and finally Braid
Add Walls to finish the Maze.</p>

<p class=B><span class=N>Crack Blind Alley Cells:</span> This edits the Maze
such that all wall segments within the same blind alley have been removed. In
other words, each blind alley hanging off the solution path will become a small
or large open space surrounded by a wall, which makes the solution and false
paths of the Maze more apparent. The temporary bitmap may optionally indicate
the solution path: If the temporary bitmap exists, and is the same size as the
main bitmap, and all off pixels in the temporary bitmap are also off in the
main bitmap, and there’s at least one pixel on in the main bitmap that’s off in
the temporary (in other words the set of off pixels in the temporary bitmap is
a proper subset of the off pixels in the main bitmap) then all off pixels in
the temporary bitmap will be considered the solution.</p>

<p class=B><span class=N>Fill Passages:</span> This fills in all passages in
the Maze, leaving a solid area or matte. This leaves rooms or parts of the
bitmap not covered by the Maze alone.</p>

<p class=B><span class=N>Fill Open Cells:</span> This removes all rooms or open
spaces within the Maze. This won’t create any inaccessible areas, but will
rather turn everything into one pixel wide passages by thickening the walls
next to open spaces.</p>

<p class=B><span class=N>Remove Boundary:</span> This removes all outer and
inner boundary walls in the Maze, or walls with open space (as opposed to a
passage) on one or both sides of them. Each time this command is run, the Maze
will “melt” inward by another passage width, as if it were dissolving in acid.</p>

<p class=C>This command will work on a pixel basis instead of a Maze cell
basis, if run when the Solve Fillers Check Every Pixel flag in Maze Settings is
on, in which any pixel not surrounded by on pixels on all sides will be turned
off. In this scenario, the No Corner Hopping flag in the Dot Settings dialog
determines whether pixels need to be set in just the four compass directions or
in all eight directions. This scenario will also check the Edge Behavior
setting in the Dot Settings dialog. When Edge Behavior is set to Stop At Edge,
pixels outside the bitmap will be considered on instead of off. When Edge
Behavior is set to Torus Wrapping, consideration of adjacent pixels will wrap
around the edges of the bitmap.</p>

<p class=B><span class=N>Remove Tubes:</span> This removes all passage tubes
from the Maze, or horizontal or vertical passage segments with open space on
both sides of the walls forming the passage. Note Remove Boundary removes
everything this command does and then some.</p>

<p class=A><span class=M>Normalize:</span> This submenu has commands to modify
whatever’s in the bitmap to look more like a standard orthogonal Maze. In a
standard orthogonal Maze, the following are true: (1) All pixels at even
numbered coordinate pairs are on, which are where walls intersect. (2) All
pixels at odd numbered coordinate pairs are off, which are where passages
intersect. (3) All pixels in the rightmost column and bottom row are off.</p>

<p class=B><span class=N>Add Passages:</span> This turns off all pixels at odd
numbered coordinate pairs. This makes solid areas become single cell isolated
sections.</p>

<p class=B><span class=N>Add Walls:</span> This turns on all pixels at even
numbered coordinate pairs. This makes open areas become fields of poles.</p>

<p class=B><span class=N>Erase Bottom Right:</span> This erases or fills with
off pixels the rightmost column and bottom row. If already clear, this does the
opposite and sets or fills the area with on pixels.</p>

<p class=A><span class=N>Make Symmetric:</span> This modifies the current Maze
to be rotationally symmetric through its middle, where the bottom half will be
the top half turned upside down, and the right half will be the left upside
down. This is implemented by copying the top half to the bottom, then editing
the Maze so it has no isolations or loops. If the most recent autorepeatable
command run was creating a Braid Maze, the symmetric Maze will be edited so it
has no dead ends instead of no loops. Note a perfect symmetric Maze will always
have its solution going through the middle, so if the Maze has no middle
passage (i.e. has an even number of horizontal and vertical passages) then the
Maze can’t be fully symmetric if it’s made to be perfect. Hence a message
displaying the number of asymmetries in the Maze is shown after running the
command.</p>

<p class=A><span class=N>Expand Set:</span> This zooms the bitmap by a factor
or two, doubling its size. However unlike a normal zoom, here each set pixel
will become a 3x3 instead of a 2x2 section in the new bitmap. This is useful to
make a properly formed solid section or matte to create a Maze within. After
running the command, every on pixel in the old bitmap will become a cell
surrounded by walls in the new bitmap.</p>

<p class=A><span class=N>Room Thinned:</span> This should only be run on a
biased zoomed Maze where walls are one pixel thick and passages are three
pixels. It will modify the Maze such that each cell looks like a small room,
where passages to adjacent cells are narrow doorways and the room itself has a
pole or set pixel in the middle. Running the command on an already roomified
Maze will unroomify it back to its original condition. Roomified Mazes look
interesting and also have the characteristic of seeming hard for the eye to
follow, and hence can be harder to solve.</p>

<p class=A><span class=N>Tweak Endpoints:</span> This slightly modifies certain
passages in a Maze. The wall segment at each wall endpoint will be made to
randomly point in a new direction. The solution and the path between any two
points in the Maze will remain very similar to before.</p>

<p class=A><span class=N>Tweak Passages:</span> This slightly modifies passages
in a Maze that are next to solid areas. This will randomly turn some straight
passage segments into U-turn sections and vice-versa, as well as toggle between
types of corners. This is useful when defining the solution or other passages
in a Maze by hand, before having the computer create the rest of the Maze.
Without this you have to manually make the passages twisty to blend in with the
rest of the Maze. With this you can just quickly draw the rough path you want
the passages to take, which can include perfectly straight lines, and then do
Tweak Passages one or more times to add random twists to the path.</p>

<p class=A><span class=N>Weave to 3D:</span> This command should only be run
with a Weave Maze in the bitmap. This will convert a Weave Maze to an
equivalent 3D Maze. The 3D Maze will have two levels, where underpasses in the
Weave Maze are represented by a drop down to and back up from the lower level.
This can be used to convert a Weave Maze to a form where one can navigate the
dot through it. If the Semitransparent Walls inside setting is set to anything
but None, then the appropriate pixels in the extra bitmap will also be set, so
the perspective inside view will show the walls adjacent to overpasses as
semitransparent. That allows one to see the underpass passage from an overpass
and vice-versa, like a real bridge.</p>

<p class=A><span class=N>Weave to Inside:</span> This command should only be
run with a Weave Maze in the bitmap. It will convert the Weave Maze into a
scene readily explorable in the perspective inside view, automatically
switching to that view and adjusting other settings appropriately. This is an
improved version of the Weave To 3D command, since instead of implementing
underpasses with pits that go underground, this creates overpasses with stairs
that allow you to climb up and look out over the Maze. Stairs and bridges will
be highlighted in the 3D Ceiling color, and handrails in the 3D Wall color.</p>

<p class=A><span class=N>Clarify Weave:</span> The command should only be run
with a Weave Maze in the bitmap. It will convert the Weave Maze into an image
that looks better (which usually means making the passages thicker relative to
walls), zooming the passages and walls appropriately. The zoom proportions are
controlled by the Clarify Weave Bias settings in the Maze Settings dialog.</p>

<p class=A><span class=N>Clarify 3D:</span> This command should only be run
with a 3D Maze in the bitmap, where the dimensions of the 3D Maze are set in
the Size dialogs. This replaces the 3D Maze with a new bitmap that represents
the Maze in a way more easily viewed and followed by humans. Basically it
removes all the block sections used to store passage connections between
levels, and instead represents those passages with icons in the levels
themselves. Within each cell can be pixels that look like staircases up or
down, that indicate passages to adjacent levels. This is basically a graphical
version of the output of the Save Text command for 3D Mazes, where within a
level a “\” shape indicates a passage down to the next lower level, “/” a
passage up to the next higher level, and “X” passages both up and down at that
point.</p>

<p class=B>When Show Color Bitmap is on, this will draw a colorized version of
the clarification in the color bitmap. Stair icons indicating passages between
levels are in one of four colors, where the colors will match up to make the
clarified 3D Maze easier to navigate. For example if stairs from one level to
another are red, the stairs from the other level back to the first will also be
red.</p>

<p class=A><span class=N>Clarify 4D:</span> This command should only be run
with a 4D Maze in the bitmap, where the dimensions of the 4D Maze are set in
the Size dialogs. This replaces the 4D Maze with a new bitmap that represents
the Maze in a way more easily viewed and followed by humans. Basically it
removes all the block sections used to store passage connections between
levels, and instead represents those passages with icons in the levels
themselves. Within each cell can be pixels that look like doors with a
doorknob, that indicate passages to different sections. Doors at the top or
bottom of a cell (i.e. in the ceiling or floor) indicate passages to the same
cell a level above or below the current one (i.e. through the 3rd dimension).
Doors at the left or right of a cell indicate passages to the same cell a
section to the left or right of the current one (i.e. through the 4th
dimension).</p>

<p class=B>When Show Color Bitmap is on, this will draw a colorized version of
the clarification in the color bitmap. Doorways leading through the 3rd and 4th
dimensions are colored red, green, blue, or yellow. That makes one color for
each possible doorway leading away from a cell. Note the colors for doorways
will match up, making the colorized clarified 4D Maze easier to navigate. For
example if a doorway from one cell to another is green, the doorway from the
destination cell back to the original will also be green.</p>

<p class=A><span class=N>Count Possible:</span> This prints how many possible
different perfect Mazes there are of a given rectangular size. The size is
taken from the current passage dimensions of the bitmap. This ignores entrances
and just considers internal passages, and also counts rotations and reflections
as different Mazes. For example, for a 2x2 passage Maze there are four
possibilities (the wall segment ending in the middle may be attached to any of
the four outer walls). The number of possible Mazes rises very rapidly as its
size increases. It’s on the order of four raised to the power of the number of
cells in the Maze, where there are for example over 100,000 4x4 Mazes. The
number of possible perfect Mazes is basically the number of possible minimal
spanning trees over a graph of vertices in a grid, where Daedalus uses Kirchhoff's
theorem and eigenvalues to mathematically compute the number.</p>

<p class=A><span class=N>Analyze Passages:</span> This analyzes the passages of
the Maze in the bitmap, and prints counts and percentage information. It prints
information about the types of cells, the lengths of passages, and the lengths
of dead ends.</p>

<p class=B>For cells this prints: (1) The number of isolated cells, i.e. holes
with walls on all sides with no passages leading from it. (2) The number of
dead ends, i.e. points where there is only one passage leading from it. This is
broken down into the number of blocks where the passage away from it leads up,
left, down, and right. (3) The number of straightaway cells. This is broken
down into the number of horizontal and vertical straightaways. (4) The number
of turnings or corner cells. This is broken down into the number of corners of
upper left, lower left, lower right, and upper right varieties. (5) The number
of junctions, i.e. points where there are three passages leading from it. This
is broken down into the number of junctions where the side passage leads up,
left, down, and right. (6) The number of crossroads, i.e. points where there
are four passages leading from it. (7) Finally the total number of cells in the
bitmap is printed, along with the total number of passage cells, i.e. points
where there are two passages leading from it (which is the sum of the
straightaways and turnings above).</p>

<p class=B>For passage lengths this prints the length of the longest horizontal
passage and the longest vertical passage, measured in cells followed by in
pixels in parentheses. For dead end lengths this prints the number of dead ends
there are of each cell length, i.e. how many cells the dead end passage goes
through before terminating.</p>

<p class=B>This command will analyze the current 3D Maze when the Bitmap Is 3D
setting is on. It will display the number of types of each cell (in which each
cell has 0-6 passages leading from it) along with the number of dead ends of
each cell length.</p>

<p class=A><span class=N>Analyze Walls:</span> This is basically the inverse of
Analyze Passages, where this analyzes the walls of the Maze in the bitmap, and
prints counts and percentage information. It prints information about the types
of wall intersection points, and the lengths of walls.</p>

<p class=B>For wall intersection points this prints: (1) The number of poles,
i.e. single pixel wall segments surrounded by a small passage loop. (2) The
number of wall endpoints, i.e. points where there is only one wall leading from
it. This is broken down into the number of endpoints where the segment away
from it leads up, left, down, and right. (3) The number of straight wall
pieces. This is broken down into the number of horizontal and vertical straight
walls. (4) The number of corner wall pieces. This is broken down into the
number of corners of upper left, lower left, lower right, and upper right
varieties. (5) The number of T-sections, i.e. points where there are three
walls leading from it. This is broken down into the number of T-sections where
the side wall leads up, left, down, and right. (6) The number of crosspieces,
i.e. points where there are four walls leading from it. (7) Finally the total
number of wall intersection points in the bitmap is printed, along with the
total number of wall points, i.e. points where there are two wall segments
leading from it (which is the sum of the straight walls and corners above).</p>

<p class=B>For wall lengths this prints the number of horizontal and vertical
wall segments composing the Maze. For example, if one wanted to reproduce a
Maze using tarps, this would indicate the number of tarp panels needed. This
also prints the length of the longest horizontal and vertical walls within the
Maze, measured in cells followed by in pixels in parentheses. This ignores
outer boundary walls when determining the longest.</p>

<p class=A><span class=N>Maze Settings...:</span> This dialog controls settings
related to various Maze solving and utility commands. Note all settings dealing
with particular Maze creation styles are in the Create Settings dialog.</p>

<p class=B><span class=O>Create Mazes Polished:</span> This controls the same
setting as the Polished Mazes command on the Create menu, however unlike the
command, changing it here won’t affect any existing Maze in the bitmap or any
other settings.</p>

<p class=B><span class=O>Apply Commands to Rectangle Section:</span> When this
is set, most Maze related commands, including creation and solving commands,
will be applied to the rectangle whose opposite corners are defined by the dot
and second dot. Normally commands are applied to the entire bitmap. For
example, this can be used to fill in all dead ends in just a section of a Maze.
Note some commands will automatically align the rectangle they use here to
certain rows and columns, e.g. most Maze creation commands will always draw
walls on even numbered pixels.</p>

<p class=B><span class=O>Teleport to Entrance on Maze Creation:</span> This
flag when set will automatically move the dot to the entrance of any Maze or
Labyrinth the program creates. This is useful when making a Maze to solve
yourself within the program by navigating the dot through it.</p>

<p class=B><span class=O>Connect Poles Never Adds Dead Ends:</span> This
affects the Connect Poles command, which tries not to create a new dead end
when connecting a pole to a neighboring wall. When this is set, if in all cases
connecting a pole would result in a dead end, Connect Poles will leave it as a
pole. When unset, Connect Poles will go ahead and make a dead end if it has to.</p>

<p class=B><span class=O>Solve Fillers Check Every Pixel:</span> This affects
the Fill Dead Ends, Fill Cul-De-Sacs, Fill Blind Alleys, Fill Single Dead Ends,
and Mark Dead Ends commands. Normally these commands assume a standard
orthogonal Maze, where dead ends can only start at odd numbered rows and
columns. When this is set, the commands will check every pixel and make no
assumptions about the layout of the Maze. This makes the commands run slightly
slower, but they will be able to handle non-standard Mazes, e.g. this needs to
be set if you want to fill dead ends of Mazes created with the Cavern command.</p>

<p class=B><span class=O>Solve Fillers Consider Dots as Exits:</span> This
affects the Fill Dead Ends, Fill Cul-De-Sacs, Fill Blind Alleys, Fill Single Dead
Ends, Mark Dead Ends, and Mark Cul-De-Sacs commands. Normally these commands
fill in every dead end or blind alley, however in some cases you may not want
everything the command considers a dead end or blind alley filled, e.g. it may
indicate an entrance or exit. When this is set, the location of the dot and
second dot will act as solutions. If a dot is at the end of a dead end, that
dead end won’t get filled. If a dot is along the loop at the end of a
cul-de-sac, that cul-de-sac won’t get filled. If a dot is anywhere within a
blind alley, that blind alley won’t get filled.</p>

<p class=B><span class=O>Find a Path Finds Random Path:</span> This affects the
Find A Path solving command. Normally that command always displays the same
solution for any particular Maze. When this is set, that command will instead
find a random solution.</p>

<p class=B><span class=O>Show Count of Shortest Solutions:</span> This affects
the Find Shortest Paths command. Normally that command displays how long each
of the solutions are. When this is set, that command will instead display the
total number of shortest solutions.</p>

<p class=B><span class=O>Tweak Passages Chances:</span> The number here affects
the Tweak Passages command, and indicates how often sections should be
modified. The first digit indicates how often U-turn sections should be turned
into straight sections, the second digit indicates how often corners should be
toggled, and the third digit indicates how often straight sections should be
turned into U-turns. For example, a 3 in the 10’s place means to give each
corner a 1 in 3 chance of being toggled. A zero digit means to never modify
that section type.</p>

<p class=B><span class=O>Total Mazes Created:</span> This field contains the
number of Mazes that have been created since the program was started. This
works well with the Autorepeat command, where you can start making a bunch of
Mazes, then later see how many were made. You can also change this value if you
want, e.g. reset it to zero.</p>

<p class=B><span class=O>Clarify Weave Passage Bias:</span> This value
determines how many pixels wide passages will be in Mazes that have had the
Clarify Weave command run on them.</p>

<p class=B><span class=O>Clarify Weave Wall Bias:</span> This value determines
how many pixels wide walls will be in Mazes that have had the Clarify Weave
command run on them.</p>

<p class=B><span class=O>Clarify Weave Railing Bias:</span> This value
determines how many pixels wide railings or separator walls next to overpass
passages will be in Mazes that have had the Clarify Weave command run on them.
Normally this value should be less than one half of the Wall Bias setting, in
order to allow some of an underpass passage to still be visible between two
parallel overpasses. If this value is too large (or zero) then overpasses and
underpasses will instead be indicated with a block of on pixels in the middle
of the intersection.</p>

<p class=B><span class=M>Entrance Positioning:</span> This section of radio
buttons controls where entrances and exits in created Mazes are placed. For
most Daedalus Mazes the entrance is always on the top edge and the exit on the
bottom, where this setting indicates where along those edges the openings
should be.</p>

<p class=C><span class=O>Corners:</span> This puts the entrance in the upper
left corner and the exit in the lower right.</p>

<p class=C><span class=O>Middle:</span> This centers the entrance and exit in
the middle of the top and bottom edges.</p>

<p class=C><span class=O>Balanced Random:</span> This places the entrance
randomly, with the exit being put the same distance from the right edge that
the entrance is from the left.</p>

<p class=C><span class=O>True Random:</span> This places both the entrance and
exit randomly.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menucreate>DAEDALUS MENU COMMANDS - CREATE MENU</a></p>

</div>

<p class=A><span class=M>Create Menu:</span> This contains all the ways of
creating different types of Mazes and Labyrinths. Most of these commands will
draw a 100% computer generated Maze within the bounds of the main bitmap.</p>

<p class=A><span class=N>Perfect:</span> This creates a standard perfect Maze,
where “perfect” means the Maze has no passage loops or detached walls, and no
inaccessible sections. The Maze will have exactly one solution, and from each
point in the Maze there will be exactly one path to any other point.</p>

<p class=A><span class=N>Braid:</span> This creates a braid Maze, where “braid”
means the Maze has no dead ends in it. This means the passages coil around and
run back into each other making you go in circles instead of bumping into dead
ends. Hence expect there to be many loops and detached walls, and multiple
solutions. The Mazes created with this command are generally easier to solve
than the Perfect command. The Braid Creation Method options in Create Settings
allow one to select different ways of generating braid Mazes.</p>

<p class=A><span class=N>Unicursal:</span> This creates a random unicursal
Maze, where “unicursal” means the Maze has no junctions, and hence has just a
single long snake-like passage that coils throughout the extent of the Maze.
Unicursal Mazes with an odd number of horizontal and vertical passages always
go from the upper left corner to the lower right corner. Unicursal Mazes with
an even number of horizontal and vertical passages start and end at the same
spot on the top row. Mazes with an even number of horizontal passages and an
odd number of vertical go from upper left to upper right. Mazes with an odd
number of horizontal passages and an even number of vertical go from upper left
to lower left. If the Create With River checkbox in the Create Settings dialog is
set, the path here will be more twisty. See the Labyrinth submenu for more ways
of creating unicursal Mazes.</p>

<p class=B>Unicursal Mazes are normally generated by bisecting the passages of
a smaller Maze created with the Hunt and Kill algorithm. If Use Eller’s Algorithm
in File Settings is on, and the Maze has odd horizontal and vertical cell
dimensions, then the unicursal Maze will instead be based on the smaller Maze
created with the Binary Tree algorithm. This runs much faster due to the quick
speed of the Binary Tree algorithm.</p>

<p class=A><span class=M>More Perfect:</span> This submenu contains additional
ways to create perfect Mazes. Each command creates a Maze using a different
algorithm, resulting in a Maze with a different texture.</p>

<p class=B><span class=N>Recursive Backtrack:</span> This algorithm creates the
Maze by carving passages, where it always adds onto the most recently created
passage whenever possible, and only “backs up” to create other sections when it’s
forced to. This results in Mazes with about as high a “river” factor as
possible, with fewer but longer dead ends, and usually a very long and twisty
solution. This command is fast, although Prim’s Algorithm is slightly faster.</p>

<p class=B><span class=N>Prim's Algorithm:</span> This algorithm creates the
Maze by carving passages, where it attaches new passage segments onto the
created portion of the Maze at random points, and will rarely stay with any
single passage for any length of time. This results in Mazes with about as low
a “river” factor as possible, with many short dead ends, and the solution is
usually pretty direct too. This command is faster than any of the others except
Eller’s algorithm.</p>

<p class=B><span class=N>True Prim’s Algorithm:</span> This is a full
implementation of Prim’s algorithm involving random edge weights. It will
produce a minimum spanning tree like Kruskal’s algorithm, and therefore the
same random number seed will produce identical Mazes when running these two
commands. If Create With Wall Adding in Create Settings is on, then the Maze
will be created by adding walls instead of carving passages. If Value Is Random
Chance in Create Settings is on, then all edge weights will be the same instead
of uniquely different, resulting in a Maze that’s generated faster, however
with a lower “river” factor similar to the Prim’s Algorithm command. If Solve
Fillers Consider Dots As Exits in Maze Settings is on, then the starting point
from which this command will begin creating the Maze will be taken from the
coordinates of the dot, instead of being chosen randomly.</p>

<p class=B><span class=N>Kruskal's Algorithm:</span> This algorithm creates the
Maze by carving passages, however it doesn’t “grow” the Maze like a tree, but
rather carves passage segments all over the Maze at random, while still
resulting in a perfect Maze when done. This results in Mazes with a low “river”
factor, but not as low as Prim’s algorithm. This command runs slightly slower
than Recursive Backtrack.</p>

<p class=B><span class=N>Aldous-Broder:</span> This algorithm creates Mazes
with the special property that all possible Mazes of a given size are generated
in equal probability. It carves passages by moving the carving point around
totally randomly, relying on chance to finish the Maze, hence this is roughly
seven times slower than most of the other creation commands. These Mazes have a
low “river” factor, only slightly higher than Kruskal’s algorithm. Normally
this Maze creation command starts carving from a randomly chosen location,
however it will always start from the upper left corner if Value Is Random
Chance in Create Settings is off.</p>

<p class=B><span class=N>Wilson's Algorithm:</span> This algorithm is an
improved version of Aldous-Broder above, in that this also creates all Mazes
with equal probability (so Mazes created here are indistinguishable from those
created with Aldous-Broder) however this runs roughly five times faster, and
only twice as slow as most of the other creation commands. This carves passages
at random too, but jumps to an unfinished location each time the random walk
hits a previously carved section, so it quickly attaches passages to the Maze
until all parts have been created.</p>

<p class=B><span class=N>Eller's Algorithm:</span> This algorithm creates Mazes
by focusing on one row at a time, keeping track of which paths connect so as to
know where to carve and not carve passages, and does so extremely quickly,
faster than any other creation command. These Mazes have a lowish “river”
factor, slightly higher than the Aldous-Broder algorithm.</p>

<p class=C>If Create With Wall Adding in Create Settings set, the Maze will be
created in the same method except by adding walls instead of carving passages.
This will result in an “elitist” Maze with a short direct solution but still
difficult to solve, since there will be many long dead ends streaming down from
the entrance edge, where it won’t be obvious which passage to take.</p>

<p class=B><span class=N>Growing Tree:</span> This algorithm creates a Maze by
continually adding onto what has already been generated. The behavior of
determining what section to add onto next is controlled by the fields in the
Growing Tree section of the Create Settings dialog. A Tree Maze can have many
dead ends or few dead ends, its solution can be direct or windy, and it can be
made by carving passages or adding walls.</p>

<p class=B><span class=N>Growing Forest:</span> This algorithm is basically
multiple instances of the Growing Tree algorithm running at the same time. In
the Create Settings dialog, the Forest Initial field indicates the number of
instances to begin with: If positive the field indicates the exact number of
instances, and if negative the field indicates that one in X cells should start
out as instances. The Forest Addition field indicates the number of instances
to add each time a cell is added to the Maze: If positive the field indicates
the exact number of instances to add, and if negative indicates that one
instance should be added every X cells. If Forest Initial is one and Forest
Addition is zero, then this behaves like the Growing Tree algorithm.</p>

<p class=B><span class=N>Recursive Division:</span> The algorithm creates a
Maze by adding walls, where the area within the Maze is divided by a randomly
positioned horizontal or vertical wall with a passage opening within it. Each
subarea is then recursively divided with more walls until all areas are filled.</p>

<p class=C>The Random Settings dialog determines whether each area is divided
horizontally or vertically. If the Random Run field is 0, then divisions are
based on the area’s proportions, where short and wide areas are more likely to
be divided vertically and vice versa. Such division is adjusted by the Random
Bias field, where positive biases increase the chance of horizontal divisions
and negative biases vertical divisions. If the Random Run field is non-zero,
then divisions are purely based on the Random Bias field, where that field will
be the percentage that each division will be horizontal, ranging from -50 (all
vertical) to 0 (equal chances) to 50 (all horizontal).</p>

<p class=C>This will create a 3D Maze when the Bitmap / Bitmap Is 3D command is
set. A 3D recursive division Maze is created with plane walls (across the X, Y,
or Z axis) dividing the Maze into two halves, with one passage opening in it,
and then recursively repeating the process on each half. As with normal 3D
Mazes, increasing the Random Bias field in Random Settings will decrease the
probability of level changes in the Maze.</p>

<p class=B><span class=N>Binary Tree:</span> The algorithm creates Mazes with
the special property that each cell has a passage that leads either up or left,
but never both or neither. This creates a biased texture, where one can always
easily travel diagonally up and to the left without hitting barriers or having
to make choices. Moving down and to the right is when the Maze becomes a
challenge, so the Maze is hard to solve but easy to solve backwards. The Maze
forms a binary tree, with the upper left corner the root, where each node or
cell has one or two children, and one unique parent which is the cell above or
to the left of it.</p>

<p class=C>The Random Bias field in the Random Settings dialog will affect the
Maze, and be the percentage that each cell will connect up or to the left,
ranging from -50 (all vertical) to 0 (equal chances) to 50 (all horizontal). A
value over 50 will cause passages to seem to radiate from the root, fading from
horizontal near the top to equal along the main diagonal to vertical near the
left. A value under -50 will cause passages to radiate from the bottom right
corner, which gives an equal probability for each opening along the long top
and left edge passages to be the one to lead to the bottom right corner.</p>

<p class=C>The Random Run field in Random Settings will also affect the Maze,
where the value acts as a percentage for whether each cell row will be flipped
horizontally. (Rows in Binary Tree Mazes can be flipped and still form valid
Mazes.) A value of 0 doesn’t affect the Maze, a value of 100 flips the entire
Maze, while a balanced value of 50 results in something very similar to a
Sidewinder Maze where only the top edge consists of a long passage.</p>

<p class=C>This command will create 3D binary tree Mazes when the Bitmap Is 3D
setting is on. These Mazes have the property that each cell has exactly one
passage that leads either north, west, or up. One can always easily travel
diagonally to the upper northwest corner without hitting barriers or having to
make choices. Moving to the lower southeast corner is when the Maze becomes a
challenge. The Maze forms a ternary tree, with the upper northwest corner the
root, where each node or cell has one to three children, and one unique parent
which is the cell to the north, west, or above it.</p>

<p class=B><span class=N>Sidewinder:</span> This algorithm creates a Maze with
the property that every horizontal passage has exactly one passage leading up
from it, resulting in a Maze with no backtracking passages where the solution
path just snakes back and forth from entrance to exit. The Maze is just as hard
to solve forwards, however it’s easy to solve backwards since there’s always
exactly one way to get to the previous row.</p>

<p class=C>If the Create With Wall Adding flag in the Maze Settings dialog is
set, this command will create the Maze by adding walls. The Random Bias field
in the Random Settings dialog will affect the Maze, and be the percentage of
horizontal vs. vertical passages, ranging from -50 (all vertical) to 0 (equal
chance) to 50 (all horizontal).</p>

<p class=C>If the Bitmap Is 3D command is checked, a 3D version of Sidewinder
Mazes will be generated. A 3D sidewinder Maze consists of horizontal passages,
each of which has a single point allowing access to the horizontal passage
either to the north or above.</p>

<p class=B><span class=N>Hunt and Kill:</span> This algorithm creates the Maze
by carving passages, where it behaves similar to Recursive Backtrack. The
difference is when it can’t add onto the current passage, it will enter “hunting”
mode and search over the Maze until an unmade section is found next to an
already carved passage. By default this results in Mazes with a high “river”
factor, but not as high as Recursive Backtrack. If Create With River in the
Create Settings dialog is unset, the Maze will instead have a low “river”
factor, about the same as Kruskal’s Algorithm. This command runs slightly
slower than Kruskal’s Algorithm. Note the Perfect command uses this algorithm.
The command is included on this submenu as well so it can be compared alongside
the others.</p>

<p class=B><span class=N>Random Perfect:</span> This creates a Maze in a random
algorithm, picking at random one of the commands on the More Perfect submenu to
run. This will pick among nine possible algorithms. It won’t ever use the
Aldous-Broder algorithm because it’s slower and Wilson’s algorithm produces
Mazes of the exact same texture, and it won’t ever use the Binary Tree,
Sidewinder, or Recursive Division algorithms since their Mazes are too biased.</p>

<p class=A><span class=M>Pattern:</span> This submenu contains ways to create
Mazes in certain specialized patterns. All the Mazes here are perfect.</p>

<p class=B><span class=N>Spiral:</span> This creates a perfect Maze, however
the Maze will be composed of interlocking spirals. This looks cool and makes
the Maze have recognizable landmarks, instead of just being filled with a flat
texture as seen with the Perfect command.</p>

<p class=B><span class=N>Diagonal:</span> This creates a perfect Maze, however
the Maze will have a “diagonal bias”. This is similar to the horizontal or
vertical bias that can be specified in the Random Settings dialog, however here
the Maze will have a special texture where many of the passages will look like
stairs going diagonally from the lower left to upper right.</p>

<p class=B><span class=N>Segment:</span> This creates a standard perfect Maze,
however different sections of the Maze can have different textures. You can set
specific rectangles of pixels to have certain textures, as well as have
textures fade from one quality to another within a rectangle. See the Segment
field in the Create Settings dialog for how to define what sections of the Maze
have what textures.</p>

<p class=B><span class=N>Nested Fractal:</span> This creates a fractal Maze,
which is composed of smaller Mazes connected together. Each cell of an outer
Maze contains an inner Maze nested inside of it, where this Maze nesting
process can be repeated multiple times. See the Fractal group box in the Create
Settings dialog for fields to set the size of a fractal Maze.</p>

<p class=C>This will generate a 3D nested fractal Maze when the Bitmap Is 3D
setting is on. A 3D nested fractal Maze is a 3D cube Maze, with smaller cube
Mazes within each cell. The Fractal X field in the Create Settings dialog
determines the X and Y cell dimensions of the cubes at each nesting level, and
the Fractal Y field determines the Z cell dimension.</p>

<p class=B><span class=N>Hilbert Curve:</span> This creates a fractal unicursal
Labyrinth pattern called a Hilbert curve, consisting of a U-turn passage
composed of four other U-turn patterns linked end to end. The size or fractal
depth of the Labyrinth is taken from the Nesting Level field in the Create
Settings dialog. If Bitmap Is 3D is set, then the Hilbert curve will be 3D
instead of just 2D, and will consist of eight linked U-turn patterns.</p>

<p class=C>Daedalus can generate deterministic fractal pattern Mazes, whose
solution path is similar to a Dragon curve fractal. This command will (instead
of a standard unicursal Hilbert curve) produce a fractal Maze pattern if Allow
Isolations in Fractal is set in Create Settings. This Maze will be perfect with
no loops or isolations. The “World’s Largest Maze” script supports these Mazes,
such that this setting will affect the virtual Hilbert curve Labyrinth (F10
option #5) and make it a Dragon curve Maze instead.</p>

<p class=A><span class=M>3D:</span> This submenu contains ways to create
various types of Mazes which don’t fit on a flat 2D plane. All the Mazes here
are perfect.</p>

<p class=B><span class=N>Weave:</span> This creates a Maze where the passages
can overlap each other. This is basically still a single level 2D Maze, but it
has 3D components, so it can perhaps be considered a 2.5D Maze. The passages
here are one pixel thick, however walls are three pixels thick. This gives room
to make it clear when a passage is a dead end and when a passage goes
underneath another. For further clarity, when a passage does go under another,
it will always continue on the opposite side, where the passage will never
change direction or terminate in a dead end while under the other passage. The
Mazes created here will be “perfect” and have a single solution. Note Weave
Mazes can be harder to solve than they appear.</p>

<p class=B><span class=N>3D:</span> This creates a true three dimensional Maze
with multiple levels, where there can be passages up and down in addition to
the four compass directions. The size of the 3D Maze to create is specified in
the Size or Maze Size dialogs, where the bitmap will be resized to fit those
dimensions, instead of the Maze being created within the current size of the
bitmap. Daedalus represents a 3D Maze as a list of levels or sections, where
there are sections between each 3D level to indicate the up and down passages
going between levels. When looking at a level in a 3D Maze, you need to look at
the sections above and below it to see whether there are passages up or down
from a cell. Therefore you may want to use the View Inside, Clarify 3D, or Save
Text commands to get a more easily understood view of the Maze. The 3D Maze
will be “perfect” and have a single solution. Note 3D Mazes are extremely
difficult to solve.</p>

<p class=B><span class=N>4D:</span> This creates a four dimensional Maze! A 4D
Maze is like a 3D Maze, except there can be passages through the 4th dimension
in addition to all the 3D directions. A cell in a 4D Maze can have passages in
eight directions: The four compass directions, up, down, and “portals” to what
can be considered the past and future. Daedalus represents a 4D Maze as a 2D
array of levels or sections, where there are up to four sections surrounding
each 4D level to indicate the passages going between levels through the third
and fourth dimensions. You may want to use the Clarify 4D command on the Maze
menu to create a more easily understood view of the Maze. Expect a 4D Maze to
be even harder to follow than a 3D Maze.</p>

<p class=B><span class=N>Planair:</span> This allows creating Mazes with
unusual topology, which means connecting the edges of the Maze in interesting
fashions. For example this can be used to create a Maze on the surface of a
cube, or a Maze on the surface of a Moebius strip. Until you specify otherwise,
the default Maze created with this command is a Maze equivalent to being on a
torus with the left and right sides wrapping around to each other and the top
and bottom wrapping. These Mazes are represented as a list of one or more
rectangular Maze sections, similar to the way a 3D Maze is represented. The
size of each section is taken from the 3D dimensions in the Size or Maze Size
dialogs. The Planair field in the Maze Settings dialog defines how many
sections there are, and more importantly how the edges match up, i.e. where a
passage continues when it goes off the edge of one of the sections. The created
Maze won’t have an official entrance or exit, where it’s up to you to define
one, however it will have a “perfect” quality (as long as you don’t define any
one way edges) where there will be exactly one path between any two points in
the Maze.</p>

<p class=C>This command will create a wireframe of the Maze’s walls in memory,
if Make Wireframe Also in Create Settings is set, and also if the Planair
creation string is set to generate a Maze on the surface of a cube
(specifically set to “e2d3f0b1 e7a3f3c1 e4b3f6d1 e1c3f5a1 c4d0a0b4 a2d6c6b2”).
This wireframe will depict a cube, in which each face is a different color, and
with arrows pointing to the middle of opposite faces to indicate entrance and
exit points.</p>

<p class=B><span class=N>Hyper:</span> This creates a Hypermaze, or a Maze
where the solving object is a line instead of just a point. In every other Maze
you move a point through whatever dimension environment, where the path behind
you forms an irregular line. In a Hypermaze you move a line through a 3D
environment, where your path forms a surface! The Hypermaze is a 3D object,
with solid top and bottom faces and what looks like a tangle of vines between
them, where your goal is to move a line segment through the Hypermaze object,
from one side to the other, like moving a piece of dental floss between two
teeth. Hypermazes are harder to solve than standard 3D Mazes of the same size,
since you need to be aware of and work with all points along the line segment.
Use the Fill Hyper Dead Ends command on the Solve menu to solve a Hypermaze and
show its solution surface. As far as I know Daedalus is the first and only
program that can create Hypermazes.</p>

<p class=A><span class=N>Crack:</span> This creates a Maze not on any
consistent grid, but rather that has walls and passages at random angles. This
uses a wall adding algorithm and results in a “perfect” Maze. Random one pixel
wide walls will be added onto what’s already present, where initially long
lines going across the Maze will be generated, followed by other proportionally
smaller lines between them. The number of walls is only limited by the bitmap’s
resolution, making the Maze look like the surface of a leaf, so this is really
another type of fractal Maze.</p>

<p class=A><span class=N>Cavern:</span> This creates a Maze that’s a mixture
between a standard orthogonal Maze and a Crack Maze. The Maze is not on any
consistent grid, however the walls and passages are still orthogonal, where
each passage or wall segment is a single pixel instead of two pixels. This Maze
is created with the Growing Tree algorithm, where all the fields in the Growing
Tree section of the Create Settings dialog apply here too. When the Maze is
passage carved, passages will always be one pixel thick while walls can be one
or two pixels thick. When the Maze is wall added, walls will be one pixel thick
while passages can be one or two pixels thick.</p>

<p class=A><span class=N>Arrow:</span> This creates a Maze where passages can
only be traversed in one direction. The Maze is composed of a bunch of small
arrows, where you may only travel over an arrow in the direction it’s pointing.
These Mazes are likely to have “traps”, which are cells or areas where all the
arrows are pointing toward it, meaning you can’t ever leave. The Mazes created
by this command will always have a single solution, although there will likely
be a number of ways to go from a later point on the solution path back to an
earlier point on it.</p>

<p class=B>If the color bitmap is active, the solution to the generated arrow
Maze will be placed in the color bitmap. The solution will be a copy of the
Arrow Maze in color, with arrows in different colors indicating the solution. Red
arrows mark the single solution path. Green arrows are false paths that can be
recovered from, always going from somewhere on the solution path to somewhere
earlier on it. Blue arrows are false paths that can’t be recovered from, always
going from somewhere on the solution path into the void from which it’s never
possible to get back to the solution. White arrows are paths within the void
from which it’s never possible to reach the solution, where every white arrow
can be followed backwards on a unique path of white arrows to reach a blue
arrow, which ensures every cell within the Arrow Maze is reachable by some
path. Gray arrows are the remaining paths within the void, where every gray
arrow has at least one white or blue arrow on both ends of it.</p>

<p class=A><span class=N>Tilt:</span> This creates a design that isn’t a real
Maze, but is still an interesting pattern. This creates a grid of diagonal line
segments, which randomly face one way or the other. The result is a bunch of
unicursal passages, which either start and end on the edges, or are isolated
passage loops within the pattern.</p>

<p class=A><span class=N>Recursive Fractal:</span> Daedalus can create Mazes
that are truly infinite sized! This command will generate an infinite recursive
fractal Maze, which is a Maze that contains copies of itself, hence having an infinite
number of passages in a finite area. (Since the copies contain copies
themselves at deeper levels, you can enter copies forever.) The Maze looks like
a microchip, with pins around the outside, and one or more numbered smaller
chips in the middle. Your goal is find your way from the “minus” chip to the “plus”
chip on the top level, following wires which sometimes weave under each other.
When you enter one of the nested chips, jump to the corresponding pin on the
outer edge. When you leave via one of the outer edge pins, jump to the
corresponding pin on the numbered chip through which you entered that level.
Your location in the Maze is defined by where you are in the current level,
combined with the stack of levels above you. Note the only dead ends in the
Maze are at the outer pins, either on the outermost level, or when leaving a
level when a numbered chip doesn’t have a wire connecting to that pin.
Recursive fractal Mazes and this representation of them were invented by Mark
J. P. Wolf, where examples can be seen in his book “100 Enigmatic Puzzles”.</p>

<p class=B>Regardless of whether the color bitmap is being shown, a colored
version of the Maze with colored wires and chips will also be placed in the
color bitmap, using a rainbow or other blend of colors as defined in the
Replace Color dialog. The number of horizontal and vertical pins on each chip
is defined by the X and Y fields in the Fractal section of the Create Settings
dialog. The number of chips is defined by the Nesting Level in the dialog, and
may range from 1 to 7.</p>

<p class=B>Several settings will affect the recursive fractal Maze. If the
Allow Isolations In Fractal checkbox in Create Settings is set, creation won’t
insist that every part of the Maze be reachable from the start. Creation will
always ensure there exists at least one solution, and normally ensures every
passage is reachable on some level, i.e. that there are no isolated
inaccessible passages. If Weave Crossings May Corner in Create Settings is set,
passages may turn a corner when crossing each other, as opposed to having to
continue straight at such points. If Tilt Lines Make No Diamonds is set,
junctions between wires won’t be highlighted with thick blocks as they normally
are. If Find A Path Finds Random Path in Maze Settings is set, passages will make
turnings more, although will still take a shortest path between pins. The
Random Bias field in the Random Settings dialog will affect the difficulty of
the Maze. A negative value makes the Maze easier, by increasing the probability
of passages connecting outer pins, which gives more opportunities to leave
nested chips. A positive value makes the Maze harder, by decreasing the
probability of passages connecting outer pins, giving fewer opportunities to
leave nested chips. A value of -50 is easiest and is guaranteed to have a
solution of depth 1, while a value of 50 is hardest and impossible to solve.
Note not all sizes and settings of recursive fractal Mazes are possible.
Daedalus will make a number of attempts to create the Maze equal to the Crack
Pass Limit in Create Settings, and if it hasn’t succeeded by then, an error
message will be shown.</p>

<p class=A><span class=M>Infinite:</span> This submenu has commands which allow
creating an infinitely long Maze! Such a Maze will have a fixed width, but its
length can be as long as you want. This is implemented by keeping only a
certain section of the Maze in memory at a time. Once a section is completely
created, it can be saved to disk or just allowed to scroll off the top of the
screen. See the Infinite Maze section of the File Settings dialog for settings
related to creating infinite Mazes.</p>

<p class=B><span class=N>Start:</span> This starts creating a new infinite
Maze. The bitmap can be considered to cover two “sections” of infinite Maze,
where the commands here finish one section at a time. Once the top section is
completely created, this command will stop, leaving the bottom section half
created.</p>

<p class=B><span class=N>Continue:</span> This continues creating an infinite
Maze begun with the Start command. This will discard the old top section that’s
completely created, and “scroll” down so the old bottom section becomes the new
top section, and a new uncreated section becomes the new bottom section. Then
more of the Maze will be created, where once the new top section is finished,
this command will stop, leaving the new bottom section half created again. Keep
running this command to add more and more sections to the Maze. If an infinite
Maze hasn’t been started yet, this will do the same as the Start command.</p>

<p class=B><span class=N>End:</span> This finishes an infinite Maze begun with
the commands above. This is like the Continue command, except instead of
leaving the bottom section half created, it will finish creating both sections,
and put an exit in the bottom edge. The smallest infinite Maze it’s possible to
create will have three sections or be 1.5 times the size of the bitmap, which
is created by running the Start command immediately followed by End. If an
infinite Maze hasn’t been started yet, this will do the same as the Start
command.</p>

<p class=B><span class=N>Restart:</span> When creating an infinite Maze, you
should not edit the bitmap between generations, because the program remembers
information about the Maze such as how many more cells need to be done to
finish the bottom section. This command does exactly the same thing as the
Continue command, except it recalculates that information before proceeding to
continue the Maze. If you’re making a very large infinite Maze and need to exit
the program and continue it later, you should save a copy of the bitmap, then
exit. Upon restarting the program, you should reload the bitmap, then run this
command once to properly create the next section. You may then keep running the
Continue command as normal. Note if Use Eller’s Algorithm is set, trying to
restart the Maze will create loops, although the Maze will still be solvable.</p>

<p class=A><span class=M>Omega (Shapes):</span> This submenu has commands to
create Mazes on non-orthogonal grids. Except for the Zeta command, the number
of passages in these Mazes is not determined by the size of the bitmap, but is
rather contained in the Omega Dimensions field in the Create Settings dialog.
The larger the bitmap, the wider the passages. If the bitmap is too small to
contain the specified Maze, the bitmap will be automatically enlarged. All
these Mazes will be “perfect” and have a single solution.</p>

<p class=B><span class=N>Gamma (Square):</span> This creates a simple square
Maze composed of square cells. It differs little from the standard Perfect
command, except the Maze dimensions are taken from the Omega Shapes Dimensions
in Create Settings, and passages will be as wide as possible that fits within
the current bitmap. However this provides a simple square Maze to contrast with
the triangular, hexagonal, and other shaped Mazes.</p>

<p class=B><span class=N>Theta (Circle):</span> This creates a circular Maze
formed of layers of concentric rings. The cells are mostly rectangular, and
usually can have four passages leading from them, however some cells have five
passages, because the number of cells in a ring increases as you go out from
the center. It’s recommended to create this in a square bitmap so the Maze is
circular instead of elliptical. The name of this style of Maze comes from the
circular shape of the capital Greek letter Theta.</p>

<p class=B><span class=N>Sigma (Hexagon):</span> This creates a hexagon shaped
Maze that’s also formed of interlocking hexagons. All cells are hexagon shaped,
and have up to six passages leading from them. The name of this style of Maze
comes from the shape of the capital Greek letter Sigma, which has similar
horizontal and diagonal angles seen in a hexagon.</p>

<p class=B><span class=N>Delta (Triangle):</span> This creates a triangle
shaped Maze that’s also formed of interlocking triangles. All cells are triangle
shaped, and have up to three passages leading from them. The name of this style
of Maze comes from the triangle shape of the capital Greek letter Delta.</p>

<p class=B><span class=N>Upsilon (Octagon):</span> This creates a Maze formed
of interlocking octagons and squares. All cells are either octagon or square
shaped, and have up to eight or four passages leading from them. The name of
this style of Maze comes from the capital Greek letter Upsilon, which has
similar vertical and diagonal angles seen in this Maze.</p>

<p class=B><span class=N>Omicron (Sphere):</span> This creates a Maze on the
surface of a sphere. It’s most similar to the Theta (Circle) Mazes that are
disk shaped, except here the Maze is by default drawn flattened. That means
passages at the top and bottom which map to the top and bottom of the sphere
are wider, because they map to the smaller radius polar areas. To actually see
the Maze in sphere form, turn on Make Wireframe Also in Create Settings, which
will also create a 3D spherical wireframe in memory of the Maze.</p>

<p class=C>The Mazes above can be generated using the Binary Tree algorithm. If
the Use Eller’s Algorithm flag in File Settings is set, then each Maze will be
created using an appropriate variation of the Binary Tree algorithm. For
example, Sigma (Hexagon) Mazes will feature each hexagon cell have a passage
leading left, up and to the left, or up and to the right, resulting in a
ternary tree.</p>

<p class=B><span class=N>Zeta (8 Way):</span> This creates a Maze on a standard
rectangular grid, however diagonal 45 degree angle passages are allowed between
cells in addition to horizontal and vertical ones. Each cell has up to eight
passages leading from it. Like Weave Mazes, passages will always be one pixel
thick and walls three pixels. The name of this style of Maze comes from the “Z”
shape of the capital Greek letter Zeta.</p>

<p class=A><span class=M>Labyrinth:</span> This submenu has commands to create
various styles of unicursal Mazes. Unlike the random unicursal Mazes created
with the Unicursal command, these always create the same fixed design.
Unicursal Mazes are usually referred to today as Labyrinths, where these Labyrinths
can be used as a tool for meditation and spiritual growth. As with the Omega
Mazes above, these unicursal Mazes will be drawn within whatever size the
bitmap is, where the larger the bitmap, the wider the Labyrinth’s passages. If
the bitmap is too small to contain the specified Labyrinth, the bitmap will be
automatically enlarged.</p>

<p class=B><span class=N>Current Labyrinth:</span> This recreates whatever
style of Labyrinth below was created most recently, i.e. whatever style is
specified in the Labyrinth Type field in the Create Settings dialog.</p>

<p class=B><span class=N>Labyrinth Settings...:</span> This dialog allows
accessing settings that affect the Labyrinth creation commands on the Labyrinth
submenu.</p>

<p class=C><span class=O>Current Labyrinth:</span> This radio button group
determines the type of Labyrinth to draw when the Current Labyrinth command is
run. The six options here (Classical, Chartres, Cretan, Man in The Maze,
Chartres Replica, and Custom) map to the corresponding commands on the
Labyrinth submenu. </p>

<p class=C><span class=O>Circle:</span> This is a radio button in the “circuit
shape” group. When selected Labyrinths will be drawn entirely using curved
circuits.</p>

<p class=C><span class=O>Rounded:</span> This is a radio button in the “circuit
shape” group. When selected Labyrinths will be drawn rectangular with
horizontal and vertical walls, except the corners will be rounded.</p>

<p class=C><span class=O>Square:</span> This is a radio button in the “circuit
shape” group. When selected Labyrinths will be drawn rectangular with
horizontal and vertical walls everywhere.</p>

<p class=C><span class=O>Flat:</span> This is a radio button in the “circuit
shape” group. When selected Labyrinths will be drawn flattened if possible,
with circuits unfolded into rows.</p>

<p class=C><span class=O>Classical Size:</span> This field indicates the number
of circuits to include when the Current Labyrinth type is Classical or Man in
the Maze. Setting this to 0 will result in a 3 circuit Labyrinth, 1 will result
in the default sized 7 circuit Labyrinth, 2 will result in 11 circuits, and so
on with each later number increasing the number of rings by four.</p>

<p class=C><span class=O>Classical Size is Circuits:</span> When this is set,
the number in the Classical Size field will indicate the exact number of circuits
to use in the Classical or Man in the Maze type Labyrinths. This value will be
rounded up to the nearest number that’s one less than a multiple of four, e.g.
3, 7, 11, and so on. On most Windows systems, classical Labyrinths can be
created with up to 12003 circuits (size 3000 when this flag is off) before
reaching memory allocation limits for bitmaps.</p>

<p class=C><span class=O>Custom Paths:</span> This string indicates the custom
sequence of circuits when drawing a custom Labyrinth. Circuits are specified in
navigation order, where circuit 1 means the outer edge. Circuits may be
specified with numbers where letters are used for circuits 10 and beyond, or
circuits may be specified with just letters where “A” is the outer edge
circuit. Custom Labyrinths may be created with up to 30 circuits. A blank
string will produce a 0 circuit Labyrinth with a single wall.</p>

<p class=D>The equals sign followed by a number will be mapped to the first
Labyrinth with that many circuits, e.g. “=3” means “123” with sequentially
increasing circuits. The equals sign followed by a negative number will be
mapped to the last Labyrinth with that many circuits, e.g. “=-3” means “321”
with sequentially decreasing circuits. The equals sign followed by “@” then a
number of circuits will be mapped to a circuit sequence forming a single large
spiral into and back out from the middle circuit, e.g. “=@5” translates to “52341”
and “=@9” translates to “927456381”. The string “=Classical” will map to the
circuits for the default classical seven circuit Labyrinth, namely “3214765”.</p>

<p class=D>Different sequences of circuits (which are effectively different
Labyrinths) may be separated by commas. For example, “=@5,1,-3” translates to a
5 circuit spiral (“@5” or “52341”), followed by a single circuit (“1”) in
normal order, followed by three circuits in reverse order (“-3” or “321”).
Subsequent tokens will have their numbers adjusted by the current offset in the
Labyrinth, resulting in “523416987” for the whole Labyrinth above. The token
prefix “'” (single quote) will treat the numbers following it as a standard
Labyrinth circuit sequence, although offset appropriately if in a comma
separated list.</p>

<p class=C><span class=O>Custom Autoiterate:</span> When this flag is set, each
time a custom Labyrinth is generated the Custom Paths field will be updated to
a different valid Labyrinth. The Labyrinths will proceed in sequence through
Labyrinths of the same number of circuits, skipping any circuit layouts that
are invalid based on the Fanfolds Allowed and related settings. This feature
can be used to display and count the number of Labyrinths possible of a given
size.</p>

<p class=D>If Don’t Autostart Infinite in File Settings is on, then
automatically iterating Labyrinths will stop after the last valid Labyrinth of
a given size is displayed. When that flag is off, progression loops back to the
beginning or the initial Labyrinth with sequentially increasing circuits.</p>

<p class=C><span class=O>Fanfolds Allowed:</span> This field determines whether
extraneous circuits are allowed in autoiterated custom Labyrinths. A fanfold
passage is two adjacent circuits (e.g. ...34... or ...65...), surrounded on
either side by circuits moving in the same direction (e.g. ...4567... or
...8541...). In such a case the middle adjacent circuits can be considered
extraneous since they don’t add anything important to the structure of the Labyrinth,
since they amount to a “hiccup” along the way of the traversal between the
circuits on either side of it. If there’s a direction change (e.g. ...6547...
or ...6125...) then you can’t delete the middle adjacent circuits since they’re
an integral part of the Labyrinth’s structure (or at least every Labyrinth has
at least one sequence like this). When this value is 2, all Labyrinths will be
shown regardless of fanfold circuits. When this value is 1, Labyrinths with
obvious fanfolds involving 3 or more adjacent circuits (e.g. ...3458... or
...9654...) will be skipped. When this value is 0, only Labyrinths with no
fanfold circuits anywhere will be shown (e.g. skip ...2569... and ...8541...).</p>

<p class=C><span class=O>Asymmetry Allowed:</span> This field determines the
asymmetry allowed in autoiterated custom Labyrinths. A Labyrinth is symmetric
if it has the same circuit sequence when flipped inside out. When this value is
2, all Labyrinths will be shown regardless of symmetry. When this value is 1, only
one of the two combinations of asymmetric Labyrinths will be shown. When this
value is 0, only fully symmetric Labyrinths will be shown.</p>

<p class=C><span class=O>Circuit Partitioning:</span> This field determines
whether partionable Labyrinths are allowed in autoiterated custom Labyrinths. A
Labyrinth can be circuit partitioned if at any point (other than the outer and
innermost edges) there’s only one opening in the wall between two circuits,
i.e. it can divided between any two circuits into two smaller Labyrinths. When
this value is 2, all Labyrinths will be shown regardless of partitioning. When
this value is 1, Labyrinths with trivial levels at the entrance or exit will be
skipped, where such a situation is simply a partition involving a 1 circuit
section on the outer or inner edge. When this value is 0, only Labyrinths with
no partitioning anywhere will be shown.</p>

<p class=C><span class=O>Radius Partitioning:</span> This field determines
whether Labyrinths partitioned along the axis perpendicular to circuits are
allowed in autoiterated custom Labyrinths. The only way to have a radius
partition in a Labyrinth is next to the entrance or exit, by jumping from the
entrance to the innermost circuit, or jumping from the outermost circuit to the
center. When this value is 2, all Labyrinths will be shown regardless of radius
partitioning. When this value is 1, Labyrinths with two radius partitions that
both start with the inner circuit and end with the outer circuit will be
skipped (but one of those radius partitions is allowed to be present). When
this value is 0, only Labyrinths with no radius partitioning anywhere will be
shown.</p>

<p class=C><span class=O>Radius:</span> This radio button in the “custom align”
group draws custom Labyrinths such that the main radial wall that’s adjacent to
the entrance and exit and marks where circuits change direction is always
centered within the Labyrinth. This will cause the entrance and exit to be
offset half a passage width to the left or right of the main radial wall.</p>

<p class=C><span class=O>Entrance:</span> This radio button in the “custom
align” group draws custom Labyrinths such that the entrance is always centered
within the Labyrinth. This will cause the main radial wall to be offset a half
passage width to the right of the entrance.</p>

<p class=C><span class=O>Exit:</span> This radio button in the “custom align”
group draws custom Labyrinths such that the exit is always centered within the
Labyrinth. This will cause the main radial wall to be offset a half passage
width to the left or right of the exit.</p>

<p class=C><span class=O>Balanced:</span> This radio button in the “custom
align” group draws custom Labyrinths such that the entrance and exit are both
centered as much as possible within the Labyrinth. For odd sized Labyrinths
this will behave like Radius alignment where the radial wall will be centered
with the entrance and exit offset on either size of it, and for even sized
Labyrinths this will behave like Entrance and Exit alignments where the
entrance and exit will be centered and the radial wall offset to their right.</p>

<p class=C><span class=O>Merged:</span> This radio button in the “custom align”
group allows custom Labyrinths to be generated so the entrance and exit to the
center are aligned within the same column. If the entrance and exit are on opposite
sides of the radial wall (which is always the case for odd number circuit
Mazes) the radial wall will be bent so they can be aligned, leaving a small
inaccessible area between the entrance and exit passages. If alignment already
happens by default (which happens when the entrance and exit are on the same
sides of the radial wall, always the case for even number circuit Mazes) then
this behaves like Balanced. If alignment isn’t possible (which happens when the
passages leading to the entrance and exit run parallel and would overlap) then
this behaves like Exit, so at least the inner part of the Labyrinth looks the
same regardless of whether merging is possible.</p>

<p class=D>Note that a special Labyrinth will be drawn, when the dialog fields
are set to “Classical”, “Square”, and “Merged”. It will be a variation of the
classical Labyrinth with the number of circuits defined by the “Classical”
fields. This Labyrinth always has walls and passages one pixel wide, and the
bitmap won’t be resized. That means depending on the size of the Labyrinth and
bitmap, the Labyrinth will be in the upper left corner of the bitmap, or
clipped on the bottom right. This is basically a way to access the virtual
Labyrinth drawn in the “World’s Largest Maze” script.</p>

<p class=C><span class=O>Custom</span><span class=O> Center</span><span
class=O> Size:</span> This field determines the diameter in passage widths of
the center area in a custom Labyrinth. Some circuit sequences, circuit shapes,
and entrance/exit alignments require a certain minimum center size to display
properly. If the desired number is too small, the actual diameter used when
drawing the Labyrinth will be the smallest possible. If this value is zero, the
diameter will be the smallest possible that all Custom Path circuit sequences
of that size can display within. This option allows automatically iterating
through Labyrinths without the center changing sizes during the iteration.</p>

<p class=B><span class=N>Classical:</span> This creates a classical seven
circuit Labyrinth, which has seven rings and has been seen in many different
cultures throughout the world.</p>

<p class=B><span class=N>Chartres</span><span class=N>:</span> This creates a
style called the Chartres Labyrinth, which has eleven rings and four quadrants,
where the start and end passages are close but not perfectly lined up. This
style has been popularized by a Labyrinth of this type in the floor of Chartres
Cathedral in France, and is commonly walked for spiritual purposes today. </p>

<p class=B><span class=N>Cretan:</span> This creates a style somewhat related
to the Chartres Labyrinth called the Cretan Labyrinth, which has ten rings and
four quadrants, where the start and end passages line up.</p>

<p class=B><span class=N>Man in the Maze:</span> This creates a style called
the Man in the Maze, which is a variant of and is topologically equivalent to
the classical seven circuit Labyrinth. It has seven concentric circles with the
seed pattern in the center, and is commonly seen in art of the Tohono O’Odham
nation and other Native American tribes.</p>

<p class=B><span class=N>Flat Classical:</span> This is like the Classical
command, except the bottom half where the entrance is located is always square,
which makes the Labyrinth look like a door or archway. The seed pattern isn’t a
cross but is rather an uneven cross, which allows the passages on either side
of the entrance to extend down to the same level.</p>

<p class=B><span class=N>Flat Chartres:</span> This is like the Chartres command, in that it creates a Labyrinth topologically equivalent to the Chartres
Labyrinth. This will however be an “unfolded” version of that Labyrinth, like
if you cut the circular version in half between the start and finish, and
unfolded it into a straight version. This unfolded version can help in
understanding the design and symmetry of the standard version.</p>

<p class=B><span class=N>Chartres</span><span class=N> Replica:</span> This is
an improved version of the Chartres command. It creates the same pattern,
except it adds extra decorations making it a true replica of the Chartres
Cathedral Labyrinth. Specifically this adds or does the following things
differently: (1) The Labyrinth here has truly circular rings, instead of just
being rounded at the corners like the Chartres command. (2) This Labyrinth has
lunations, or a ring of semicircles around the outside of it. Specifically
there are 112 two-thirds circles (called cusps) and 113 points or lines
connecting them (called foils). (3) This Labyrinth has a rosette or six petaled
area in the middle. This is based on an invisible 13 sided polygon, where there
are two sides per petal and one more side for the passage leading to the
center. (4) This Labyrinth has extra curves that make the U-turn and corner
points of the path rounded. This creates ten Labrys or double headed axe shapes
along the axes of the Labyrinth.</p>

<p class=B><span class=N>Custom:</span> This draws a unicursal Labyrinth with a
custom specified circuit sequence. Each circuit fills an entire ring of the
Labyrinth, each circuit alternates direction from the previous circuit, and the
Labyrinth always starts on the outside and ends in the center. Like the other
commands on the Labyrinth submenu, the circuits will be the widest possible
that fit within the current bitmap dimensions. The circuit sequence comes from
the Custom Paths field in the Labyrinth Settings dialog.</p>

<p class=A><span class=M>Partial Create:</span> This submenu has commands to
partially create a Maze. This means adding onto what’s already present in the
bitmap, instead of clearing the bitmap and making a totally new random Maze.</p>

<p class=B><span class=N>Perfect at Dot:</span> This is like the Perfect
command in that it creates a perfect style Maze, however this doesn’t clear the
bitmap first, but rather it carves passages into whatever’s already on the
bitmap. This means filling whatever solid area the dot is over with passages.
It will also take existing passages next to solid areas anywhere on the bitmap,
and continue the passages into those areas. If the dot isn’t over a solid area,
and there are no existing passages to start from, Perfect At Dot will do
nothing. This command can be used to create Mazes of irregular shapes, where
you define the outline, fill it in, then do Perfect At Dot within it. This is
also the way to have the computer partially create or finish creating a Maze,
where you define the solution and main dead ends, and the program fills in the
rest.</p>

<p class=B><span class=N>Braid Add Walls:</span> This is related to the Braid
command used to create Braid style Mazes without dead ends. This will add wall
segments to the Maze in the bitmap in random order. Specifically it will add
all possible walls that won’t cause a dead end to be created, and that won’t
cause a section of the Maze to become inaccessible. The Braid command does this
operation internally when creating Braid Mazes.</p>

<p class=B><span class=N>Unicursal Thinned:</span> This is related to the
Unicursal command used to create unicursal Mazes having a single path without
junctions. This should only be run on a biased zoomed Maze where walls are one
pixel thick and passages are three pixels. This adds walls bisecting each
passage, where each old dead end becomes a new U-turn passage. When run on
perfect Mazes, this basically turns the perfect Maze into a unicursal Maze. The
Unicursal command does this operation internally when creating Unicursal Mazes.</p>

<p class=B><span class=N>Recursive at Dot:</span> This is like the Recursive
Backtrack command in that it creates a perfect style Maze using the recursive
backtrack algorithm, however this doesn’t clear the bitmap first, but rather
carves passages into whatever’s already on the bitmap. This works exactly like
the Perfect At Dot command, however this will not also extend existing
passages. If you want to define the solution or anything other than the area to
fill in, use Perfect At Dot.</p>

<p class=B><span class=N>Prim's at Dot:</span> This is like the Prim’s
Algorithm command in that it creates a perfect style Maze using Prim’s
algorithm, however this doesn’t clear the bitmap first, but rather carves
passages into whatever’s already on the bitmap. This works exactly like Perfect
At Dot, however this will not also extend existing passages.</p>

<p class=B><span class=N>Kruskal Passages:</span> This is like the Kruskal’s
Algorithm command in that it generates a Maze using that algorithm, however
this doesn’t clear the bitmap first, but rather carves passages into any solid
areas already on the bitmap. This will not extend any existing passages into
solid areas next to them.</p>

<p class=C>This command supports the concept of separate Mazes, i.e. sets of
points that should not have any path between them after the Maze is generated,
even if those points are in the same connected island. This is implemented by
assuming those points are already connected or have some invisible passage
connecting them when carving additional passages. If the color bitmap exists,
is the same size as the main bitmap, every off pixel in the main bitmap is
black in the color, and every on pixel in the main bitmap is non-black in the
color (i.e. the color bitmap is a copy of the main bitmap except with coloring)
then the color bitmap will contain the pre-connected points to use in creation.
Each cell pixel that’s non-white will be considered connected with every other
cell that’s the same color, i.e. there will be no path between any such colored
cells in the finished Maze. Cells that are white can be connected with any
other cell. This pre-connected points feature is used to create perfect Mazes
in the “Glacier Maze Simulation” script, where the pre-connected points are
where bridges have their endpoints.</p>

<p class=B><span class=N>Tree at Dot:</span> This is like the Growing Tree
command in that it creates a Tree style Maze, however this doesn’t clear the
bitmap first, but rather carves passages into whatever’s already on the bitmap.
This works exactly like Perfect At Dot, however this will not also extend
existing passages. Note this command will always carve passages, even if Create
With Wall Adding in the Create Settings dialog is set.</p>

<p class=B><span class=N>Weave at Dot:</span> This is like the Weave command in
that it creates a Weave style Maze, however this doesn’t clear the bitmap
first, but rather carves weave passages into whatever’s already on the bitmap.
This will also extend any existing passages into solid areas next to them.</p>

<p class=B><span class=N>Crack Add Walls:</span> This is like the Crack command
in that it creates a Crack style Maze, however this doesn’t clear the bitmap
first, but rather adds lines to whatever’s already on the bitmap.</p>

<p class=B><span class=N>Cavern at Dot:</span> This is like the Cavern command
in that it creates a Cavern style Maze, however this doesn’t clear the bitmap
first, but rather carves passages into whatever’s already on the bitmap. This
works like Perfect At Dot, however this will not also extend existing passages.
Note this command will always carve passages, even if Create With Wall Adding
in the Create Settings dialog is set.</p>

<p class=B><span class=N>Zeta at Dot:</span> This is like the Zeta command in
that it creates a Zeta style Maze, however this doesn’t clear the bitmap first,
but rather carves passages into whatever’s already on the bitmap. This will
also extend any existing passages into solid areas next to them.</p>

<p class=A><span class=N>Polished Mazes:</span> Mazes in Daedalus can be
created in a polished form. Polished Mazes look better and are ready for
printing. Most Maze creation commands produce a Maze with walls and passages of
equal thickness, where one may think it looks better to have walls thinner than
passages. Also the default colors in the program have white walls on a black
background, however the reverse is better to save ink when printing. This
command sets a mode that will cause all created Mazes to have a polished form.
Activating this mode will also switch from white on black to black and white
coloring, switch from a gray to a white border, and center the bitmap in the
window. Leaving this mode will do the reverse. Activating the mode will also
polish any existing Maze in the bitmap if an appropriate Maze creation command
was the most recent autorepeatable command run, while leaving polished mode
will unpolish a Maze if possible. The only downside of polished Mazes is
further commands such as solving tend to only work on the raw form of a Maze.
Still, polished Mazes are the best for simply viewing and printing.</p>

<p class=B>Polished standard orthogonal Mazes will have walls one pixel thick
and passages three pixels (i.e. they automatically have the Zoom Bias command
applied to them). Polished 3D and 4D Mazes will have transitions between levels
indicated in cells in the main and color bitmaps (i.e. they automatically have
the Clarify 3D or 4D commands applied to them). Polished Hypermazes are a 3D
overview of the Hypermaze (i.e. they automatically have the Render Bitmap
Overview command applied to them, using its settings). Non-orthogonal Mazes
such as Crack, Cavern, and Zeta Mazes will have smoother walls (i.e. they
automatically have the Smooth Zoomed command applied to them). The Chartres Replica
Labyrinth will have filled in walls instead of hollow walls.</p>

<p class=A><span class=N>Create Settings...:</span> This dialog accesses all
settings dealing with creating specific types of Mazes.</p>

<p class=B><span class=O>Create With &quot;River&quot;:</span> This affects
Maze generation commands that create or internally use perfect style Mazes.
This includes the following commands: Perfect, Perfect At Dot, Unicursal,
Outline, Weave, Weave At Dot, 3D, 4D, Arrow, Planair, Theta (Circle), Sigma
(Hexagon), Delta (Triangle), Upsilon (Octagon), Zeta (8 Way), and Infinite.
When set, the Maze will be created with a high river factor, with longer
passages between junctions and fewer but longer dead ends. When unset, the Maze
will created with a low river factor, with shorter passages and more but
shorter dead ends.</p>

<p class=B><span class=O>Have &quot;River&quot; at Edges:</span> This only
plays a role in the Perfect At Dot command. When set, passages next to edges of
the Maze will tend to follow along the edges. When unset, passages next to
edges of the Maze will tend to move away from the edge or have dead ends near
them.</p>

<p class=B><span class=O>No &quot;River&quot; Flowback:</span> This subtle
setting only plays a role in the Perfect At Dot command. When set, when
creating the Maze the point carving it must always make a new passage, or else
it enters “hunting” mode. When unset, the point carving the Maze is allowed to
wander back into already created portions of the Maze while looking for a new
passage to create. When unset the Maze will have a somewhat lower river factor.</p>

<p class=B><span class=O>Omega Dimensions:</span> This contains the number of
passages to include in Omega style Mazes. Specifically this means the number of
rings of passages to have in circular Theta Mazes, the number of hexagons to
have on an edge in hexagonal Sigma Mazes, and the number of rows of triangles
to have in triangular Delta Mazes.</p>

<p class=B><span class=O>Omega Inner Dimensions:</span> This value only plays a
role when creating circular Theta Mazes. It contains the inner radius, i.e. how
many rings from the center should not be passage rings but rather part of the
center area. The larger the number, the bigger the central room.</p>

<p class=B><span class=O>Omega Start Location:</span> This indicates the
location to use for the entrance in Omega style Mazes. When this value is
negative, it means to have the start at a random location. If the number or
parts of the number are illegal for the Maze in question, it will also be
chosen randomly.</p>

<p class=C>For Theta Mazes, this value means to have the start on the inner
ring at the nth segment clockwise starting from a 45 degree angle up and to the
right.</p>

<p class=C>For Sigma Mazes, the 1000’s place indicates which of the six sides
to have the entrance on, ranging from 0 to 5. Side 0 is the top, 1 is the upper
right, 2 is upper left, 3 is lower right, 4 is lower left, and 5 is the bottom.
The last three digits indicate which hexagon on that side to have the entrance
in. Hexagons are counted from top to bottom for all but sides 0 and 5, and from
left to right for sides 0 and 5. The 10000’s place indicates which outer wall
segment in that hexagon to have the entrance in, ranging from 0 to 1. Again it’s
the upper or leftmost wall segment that’s considered segment 0.</p>

<p class=C>For Delta Mazes, the 1000’s place indicates which of the three sides
to have the entrance on, ranging from 0 to 2. Side 0 is the upper left, 1 is
the upper right, and 2 is the bottom. The last three digits indicate which wall
segment on that side to have the entrance in. This is counted from top to
bottom for sides 0 and 1, and from left to right for side 2.</p>

<p class=C>For Upsilon Mazes, the 1000’s place indicates which of the four
sides to have the entrance on, ranging from 0 to 3. Side 0 is the top, 1 is the
left, 2 is bottom, and 3 is right. The last three digits indicate which wall
segment on that side to have the entrance in. This is counted from top to
bottom for sides 0 and 2, and from left to right for sides 1 and 3.</p>

<p class=B><span class=O>Omega Finish Location:</span> This indicates the location
to use for the exit in Omega style Mazes. The values here are treated the same
as in Start Location. The only difference is for Theta Mazes the finish will be
on the outer ring of the Maze instead of the inner.</p>

<p class=B><span class=O>Omega Wireframe:</span> This radio button group allows
creating Omega Mazes to also automatically generate Daedalus wireframe and
patch scenes of that Maze. When set to Screen Only, Omega Mazes will only be
drawn in the main bitmap. If set to Make Wireframe Also, creating the Maze (in
addition to drawing in the bitmap) will also generate a Daedalus wireframe
scene, which can be rendered, saved as a Windows metafile, and so on using
commands on the Draw menu. If set to Make Patches Also, creating the Maze will
also generate a Daedalus patch scene, that can be rendered and such using
commands on the Draw menu.</p>

<p class=B><span class=O>Planair:</span> The string here controls the
arrangement of Planair Mazes, and indicates both how many sections there are in
it, and how the sections connect with each other, i.e. where you end up when you
move off each of the four edges of each section. The string here must consist
of groups of eight characters separated by spaces. The number of groups
indicates the number of sections in the Maze. Each group of eight characters
has two characters for each of the four edges of that section. The edges are in
the order: top, left, bottom, and right. The two characters indicate the
section and edge within that section you go to when moving off that edge. The
first character is a lower case letter, where “a” is the first section in the
string, “b” the second section, and so on. The second character is a number
from 0 to 7. The numbers 0 to 3 mean the top, left, bottom, and right edges in
that order. The numbers 4 to 7 also mean those edges, but you go to the passages
on that edge in reverse order (i.e. from right to left, or from bottom to top,
instead of the other way around). Planair Mazes get the size of each of their
sections from the same 3D bitmap dimensions fields 3D Mazes themselves use.
Since Planair Maze sections can be rectangular, an error will be displayed if
you try to link up an edge with an edge of a different length. A warning will
be displayed if you define or create a Planair Maze with a one way edge link, in
which a passage is set to flow from edge #1 to edge #2, but flowing back from
edge #2 doesn’t return to the same spot on edge #1.</p>

<p class=C>For example, to have a Maze on the surface of a torus where the left
and right edges wrap, along with the top and bottom, enter “a2a3a0a1” (this is
the default text in the Planair field). To have a Maze on the surface of a
cube, to specify the six sides enter “e2d3f0b1 e7a3f3c1 e4b3f6d1 e1c3f5a1
c4d0a0b4 a2d6c6b2”. To have a Maze on the surface of a Moebius strip, enter “a0a3a2a1”.
To have an edge be a true edge instead of connecting with some section when you
move off it, have that edge link up with itself. A normal Maze without any
special links is the string “a0a1a2a3”.</p>

<p class=B><span class=O>Segment:</span> The input here indicates what textures
to use and where they should be, when creating a segmented Maze with varying
textures with the Segment command. This should be entered as a list of numbers,
specifically a series of groups of nine numbers each, with a final terminating
zero after the last group.</p>

<p class=C>The first number indicates what type of texture to use. The number 1
means to affect the “river” factor of the passages in the Maze, the number 2
means to affect the horizontal or vertical bias of the passages, and the number
3 means to affect the random “run” factor of passages.</p>

<p class=C>The next four numbers indicate the rectangle to apply that texture
to, specified as the horizontal and vertical pixel coordinates of the upper
left and lower right corners of that rectangle. If any rectangles overlap that
have the same texture type, the earlier group has precedence.</p>

<p class=C>The final four numbers indicate how to apply the given texture
within the rectangle. Each number indicates how to apply the texture at one of
the corners of the rectangle, where the first number is the upper left corner,
the second is the upper right, third is lower left, and fourth is lower right.
If all four numbers are the same, that means to apply the texture evenly
throughout the rectangle, while if any are different, the amount of texture
will gradually change or fade from corner to corner. For texture type 1, a
number means the percentage of “river” to have, where 0 means minimum river and
100 means maximum. For texture type 2, a number means the random bias to have,
which is interpreted in the same way as the Random Bias field in the Random
Settings dialog. For texture type 3, a number means the random “run” factor to
have, which is interpreted in the same way as the Random Run field in Random
Settings.</p>

<p class=C>The default segmented Maze in the Segment List field should be
created within a 256x192 pixel bitmap. The top half of the Maze has a 0% river
factor, while the bottom half of the Maze has a 100% river factor. The left
half of the Maze has a vertical bias, while the right half of the Maze has a
horizontal bias. Finally the middle quadrant has a high random run factor.
After running the Segment command you should be able to see different textures
in each of the four quadrants, and a different texture overlapping in the
middle, for eight different types total.</p>

<p class=B><span class=O>Create with Wall Adding:</span> This controls whether
the Growing Tree command creates the Maze by carving passages or adding walls.
This also affects the Perfect, Prim’s, Kruskal’s, Aldous-Broder, Wilson’s,
Eller’s, and Cavern Maze creation commands.</p>

<p class=C>Wall added Perfect Mazes are made by adding onto the most recently
created wall whenever possible, and usually only creating other walls when
forced to. The Maze here will have a lower “river” factor than when Create With
Wall Adding is off. Wall added Prim’s Algorithm Mazes have walls grow inward from
the boundary wall, instead of having passages grow outward from some point in
the middle. Wall added Kruskal’s Algorithm Mazes add wall segments instead of
passages throughout the Maze at random. Wall added Aldous-Broder and Wilson’s
Algorithm Mazes also have walls grow inward from the boundary wall, where they
not only still have the property where all possible Mazes are created with
equal probability, but wall added versions are generated nearly twice as fast
too.</p>

<p class=B><span class=O>Tree Value Is Random Chance:</span> This controls how
the Growing Tree algorithm determines what section to add onto next. When this
is clear, the algorithm will randomly pick one of the most recently created
sections to add onto. This will tend to make the Maze have a long and windy
solution. When set, the algorithm will always add onto the most recently
created section, however sometimes it will choose a completely random section.
This will tend to make the Maze have a short direct solution.</p>

<p class=B><span class=O>Tree</span><span class=O> &quot;River&quot;</span><span class=O> Value:</span> When Value Is Random Chance is off, this checkbox
sets how many of the most recently created sections to choose among. The higher
the value, the less windy the solution. The Maze will tend to have many dead
ends, unless the value is zero in which case it will have few dead ends. When
Value is Random Chance is on, this set how often the algorithm will pick a
completely random section. The higher the value, the more windy the solution.
The Maze will tend to have few dead ends, unless the value is very low in which
case it will have many dead ends.</p>

<p class=C>If Create With Wall Adding and Value Is Random Chance are off, and
River Value is zero, the Growing Tree algorithm will exactly emulate the
Recursive Backtrack algorithm, with a windy solution and few but long dead
ends. If Create With Wall Adding is off, Value is Random Chance is on, and
River Value is zero or a very low number, the Growing Tree algorithm will
behave similarly but not exactly to Prim’s Algorithm, with a short direct
solution and many but short dead ends. If Value Is Random Chance is off, and
River Value is a low number greater than zero, the Maze will have a windy
solution, and also many but short dead ends. If Value Is Random Chance is on,
and River Value is a low number not too close to zero, the Maze will have a
short direct solution, and also few but long dead ends.</p>

<p class=C>Note if Value Is Random Chance is off, River Value may be negative,
in which case it means how many of the earliest created sections to choose
among instead. This will give the Maze a unique look, with about as many dead ends
as it’s physically possible to have in a Maze, even more than Prim’s Algorithm,
where there will be many “pipe cleaner” passages, with many one unit dead ends
hanging off the main passages like short hairs.</p>

<p class=B><span class=O>Max Spirals:</span> This sets the maximum number of
spirals that can be drawn at once during creation of a Spiral Maze. Larger
numbers make the Maze have many smaller spirals, while smaller numbers make the
Maze have fewer larger spirals.</p>

<p class=B><span class=O>Max Spiral Walls:</span> This sets the maximum number
of walls that can be drawn at once around each spiral in a Spiral Maze. Larger
numbers make spirals have many passages that rapidly spiral away from the
center, while smaller numbers make spirals have fewer passages that go around
the center more times.</p>

<p class=B><span class=O>Spiral Random Addition:</span> This affects both
Spiral and Diagonal Mazes, and changes the number of random walls and passages
to add during their creation. Both these Mazes draw a base design, then do what
amounts to running the Add Passage or Add Wall command a number of times, where
the number of times this is done can be modified by this field. A high number
will make the Maze more random and look less like its base design, while a high
negative number will make the Maze be nothing but its base design with longer
passages and dead ends.</p>

<p class=B><span class=O>Fractal X &amp; Y:</span> These fields determine the
size of a fractal Maze. They are the number of horizontal and vertical passages
of the Maze at each nesting level.</p>

<p class=B><span class=O>Fractal Nesting Level:</span> This determines how many
levels of nesting there are within a fractal Maze, or how many times a new X by
Y Maze should be nested within each cell of the Maze while creating it. The
total size of a fractal Maze is determined by this nesting level and the X and
Y fields. For example, if X is 5, Y is 4, and the nesting level is 3, then the
complete Maze is 5^3 by 4^3 or 125 by 64 passages. In other words it’s a 5x4
Maze, with each cell containing another 5x4 Maze, with each cell of that
containing a third 5x4 Maze.</p>

<p class=B><span class=O>Allow Isolations in Fractal:</span> This affects Mazes
created with the Recursive Fractal command. When this is set, creation won’t
insist that every part of the Maze be reachable from the start. Creation will still
always ensure there exists at least one solution, and normally ensures every
passage is reachable on some level, i.e. that there are no isolated
inaccessible passages.</p>

<p class=B><span class=O>Crack Lines May Head Off:</span> This affects Mazes
created with the Crack command. When unset, random lines will always be drawn
with both the starting and ending points within the bitmap. This means lines
near the corners of the Maze will tend to point toward the center, since the
endpoint of a line that starts in a corner has to be still on the bitmap and so
is likely in the direction of the center. When set, the desired ending point
may be off the edge of the bitmap, which means the texture of the corner areas
is the same as everywhere else.</p>

<p class=B><span class=O>Crack Line Length:</span> This value sets the maximum
length lines in a Crack Maze can have. No line will ever be longer than half
the size of the bitmap. Note smaller values require a larger value for the
Crack Pass Limit field to ensure all parts of the Maze get filled out and
prevent an open space in the center.</p>

<p class=B><span class=O>Crack</span><span class=O> Pass</span><span class=O>
Limit:</span> This value indicates how long Crack Mazes will draw lines before
stopping. Larger values mean fewer open spaces within the Maze, however the
Maze will take longer to make.</p>

<p class=B><span class=O>Crack Line Sectors:</span> This value will modify
Crack Mazes so that all random lines are restricted to certain angles. A value
of 1 forces all lines to be in the horizontal plane, a value of 2 forces all
lines to be horizontal or vertical, 3 forces all lines to be in a triangular
grid, and so on. Negative numbers rotate the angles by half a sector, e.g. a
value of 1 forces all lines to be in the vertical plane, 2 forces all lines to be
diagonal, and so on. The default value of zero allows all angles.</p>

<p class=B><span class=M>Braid Creation Method:</span> This radio button group
determines how Mazes without dead ends are created when the Braid command is
run.</p>

<p class=C><span class=O>Wall Added:</span> Braid Mazes will be created with a
simple wall adding algorithm, in which wall segments will be added to as many
places as possible, unless doing so would produce a dead end or inaccessible
location.</p>

<p class=C><span class=O>Eller’s Algorithm Variation:</span> Braid Mazes will
be created with a variation of Eller’s algorithm. This alternate braid Maze
algorithm, when compared to the standard wall added algorithm, will result in
braid Mazes with a slightly higher loops density, will have a slight diagonal
bias from upper left to lower right in the solution path, and will occasionally
generate wall poles in the upper corners, however it’s also six times faster.</p>

<p class=C><span class=O>Tilt Template:</span> Braid Mazes will be created
using a template similar to the pattern produced by the Tilt command. In other
words, every other wall pole will be the center of a two segment vertical or
horizontal wall, which produces a bunch of unicursal passages which either
start and end on the edges or are isolated passage loops within the Maze. The
result will then be enclosed by the boundary wall and have the Crack Isolation
command internally run, to create a valid braid Maze. If Tilt Lines Make No
Diamonds in Create Settings is on, then (like the Tilt command) the Maze will
have no wall poles.This alternative braid Maze algorithm, when compared to the
standard algorithm, will tend to result in more difficult braid Mazes with
fewer solutions, yet with a more convoluted solution path.</p>

<p class=B><span class=O>Cavern Sparseness:</span> This setting allows Mazes
created with the Cavern command to be sparse, where the algorithm won’t fill in
all available space with passages or walls. The value determines the minimum
interior wall thickness in pixels for passage carved caverns, or the minimum
interior passage thickness for wall added caverns. For wall added sparse caverns,
the entrance and exit passages will have the same minimum passage width as the
interior passages.</p>

<p class=B><span class=O>Kruskal Based on Picture:</span> This flag affects
Mazes created with the Kruskal’s Algorithm and Kruskal Passages commands. When
set, the wall and passage layout within the created Maze will resemble an image
in a color bitmap, assuming that bitmap exists. The Kruskal’s Algorithm command
will make the Maze resemble the main color bitmap, and the Kruskal Passages
command will resemble the temporary color bitmap (because the main color bitmap
has a different effect on the Kruskal Passages command when present). Passages
will be biased to appear more often in areas of high contrast in the picture,
or in other words the more distinct the edge, the more likely a passage will be
present at the same pixel in the Maze. Specifically this causes Kruskal’s
algorithm to attempt to carve walls in order of contrast between the colors of
the adjacent cells. This will cause certain passages and walls to always be
present, where only areas of equal contrast will be randomized.</p>

<p class=B><span class=O>Weave Crossings May Corner:</span> When this is set,
Weave Mazes can have corners at points where passages overlap. Normally there
will only be straightaways at overlap points, where when a passage goes over or
under another, it will keep going straight as opposed to making a turn there.</p>

<p class=B><span class=O>Tilt Lines Make No Diamonds:</span> This affects the
Maze designs created with the Tilt command. When this is set, there will never
be any “diamonds” or places where 2x2 groups of diagonal lines fit together to
make a diamond shaped space. When unset, these diamonds are allowed to appear
in the designs.</p>

<p class=B><span class=O>Tilt Cell Size:</span> This affects the size in pixels
of each cell of tilt Mazes created with the Tilt command. If this value is
positive, then every cell will have its own separate grid of pixels. If this
value is negative, then there will be boundary rows and columns of pixels that
contain shared vertexes between cells. This should be at least 3 for the
passages to be apparent and wide enough to be followed.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menusolve>DAEDALUS MENU COMMANDS - SOLVE MENU</a></p>

</div>

<p class=A><span class=M>Solve Menu:</span> This contains all the ways of
completely or partially solving different types of Mazes. Most of these
commands edit the monochrome bitmap, and replace the Maze with a solved version
of it, where false passages get filled in. If however the color bitmap is
active, most commands on this menu will put the solution in the color bitmap,
leaving the original Maze alone in the monochrome bitmap. False or highlighted
paths will be filled in with the Dot color from the Set Colors dialog, and any
walls that get highlighted will be marked with the Overlay color.</p>

<p class=A><span class=N>Fill Dead Ends:</span> This fills in all dead ends,
including any passages that become dead ends once other dead ends are filled.
This will completely solve and show the one unique solution for perfect Mazes,
however the more passage loops in the Maze, the less this will do, where this
won’t do anything at all to completely braid Mazes that don’t have dead ends.
If Bitmap Is 3D is set, this will fill in the dead ends of a 3D Maze as
generated with the the Create 3D command, where the dimensions of the 3D Maze
are taken from the Size or Maze Size dialogs.</p>

<p class=A><span class=N>Fill Cul-De-Sacs:</span> This fills in all cul-de-sacs
or noose shaped passages, i.e. constructs in the Maze consisting of a blind
alley stem that has a single loop at the end with no other junctions along that
loop. This will also fill in areas that become cul-de-sacs after other
cul-de-sacs are filled. This is implemented by adding wall segments turning
cul-de-sacs into long dead ends, and then filling in the dead ends. This doesn’t
do much in heavily braid Mazes with lots of passage loops, but will be able to
invalidate more than just Fill Dead Ends.</p>

<p class=A><span class=N>Fill Blind Alleys:</span> This finds all possible
solutions, regardless of how long or short they may be. This does do by filling
in all blind alleys, where a blind alley is a passage where if you walk down it
in one direction, you have to backtrack through that passage in the opposite
direction in order to reach the exit. All dead ends are blind alleys, as are
all cul-de-sacs described above, as is any sized section of passages connected
to the rest of the Maze by only a single stem. This command is unfortunately
rather slow. This will basically invalidate everything Fill Cul-De-Sacs will
and then some, however Fill Collisions will invalidate everything this command
will and then some.</p>

<p class=A><span class=N>Fill Collisions:</span> This finds all shortest
solutions, only showing multiple solutions if there are more than one of the
same length. This is implemented by internally “flooding” the Maze with “water”,
such that equal distances from the start are touched at the same time, where
whenever two “columns of water” come down a passage from opposite sides
(indicating a loop) a wall segment is added where they collide. Once all
reachable parts of the Maze have been flooded, all the dead ends are filled
(which can’t be on a shortest path), and the process is repeated until no more
collisions happen. The starting point for “flooding” is the dot, and if the dot
is not an off pixel on the bitmap it’s first available entrance in the top row.</p>

<p class=A><span class=N>Find a Path:</span> This finds one particular
solution, which likely won’t be the shortest solution if the Maze has more then
one. This is different from the commands above because it will work on any
Maze, and doesn’t require there to be any one pixel wide passages to
invalidate. When the command is done, the bitmap will be erased and the
solution path will be shown as a trail of off pixels. If the No Corner Hopping
checkbox in the Dot Settings dialog is off, that means the solution path may
move diagonally, which for example can be used to find the solution to Zeta
Mazes with their one pixel wide diagonal passages. It’s interesting to note
this uses a recursive backtracking algorithm similar to the method used to
create Mazes in the Recursive Backtrack command. This command needs to know
what to consider the start and end of the Maze, where there are a few
possibilities:</p>

<p class=B>If the dot is over an on pixel, the start will be considered the
first off pixel in the top row, and the end will be the bottom edge of the
bitmap. This allows solving Mazes that have the entrance at the top and the
exit at the bottom, as most of the Mazes generated on the Create menu do. This
is the default behavior, since the dot starts out in the upper left corner and
is there unless you’ve moved it, and the upper left corner is usually an on
pixel after creating a Maze.</p>

<p class=B>If the dot is over an off pixel, the start will be considered the
location of the dot, and the end will be any edge of the bitmap. This allows
solving Mazes that either start or end somewhere in the middle of the bitmap.</p>

<p class=B>Either way, if the second dot is over an off pixel, and is anywhere
other than in the upper left corner, then the location of the second Dot will
be considered an end too. This allows solving Mazes that both start and end in
the middle of the bitmap. This is not default behavior, since the second dot is
in the upper left corner unless you’ve moved it, and the upper left corner is
usually an on pixel too.</p>

<p class=B>If the Solve Fillers Consider Dots As Exits checkbox in the Maze
Settings dialog is on, and both the dot and 2nd dot are within the Maze and
over off pixels, then a solution will be found connecting the dots only, and
the edge of the bitmap will be ignored.</p>

<p class=A><span class=N>Find Shortest Path:</span> This finds a shortest
solution, picking one if there are multiple shortest solutions. This behaves
like Find A Path in every way, just that it uses a different algorithm to find
the solution. Normally this solver always picks the same shortest path when
there’s more than one, however if the Find A Path Finds Random Path checkbox in
the Maze Settings dialog is on, this will pick a random shortest path.</p>

<p class=A><span class=N>Find Shortest Paths:</span> This finds all shortest
solutions. This does exactly the same thing as Find Shortest Path, except it
will show all shortest solution paths if there’s more than one.</p>

<p class=A><span class=M>Wall Following:</span> This submenu contains ways to
solve Mazes that involve following a wall.</p>

<p class=B><span class=N>Follow Wall Left:</span> This tries to solve the Maze
by following a wall. The computer will follow passages and always take the
leftmost choice at junctions, which is equivalent to a person solving a Maze by
putting their hand on the left wall and leaving it there as they walk through.
This probably won’t find the shortest solution if the Maze has more than one,
and it won’t find a solution at all if the goal is in the center of the Maze
and there’s a passage loop surrounding it, because wall following will make you
go around the center and eventually find yourself back at the start. This is
similar to Find A Path in that it will work on any Maze and doesn’t require
there to be one pixel wide passages to follow. When the command is done, the
bitmap will be erased and all passages that wall following went through will be
shown as trails of off pixels. Wall following will start from the location and
current direction of the dot if it’s over an off pixel, otherwise it will start
from the first off pixel in the top row. Wall following will end at the
following places: (1) Upon reaching any edge of the bitmap, meaning wall
following found an exit, (2) upon returning to the start point, meaning wall
following failed to find a solution, or (3) upon reaching the location of the
second dot, assuming the second dot is over an off pixel, and is anywhere other
than in the upper left corner.</p>

<p class=B><span class=N>Follow Wall Right:</span> This is exactly like Follow
Wall Left in every way, just that it follows the right hand wall instead of the
left. Note a wall following command will show more than just the solution path,
in that it will also show all the blind alleys it went down while following the
wall on that side. To show only the actual solution path, run also the opposite
wall following command, which will go down just the solution path and discard
the extra blind alleys. For example, to show the rightmost solution path, do
Follow Wall Right and then do Follow Wall Left.</p>

<p class=B><span class=N>Pledge Algorithm Left:</span> This tries to solve a
Maze using the Pledge algorithm. Pledge algorithm is similar to wall following,
hence it has a version that follows the left wall and another following the
right. Solving works by always moving in the direction specified by the
Direction field in Dot Settings when possible, and wall following when not.
Moving in the direction allows jumping between islands, so this can solve Mazes
wall following can’t. Pledge algorithm is guaranteed to find a way to an exit
on the outer edge of any Maze from any point in the middle, however it can’t do
the reverse, namely find an arbitrary solution point within the Maze. The Maze
is unsolvable if the turn total keeps increasing, meaning the solver is caught
going around inside an inaccessible area. The Pass Limit field in Create
Settings specifies how high the turn total can get before giving up.</p>

<p class=B><span class=N>Pledge Algorithm Right:</span> This is exactly like
Pledge Algorithm Left in every way, just it uses right hand wall following
instead of left.</p>

<p class=B><span class=N>Chain Algorithm:</span> This will solve Mazes using
the chain algorithm, which is similar to wall following, but is able to jump
between islands. Solving proceeds from the dot to 2nd dot, or the first
available passage on the top and/or bottom rows if the dots aren’t positioned
over valid passages. The solving path moves along an invisible straight line
between the start and end points. If that line bumps into a Maze wall, then
wall following robots proceed in both directions until one reaches the
invisible line again.</p>

<p class=A><span class=M>3D:</span> This submenu contains ways to solve various
types of special Mazes which don’t fit on a flat 2D plane.</p>

<p class=B><span class=N>Fill Weave Dead Ends:</span> This is like Fill Dead
Ends, but works on Weave Mazes created with the Weave command on the Create
menu.</p>

<p class=B><span class=N>Fill 4D Dead Ends:</span> This is like Fill Dead Ends,
but works on 4D Mazes generated with the 4D command on the Create menu. The
dimensions of the 4D Maze are taken from the Size or Maze Size dialogs.</p>

<p class=B><span class=N>Fill Hyper Dead Ends:</span> This solves a Hypermaze
created with the Hyper command on the Create menu, and is similar to Fill Dead
Ends in that it fills in pixels that aren’t on the solution. This leaves behind
a narrow one pixel wide crack splitting the 3D object which marks out the
solution surface.</p>

<p class=B><span class=N>Find Recursive Fractal:</span> This solves an infinite
recursive fractal Maze in the main bitmap that was created with the Recursive
Fractal command. It is assumed the Nesting Level field in Create Settings is
set to the number of chips in the Maze, where the X and Y fractal fields define
the number of pins across and down each chip. When run, a message box will
display the shortest move solution. Press Cancel to stop, or press OK to
display the next shortest solution. By default Daedalus will search for all
solutions up to a chip depth of 10, and up to 50 moves.</p>

<p class=C>The solution is displayed as a sequence of moves. Each move consists
of a start location and an end location. Each location is either the start “---”,
end “+++”, or a pin on a chip. Chips are indicated by their number, or nothing
for the outer edge of the current chip. Pins are indicated by the direction of
the edge (NWSE) followed by the numeric position of the pin along that edge,
increasing from 1 from left to right, or top to bottom. For example, “1S10”
means the 10th pin from the left on the bottom of chip #1, and “W1” means the
topmost left pin on the outer rim.</p>

<p class=A><span class=N>Tremaux's Algorithm:</span> This solves a Maze using
Trémaux’s algorithm. This method works for all Mazes (even Mazes with loops)
and can be implemented by a person inside of a Maze. Unlike most solving
commands, this never changes the Maze in the main bitmap, but rather draws the
solution in the color bitmap. Markings in the Dot color indicate the solution
path, i.e. where a passage was navigated and marked once. Markings in the
Overlay color indicate false paths that were visited, i.e. where a passage was
navigated and marked twice.</p>

<p class=B>If the Solve Fillers Check Every Pixel flag in the Maze Settings
dialog is set, the command won’t assume the Maze is on a grid with passages
always on odd pixels. Rather it will consider every pixel as a possible
passage. Since Trémaux’s algorithm works by considering markings between cells,
this case necessitates drawing the solution in a zoomed version of the Maze
bitmap. If the Find A Path Finds Random Path flag in Maze Settings is set,
solving won’t always choose paths in the same order.</p>

<p class=A><span class=N>Mark Dead Ends:</span> This is like Fill Dead Ends,
however it will only partially fill in each dead end, where each dead end will
have its last cell or two filled. This can be run multiple times to remove more
and more of the dead ends from the Maze. This allows Mazes to be made easier a
step at a time instead of solving it all at once. This also allows seeing the
layout of the main passages in a Maze and what areas are reachable from others,
once the minor “leaf” like dead ends are no longer cluttering the Maze and only
the main “branch” passages are left.</p>

<p class=A><span class=N>Mark Cul-De-Sacs:</span> This is similar to Fill
Cul-De-Sacs, however instead of filling in all cul-de-sac passages, it will
instead just convert each cul-de-sac into a long dead end by adding a wall
segment at an appropriate point. For example running this on a Maze created
with the Braid command will add some dead ends to the Maze resulting in a
partially braid Maze with both loops and dead ends.</p>

<p class=A><span class=N>Mark Blind Alleys:</span> This is similar to Fill
Blind Alleys, however this only seals off and fills in the blind alley passages
themselves, as opposed to also the section of passages that may be behind the
stem. This runs much faster than Fill Blind Alleys, however it will create
inaccessible sections out of cul-de-sacs and other blind alleys that are more
than just dead ends.</p>

<p class=A><span class=N>Mark Collisions:</span> This is similar to Fill Collisions,
however instead of filling in all passages not on a solution path, it will
instead just add wall segments where the “collisions” happen, removing most of
the passage loops from the Maze.</p>

<p class=A><span class=N>Fill Single Dead Ends:</span> This is like Fill Dead
Ends, in that it fills in all dead ends, however it won’t fill in passages that
become dead ends once other dead ends are filled. As with Mark Dead Ends, this
can be run multiple times to remove more and more of the dead ends from the
Maze.</p>

<p class=A><span class=N>Show Bottlenecks:</span> This will show all
bottlenecks in the Maze, by filling in all passages that aren’t bottlenecks. A
bottleneck is a passage or intersection such that every solution to the Maze
goes through it.</p>

<p class=A><span class=N>Flood Passages:</span> This will flood the bitmap
starting from the bottom right corner. Since that’s usually an off pixel, this
is basically flooding the passages. This basically does the same as the Fill At
Dot command if the dot is in the bottom right corner. A simple yet useful way
to get information about a Maze is to flood it, because it will touch all areas
and only those areas reachable from the start point. Any parts not flooded
indicate areas inaccessible from the start. If you flood the passage at the
start, and the end isn’t filled, the Maze has no solution.</p>

<p class=A><span class=N>Flood Walls Left:</span> This will flood the bitmap
starting from the top left corner. Since that’s usually an on pixel, this is
basically “flooding” along the tops of the walls, and will be like if you were
to lift up the wall at that point and carry away whatever parts of the Maze
connect with it. For Mazes with an entrance and exit on the edges, when one of
the halves is removed, the remaining half marks out a solution. For Mazes with
the start or goal in the middle, when the outer wall is flooded, if the inner
wall around the exit isn’t also erased, then wall following won’t work to solve
it.</p>

<p class=A><span class=N>Flood Walls Right:</span> This is like Flood Walls
Left but will do it to the right half of the Maze. This will flood the bitmap
starting from the top right corner, or rather one pixel to the left from the
top right corner. Since that’s usually the top rightmost on pixel in a Maze,
this is basically “flooding” along the tops of the walls at that point.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=menudraw>DAEDALUS MENU COMMANDS - DRAW MENU</a></p>

</div>

<p class=A><span class=M>Draw Menu:</span> This contains advanced graphic
commands which operate on the main bitmap or other data in memory and have as
their result another bitmap. This includes simple orthographic views of 2D and
3D bitmaps, along with general wireframe and polygon based true perspective
graphics scenes. These aren’t related to Mazes, but can be used to create nice
displays of Mazes or other things.</p>

<p class=A><span class=N>Draw Settings...:</span> This dialog contains size and
location settings used by many of the commands on the Draw menu. Most fields
are used in similar ways by multiple commands.</p>

<p class=B><span class=O>Horizontal Size &amp; Vertical Size &amp; Depth Size:</span>
These values affect all the commands on the Draw menu that deal with blocks in
any way. They indicate the pixel size of the blocks to be drawn in the Render
Bitmap Overview and Render Pyramid commands. They also indicate the draw unit
size of the blocks for the commands that make wireframe or patch scenes.</p>

<p class=B><span class=O>Horizontal Size Bias &amp; Vertical Size Bias:</span>
These values affect the Make Wireframe Bitmap Overview and Make Patch Bitmap
Overview commands. They are similar to fields in the Zoom Bias dialog, and
allow walls in scenes representing Mazes to be a different thickness than
passages. The numbers here will be used for the length of line segments
corresponding to even numbered rows and columns in the bitmap i.e. walls,
instead of the numbers in the Horizontal Size and Vertical Size fields. These
values should be the same as Horizontal and Vertical Size unless you do want
walls and passages to have different widths.</p>

<p class=B><span class=O>X Starting Location &amp; Y Starting Location &amp; Z
Starting Location:</span> These values affect the perspective rendering
commands. They indicate the coordinates in three dimensional space to view the
scene from. These values also affect the commands that make wireframes or
patches in memory, where the numbers here will be added to every coordinate
generated, allowing the entire scene to be offset by some amount.</p>

<p class=B><span class=O>Move with Arrow Keys:</span> This allows you to walk
around through the 3D perspective scenes created with Render Wireframe
Perspective and Render Patch Perspective. When set, this will make the dot
movement commands no longer affect the dot, but rather change the viewing
coordinates and viewing angle in Draw Settings. The perspective rendering
command executed most recently will also automatically be done to update the
display. The number of draw units to move and the number of degrees to rotate
at a time are taken from the Motion Velocity and Rotation Velocity fields. Here’s
what the dot movement commands (with their shortcut keys in parentheses) do in
this mode:</p>

<p class=C>Up (up arrow) will move forward in the direction you’re facing, Down
(down arrow) will back up, Left (left arrow) will rotate to the left, and Right
(right arrow) will rotate to the right. Raise (“u”) will levitate up, and Lower
(“d”) will sink down. Jump Left (Shift+left arrow) and Jump Right (Shift+right
arrow) will sidestep or strafe to the left or right. Jump Up (Shift+up arrow)
will pitch the view upward, and Jump Down (Shift+down arrow) will pitch the
view downward.</p>

<p class=B><span class=O>X Vanishing Point &amp; Y Vanishing Point:</span>
These values affect the Render Pyramid command. They indicate the pixel
coordinate where the vanishing point will be. This must be a legal coordinate
within the bounds of the bitmap Render Pyramid creates.</p>

<p class=B><span class=O>Viewing Angle Theta:</span> This affects the render
perspective commands. It indicates the angle to look at the scene from the
starting location coordinates. A value of 0 means to look along the increasing
Y axis, a value of 90 means to look along the increasing X axis, and so on
around the 360 degree circle.</p>

<p class=B><span class=O>Vertical Pitch Phi:</span> This affects the render
perspective commands. It indicates the amount to look up or down along the
viewing angle. A value of 0 means to look straight ahead, a value of 45 means
to look down at a 45 degree angle, and a negative number means to look up by
that many degrees. Note if this value exceeds 90 or -90, you’ll be upside down,
in which case the sky color will be drawn below the horizon line and the ground
color above it, instead of the reverse.</p>

<p class=B><span class=O>Motion Velocity:</span> This only plays a role when
Move With Arrow Keys is set. It indicates the number of draw units to move at a
time when a dot movement command is run. Note if the Move By Two dot editing
flag is on, movement will happen at twice the rate as is normal, allowing that
setting to act as a “run” or “turbo” mode.</p>

<p class=B><span class=O>Rotation Velocity:</span> This only plays a role when
Move With Arrow Keys is set. It indicates the number of degrees to turn at a
time when a dot rotation command is run. Note if the Drag By Two dot editing
flag is on, rotation in place will happen at twice the rate as is normal.</p>

<p class=B><span class=O>View from Right:</span> This affects the Render Bitmap
Overview command. When set the overview will appear to be seen from somewhat
right of center, where you can see down the right hand sides of the blocks.
When unset the overview will appear to be seen from left of center.</p>

<p class=B><span class=O>Merge Blocks Together:</span> This affects Render
Bitmap Overview, Render Pyramid, and the commands that make wireframes or
patches in memory. This makes adjacent individual blocks appear to be a single
large object. When set the edges between blocks won’t be indicated in an
overview on the screen, the blocks in Render Pyramid will appear solid, and
edges between blocks in the created wireframe or patch scene will not be shown
when that scene is rendered. When unset an overview will appear composed of
individual blocks placed next to each other, the blocks in Render Pyramid will
appear transparent, and all edges around blocks in a scene will be drawn when
that scene is rendered.</p>

<p class=A><span class=N>Obscure Draw Settings...:</span> This dialog contains
additional minor or less fundamental settings used by the perspective rendering
commands.</p>

<p class=B><span class=O>Reflect Coordinates:</span> When this is checked, the
entire scene will be inverted through the Y-axis before being rendered. The
range of Y coordinates covered won’t change, e.g. if coordinates range from Y=0
to y=100, the scene will be flipped across the plane Y=50. It’s recommended to
have this set for scenes created by the make wireframe and patch commands, to
prevent objects in the scene from being a mirror image of what you expect,
because the rendering assumes a right-handed coordinate system, while the
bitmaps are in a left-handed coordinate system with X increasing to the east, Y
increasing to the south, and Z increasing up.</p>

<p class=B><span class=O>Shade Sky:</span> This only plays a role in the
monochrome patch and wireframe renderings. When set, the “sky” area above the
horizon will be filled with the drawing color. You probably don’t want to use
this with Render Wireframe Perspective, because the lines it draws which are
done in the same drawing color won’t show up on it.</p>

<p class=B><span class=O>Shade Ground:</span> This only plays a role in the
monochrome patch and wireframe renderings. When set, the “ground” area below
the horizon will be half filled with the drawing color, creating a dithered
gray shade there. You probably don’t want to use this with Render Perspective
Wireframe, because the lines it draws which are done in the drawing color won’t
show up on it very well.</p>

<p class=B><span class=O>Draw Edges:</span> This only plays a role in the patch
renderings. When set, edges between polygons will be indicated with one pixel
wide line segments. When unset, you have to rely on patch shading, different
colors of patches, or different colors between patches and the background, to
see where the edges are.</p>

<p class=B><span class=O>Shade Objects:</span> This only plays a role in Render
Patch Perspective. When set, the polygons will be shaded based on the angle
between them and the light source. In the color scene generated when Show Color
Bitmap is on, the color of each polygon will be lightened the more it faces the
light source, and darkened the more it faces away from it. In the monochrome
scene generated when Show Color Bitmap is off, each polygon will be dithered
between the background color (when facing more toward the light source) and the
draw color (when facing away from the light source) to simulate shades of gray.</p>

<p class=B><span class=O>Do Touch Ups:</span> This only plays a role in the
patch renderings and when Draw Edges is set. Sometimes you may notice that not
all parts of all line segments show up. This happens because later drawn
polygons may partially overlap the edge’s pixels. When this is set, Daedalus
will spend a little extra time during the rendering to redraw some of the edges
that were covered in this way.</p>

<p class=B><span class=O>Border Width:</span> This is the pixel width of the
border that surrounds the rendered bitmap. This may be set to zero to not draw
a border.</p>

<p class=B><span class=O>Horizon Width:</span> This is the pixel width of the
horizon line that separates the sky from the ground. This may be set to zero to
not draw the horizon, say if you want to simulate being in space instead of on
the ground.</p>

<p class=B><span class=O>Distance Scale:</span> This affects the apparent
distance of objects in the scene with respect to how far away they are from the
viewing location. Increase this value to make objects appear closer and
decrease this to make them appear farther away.</p>

<p class=B><span class=O>X Scale &amp; Y Scale &amp; Z Scale:</span> These
values apply a scale factor to the objects in the scene. For example if you
double all the numbers here, everything will appear twice as big. You can also
apply different scales to each coordinate axis. For example if you cut just the
Z Scale value in half, everything will appear half as tall, while having the
same width.</p>

<p class=B><span class=O>Edge Color:</span> This only plays a role in Render
Wireframe Perspective and Render Patch Perspective when Show Color Bitmap is
on. It indicates the color to use for the wireframe itself, for edges around
polygons, and the color to use for the horizon line and border.</p>

<p class=B><span class=O>Sky Color (High) &amp; Sky Color (Low):</span> These
fields only play a role in Render Patch Perspective when Show Color Bitmap is
on. They indicate the color to use for the “sky” background area above the
horizon line. The colors in the scene will gradually fade from the Sky Color
(High) value at the top of the bitmap to the Sky Color (Low) value at the
horizon line.</p>

<p class=B><span class=O>Ground Color (High) &amp; Ground Color (Low):</span>
These fields only play a role in Render Patch Perspective when Show Color
Bitmap is on. They indicate the color to use for the “ground” background area
below the horizon line. The colors in the scene will gradually fade from the
Ground Color (High) value at the horizon line to the Ground Color (Low) value
at the bottom of the bitmap.</p>

<p class=B><span class=O>Object Color:</span> This only plays a role in Render
Patch Perspective when Show Color Bitmap is on. It indicates the default color
to use to use for polygons. This color will be used whenever patches don’t
already have a color specified for themselves in the patch file. Patch files
created by Daedalus with the Save Patches command sometimes don’t specify
colors so will use the color here when reloaded. The SOLIDS.DP sample patch
file does specify patch colors so will ignore the color here when rendered.</p>

<p class=B><span class=O>X Light Vector &amp; Y Light Vector &amp; Z Light
Vector:</span> These fields only play a role in Render Patch Perspective when
Shade Objects is set. They indicate the direction from which the light source
is coming, and control how the polygons are shaded.</p>

<p class=A><span class=N>Render Bitmap Overview:</span> This creates an
orthographic 3D overview of the main bitmap, which means a non-perspective view
composed of only orthogonal and 45 degree angle lines. The view will be looking
down on and looking across the bitmap with its bottom edge closest to you. Each
on pixel will become a block in the scene. In the Draw Settings dialog, the
Horizontal Size value will be the width of the block in pixels. The Vertical
Size value will be the depth of the block in pixels, i.e. the number of pixels
along the 45 degree angle line. It’s recommended to have this value be slightly
smaller than Horizontal Size to make each block seem to have a square top. The
Depth Size value will be the height of the block in pixels. The pixel size of
the rendered bitmap is determined by the dimensions of the main bitmap along
with the size values above. If View From Right in Draw Settings is checked, the
overview will be looking down on the bitmap from the right, i.e. the depth
lines will go up and to the right. When unchecked the overview will be looking
down from the left, i.e. the lines will go up and to the left. If Merge Blocks
Together in Draw Settings is checked, adjacent blocks will have the edges
between them removed so they look like one object. When unchecked each block
will appear individually with the edges between them apparent.</p>

<p class=B>If Bitmap Is 3D is set, this operates on the 3D bitmap within the
main bitmap, and creates an orthographic 3D overview of the 3D bitmap, i.e. a
non-perspective view composed of only orthogonal and 45 degree angle lines,
with the result looking like a stack of overview scenes created by the 2D
overview rendering above layered on top of each other. The view will be looking
down on and across the top of the 3D bitmap, where the top level of the 3D
bitmap becomes the face closest to you. In the Draw Settings dialog, the
Horizontal Size value will be the width of the block in pixels. The Vertical
Size value will be the height of the block in pixels, where it’s recommended to
have this value be the same as Horizontal Size to make each block seem to be a
cube. The Depth Size value will be the depth of the block in pixels, i.e. the
number of pixels along the 45 degree angle line. It’s recommended to have this
value be slightly smaller than Horizontal and Vertical Size to make each block
seem to be a cube.</p>

<p class=B>Overview rendering can be done in color for 2D and 3D bitmaps. If
the color bitmap is being shown when this command is run, the rendering will be
placed in the color bitmap. The old contents of the color bitmap will contain
the color to use for each block. For 3D overviews, if the color bitmap has
different 3D dimensions than the monochrome bitmap, then the colors for blocks
will instead be taken from the blend in the Replace Color dialog, which will be
applied from the top to bottom levels.</p>

<p class=B>For monochrome renderings, certain fields in the Obscure Draw
Settings dialog can cause sections of this display to be filled in i.e. set to
off pixels. If Shade Ground is checked, pixels surrounding the rendering will
be filled in. If Shade Objects is set, pixels on the front walls of drawn
blocks will be filled in. If Shade Sky is set, pixels on tops of blocks will be
filled in. For color renderings, if Shade Objects is set, the walls facing each
axis will be shaded based on the values in the X &amp; Y &amp; Z Light Vector
fields in Obscure Draw Settings. The numbers should range from -100 to 100,
where 0 is unchanged, negative numbers darken, and positive lighten.</p>

<p class=B>Note a command like this shouldn’t be run twice in a row, as the
second rendering will take the first rendering as input, which is probably not
what you want and will look like garbage. Since this replaces the contents of
the main or color bitmaps with the rendering, you should first copy the old
bitmap contents to the temporary or extra bitmaps, or to the clipboard or save
it to a file, and then copy it back if you want to run the command again (say
after adjusting things in Draw Settings).</p>

<p class=A><span class=N>Render Pyramid:</span> This creates a single point
perspective view of the main bitmap. In the image you’ll be directly facing the
bitmap with each on pixel being an infinitely long block, where all the blocks
meet in the distance at a single vanishing point. The name “pyramid” for this
view comes from that each block has a square base, and all the depth lines seem
to meet at a point, which is similar to a pyramid. In the Draw Settings dialog,
the Horizontal Size and Vertical Size values will be the width and height of
each block in pixels. The pixel size of the rendered bitmap is determined by
the dimensions of the main bitmap along with the size values above. The X
Vanishing Point and Y Vanishing Point values will be the pixel coordinate where
the vanishing point is, where this must lie within the bounds of the rendered
bitmap. If Merge Blocks Together in Draw Settings is checked the blocks will be
solid. When unchecked they will all be transparent where you can see every
edge. A cool example use of this command is to have letters spelling something
in the main bitmap, with the vanishing point above or below them, where you can
see a 3D version of the letters going off to infinity.</p>

<p class=B>The result will be a monochrome image placed in the main bitmap
(replacing the source bitmap) or a color image, based on which bitmap is active
when the command is run. For monochrome renderings, if Shade Ground in the
Obscure Draw Settings dialog is checked, pixels surrounding the rendering will
be filled in with off pixels. If Shade Objects is set, pixels on the front
walls of drawn blocks will be filled in with off pixels.</p>

<p class=B>For color renderings, the background will always be white, lines
will be in the Edge Color setting from the Obscure Draw Settings dialog, the
front face of blocks will be in the Object Color, and the sides of blocks will
be in Sky Color (High). If the Shade Objects flag in Obscure Draw Settings is
on, then the color of sides of blocks will be based on which way the side is
facing: The top side of blocks will be in Sky Color (High), the bottom side of
blocks will be in Sky Color (Low), the left side of blocks will be in Ground
Color (High), and the right side of blocks will be in Ground Color (Low).</p>

<p class=A><span class=N>Life Generate:</span> This treats the main bitmap as a
board of the game of “Life”, as invented by mathematician John Conway in 1970,
where on pixels are “live” cells and off pixels “dead” cells, and produces the
next generation. The rules for going to the next generation are: (1) Live cells
with one or fewer neighbors, or four or more neighbors, among the eight
adjacent cells die. (2) Dead cells with exactly three neighbors become live. If
Edge Behavior is set to Torus Wrapping, then the board is considered to wrap
around between left &amp; right and top &amp; bottom. If Edge Behavior is
anything else, then off the edge of the board is always considered dead cells.</p>

<p class=B>Life Generate will operate on the color bitmap when it’s active.
Color life is like monochrome life except each cell is displayed in a color of
the rainbow. When a new cell is born, its color is the midpoint among the
colors of its three parent cells. For example a red cell and two green cells
will produce a yellowish green cell. Note Color life makes use of the temporary
color bitmap to determine which cells are actually alive and what color they should
be, where if the temporary color bitmap doesn’t exist, each cell will be
initialized to a random color of the rainbow.</p>

<p class=B>Life Generate automatically increments the Current Generation field
in File Settings. If the Generation Cutoff field is non-zero, then once the
Current Generation value reaches or passes this number, Life Generate will do
nothing. This allows one to use Autorepeat to generate a specific number of
Life generations and to automatically stop once they’re completed.</p>

<p class=A><span class=N>Open Wireframe...:</span> This opens a Daedalus
wireframe file into memory. Such a file is basically just a list of coordinate
pairs in three dimensional space indicating line segments. Once in memory you
won’t be able to see or do anything with it until some of the other commands on
the Draw menu are run.</p>

<p class=A><span class=N>Save Wireframe...:</span> This saves the current
wireframe scene in memory to a file.</p>

<p class=A><span class=M>Wireframe File:</span> This submenu has commands to
load and save the wireframe scene.</p>

<p class=B><span class=N>Save Metafile...:</span> This saves the current
wireframe scene in memory to a Windows metafile. It’s a vector format that uses
lines instead of pixels. The Windows metafile format may be opened or pasted
into programs such as Microsoft Word, in order to produce printouts that aren’t
pixelated.</p>

<p class=B><span class=N>Copy Metafile:</span> This copies the current wireframe
scene in memory to the Windows clipboard in Windows metafile format.</p>

<p class=B><span class=N>Save Vector…:</span> This saves the current wireframe
scene in memory to the Scalable Vector Graphics (SVG) format. SVG files are an
XML based format that uses lines instead of pixels, and like HTML files they
can be displayed in Web browsers.</p>

<p class=A><span class=N>Make Wireframe Bitmap Overview:</span> This creates a
wireframe scene in memory. It will contain the contents of the main bitmap,
where each on pixel in the bitmap becomes a 3D block. The wireframe will contain
two planes of edges along the top and bottom faces, with vertical lines
connecting the corners between them, and look like the graphic created by
Render Bitmap Overview. In the Draw Settings dialog, the Horizontal Size and
Vertical Size values indicate the number of draw units wide or long each line
segment will be. The Depth Size value indicates the height of each block in
draw units. If Depth Size is 0, then the top and bottom planes will become one
and the vertical connecting lines will disappear, all line segments being
within a single plane. The Horizontal Size Bias and Vertical Size Bias values
are similar to fields in the Zoom Bias dialog, and allow walls in wireframes
representing Mazes to be a different thickness than passages. The numbers here
will be the length of line segments corresponding to even numbered rows and
columns in the bitmap. For example, if Horizontal Size is 10 and Horizontal
Size Bias is 5, then horizontal walls will be 5 units wide and passages 15
units. If these values are 0, then the front and back planes of walls will
become one and the connecting edges will disappear, since they have no
thickness. If Merge Blocks Together in Draw Settings is checked, adjacent
blocks will appear to be one solid structure. When unchecked the blocks will
remain separate where you can see the edges between them.</p>

<p class=B>If Bitmap Is 3D is set, this creates a wireframe file containing the
contents of the 3D bitmap within the main bitmap, where each on pixel becomes a
3D block. This will look like the graphic created by Render Bitmap Overview for
3D bitmaps. In the Draw Settings dialog, the Horizontal Size and Vertical Size
and Depth Size values will indicate the size of each block. If Merge Blocks
Together in Draw Settings is checked, adjoining blocks will appear to be one
solid structure. When unchecked the blocks will remain separate where you can
see the edges between them.</p>

<p class=B>If the color bitmap exists, this will also set colors to use for the
line segments, instead of letting all lines have their color defined by the
Object Color draw setting at render time. The color set for each line will be
taken from the color bitmap, specifically the color pixel adjacent to the line
that’s on in the monochrome bitmap.</p>

<p class=A><span class=N>Render Wireframe Perspective:</span> This draws a
perspective view of the wireframe file in memory within the current size of the
main bitmap. The bitmap will be erased with the wall color, and everything on
it will be drawn using the passage color. In the Draw Settings dialog, the
coordinates you’re viewing the scene from are specified in the X and Y and Z
Starting Location fields. The angle you’re facing is specified in the Viewing
Angle Theta field, and the amount you’re looking up or down is in the Vertical
Pitch Phi field. See the Move With Arrow Keys checkbox in Draw Settings for a
way to make the dot movement keys change the viewing location and viewing angle
here, allowing you to walk around through the 3D perspective scene.</p>

<p class=B>If Show Color Bitmap is set, this instead generates a color display
of the wireframe instead of just a black and white one, and draws a perspective
view of the wireframe in memory within the current size of the color bitmap.
All fields in the Draw Settings dialog that affect the monochrome rendering
affect this color rendering in exactly the same way. See the Obscure Draw
Settings dialog for various other settings that affect the way this color scene
is drawn.</p>

<p class=B>The Daedalus wireframe file format is plain text and easily
understandable, which means other programs can create wireframe files and have
Daedalus render them. Example wireframe scene animations created by the
astrology program Astrolog can be viewed at <a
href="https://www.youtube.com/watch?v=UdRaDGXBV-0">https://www.youtube.com/watch?v=UdRaDGXBV-0</a>
and <a href="https://www.youtube.com/watch?v=jFhwfM0FKCo">https://www.youtube.com/watch?v=jFhwfM0FKCo</a></p>

<p class=A><span class=N>Render Wireframe Aerial:</span> This simple command
draws a simplified non-perspective view of the wireframe in memory. It will be
as if you’re looking straight down on the scene from above. Draw coordinates
will map to pixels, where a line segment ten draw units long will be ten pixels
long. The bitmap will be resized to exactly fit the bounds of all the line
segments.</p>

<p class=A><span class=N>Open Patches...:</span> This opens a Daedalus patch
file into memory. Such a file is basically a list of coordinate triplets in
three dimensional space indicating triangular patches. For each triangle it’s
indicated what edges are true edges as opposed to just an invisible place where
it meets another triangle in the same plane, e.g. a square patch is created by
placing two triangle patches together. The file format also has the ability to
set or change the color to use for patches. Once in memory you won’t be able to
see or do anything with the loaded file until some of the other commands on the
Draw menu are run.</p>

<p class=A><span class=N>Save Patches...:</span> This saves the current patch
scene in memory to a file.</p>

<p class=A><span class=N>Make Patch Bitmap Overview:</span> This creates a new
patch scene in memory. It will contain the contents of the main bitmap, where
each on pixel in the bitmap becomes a 3D block. This will look exactly like the
result generated with Make Wireframe Bitmap Overview, except here the blocks
will have solid faces. In the Draw Settings dialog, the Horizontal, Vertical,
and Depth Size values, the Horizontal and Vertical Size Bias values, and the
Merge Blocks Together checkbox, mean the exact same thing here as they do in
Make Wireframe Bitmap Overview. Note all patches generated by this command
cover square or rectangle areas, even though patch scenes are allowed to
contain triangle patches too, as seen in the SOLIDS.DP sample file.</p>

<p class=B>If Bitmap Is 3D is set, this creates a patch file containing the
contents of the 3D bitmap within the main bitmap, where each on pixel becomes a
3D block. This will look exactly like the result generated by Make Wireframe
Bitmap Overview for 3D bitmaps, except here the blocks will have solid faces.
In the Draw Settings dialog, the Horizontal, Vertical, and Depth Size values,
and the Merge Blocks Together checkbox, mean the exact same thing here as they
do in Make Wireframe Bitmap Overview.</p>

<p class=B>If the color bitmap exists, this will also set colors to use for the
patches, instead of letting all patches have their color defined by the Object
Color draw setting at render time. The color set for each block will be taken
from the corresponding pixel in the color bitmap.</p>

<p class=A><span class=N>Render Patch Perspective:</span> This is just like
Render Wireframe Perspective except it operates on the patch file in memory
instead of the wireframe file. This draws a perspective view of the patch file
in memory within the current size of the main bitmap. In the Draw Settings
dialog, the X and Y and Z Starting Location fields, the Viewing Angle Theta and
Vertical Pitch Phi fields, and the Move With Arrow Keys checkbox, mean the exact
same thing here as they do in Render Wireframe Perspective. Because the main
bitmap is monochrome, the colors of patches are ignored here, where all patches
and the background are the wall color, and all edges and lines are the passage
color. See the Obscure Draw Settings dialog for various other settings that
affect the way this monochrome scene is drawn.</p>

<p class=B>If Show Color Bitmap is set, this instead generates a color display
of the patch file instead of just a black and white one, and draws a
perspective view of the patch file in memory within the current size of the
color bitmap. All fields in the Draw Settings dialog that affect the monochrome
rendering affect this color rendering in exactly the same way. See the Obscure
Draw Settings dialog for various other settings that affect the way this color
scene is drawn.</p>

<p class=A><span class=N>Convert Patches to Wireframe:</span> This simple
command converts a patch file in memory to a wireframe file in memory. The edge
of each polygon will become a line segment in the new wireframe. This isn’t
that useful because everything Daedalus can create a patch file for, it can
also directly create a wireframe for. This can however be used on external
patch files like the SOLIDS.DP sample file.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=other>OTHER FEATURES OF DAEDALUS</a></p>

</div>

<p class=A><span class=P>Mouse Clicks:</span> Clicking the left mouse button on
the window, when a bitmap is being displayed, will teleport the dot to the
location you click. Clicking the left mouse button on the window, when the 3D
first person inside view is being displayed, will do a movement command.
Specifically clicking in the top quadrant will move forward, clicking in the
bottom quadrant will move backward, clicking the left quadrant will rotate
left, and clicking the right quadrant will rotate right. Also for the inside
view of a 3D Maze, clicking in the upper 1/4 of the top quadrant will move up,
and clicking in the bottom 1/4 of the bottom quadrant will move down. Clicking
the right mouse button on the window at any time will toggle the Chase Mouse
Point setting.</p>

<p class=B><span class=P>Mouse drag:</span> When the Drag Move Dot setting is on,
you can use the mouse to draw on the screen in addition to just setting the
location of the dot when you click. Clicking and dragging the mouse will draw a
line under the pointer, using the Drag Is Erase color. Shift+clicking will draw
a line from the last location clicked to the current location. Control+clicking
will draw a box, and Control+shift+clicking will draw a filled in box.</p>

<p class=B><span class=P>Mouse clicks stay on grid:</span> When clicking the
mouse on the bitmap, if either the Move By Two or Drag By Two settings are on,
the coordinates of the pixel the dot is teleported to will have the same
oddness or evenness as the original coordinates. This helps when drawing the
outline of or solution to a Maze with the mouse, as it will ensure you stay
over the same type of pixel as you click around.</p>

<p class=A><span class=P>Scroll Bars:</span> The window scroll bars in Daedalus
work as one would expect. When a bitmap is being displayed, and it doesn’t fill
the entire window, the scroll bars will move the bitmap around within the
window. When the bitmap’s display is larger than the window, the scroll bars
will determine which part of the bitmap is shown.</p>

<p class=A><span class=P>Entering Colors:</span> In the Set Colors dialog, in
the Replace Color dialog, and in the Obscure Draw Settings dialog, specifying
colors may be done in several ways. You can select a color from the dropdown,
where the dropdown shows the 16 default Windows colors, or you can enter a
color manually. Daedalus recognizes the 16 strings in the dropdown, in addition
to “DkGray”, “Orange”, “Pink”, “Brown”, “Olive” (same as “Maize”), “Navy” (same
as “DkBlue”), “Violet” (same as “Purple”), “Teal” (same as “DkCyan”), “Grey”
(same as “Gray”), “Lime” (same as “Green”), “Fuchsia” (same as “Magenta”), and “Aqua”
(same as “Cyan”). The 28 colors mentioned above may also be entered as just the
numbers from 0 to 27 respectively. If you enter “???” Daedalus will translate
it into a random color of the rainbow, and if you enter “????” Daedalus will
translate it into a random color period. You can also enter a color as an RGB value, e.g. “rgb 50 100 150”, where the three numbers are the red intensity, green intensity,
and blue intensity, which can range from 0 to 255. Typing “grayn” followed by a
number will indicate a grayscale of that intensity. For example, “grayn 100” is
equivalent to “rgb 100 100 100”. Typing “hue” followed by a number from 0 to
360 will result in a color of the rainbow, where 0 is red, 120 is green, and so
on. This color can be modified by the pattern settings in the Replace Color
dialog. Finally, entering “dlg” for the color will invoke the Windows Color
picker dialog, where you can visually select among a palette of colors or
specify a color in terms of red/green/blue or hue/saturation/luminosity. When
you leave the Color dialog, its current color will be used for that field.</p>

<p class=B>You can also specify colors in terms of other colors. If you type “light”
followed by a color, the color used will be a lighter version of the color in
question, e.g. “light brown” for a tan color. If you type “dark” followed by a
color, the color used will be a darker version of the color. If you type “shade”
followed by a color and then a number from -100 to 100, the color will be
darkened (for negative numbers) or lightened (for positive numbers)
appropriately. The farther the shading number from 0, the darker or lighter the
color. If you type “blend” followed by two colors, the resulting color will be
half way between the two colors following, e.g. “blend red orange” for a hot
reddish orange color. Finally, colors can be specified using the Daedalus
scripting language syntax, in which the string typed will be parsed as an
expression.</p>

<p class=A><span class=P>Screen saver:</span> Daedalus can act as a Windows
screen saver. To use it as one, copy the DAEDALUS.EXE executable to
Daedalus.scr in your Windows system directory, which is usually
C:\WINDOWS\SYSTEM32 (or C:\WINDOWS\SYSTEM on old Win9x systems). The right
directory is one that has other .scr extension screen savers in it. Once
installed, in Windows select Start / Settings / Control Panel / Display /
Screen Saver, and pick “Daedalus” in the list. When Previewed or when started
as a screen saver, a first person animation of randomly roaming a Maze will be
shown by default.</p>

<p class=B>If the file “daedalus.ds” exists in the same directory as
Daedalus.scr, that script will be loaded on startup instead of the above
behavior. You can’t set an unlock password when Daedalus is running as a screen
saver, and the Settings button won’t do anything other than show the same
animation in a window. However the script file allows the behavior to be arbitrarily
customized. Daedalus knows to act as a screen saver when Windows invokes it with
specific command switches, and exit immediately when a key is pressed or the
mouse is moved. “DAEDALUS /s” (run screen saver) will run in full screen mode. “DAEDALUS
/c” and “DAEDALUS /a” (configure screen saver) will run in windowed mode. “DAEDALUS
/p” (preview screen saver) will do nothing. One can run DAEDALUS.EXE with these switches to test its screen saver functionality.</p>

<p class=B>If Daedalus is invoked as “DAEDALUS /w” it will run in windowless
mode. It won’t show its main window, but will instead run the script “daedalus.ds”
if present, then immediately exit. This allows Daedalus to be invoked from
batch files without a window getting in the way. More generally, if “daedalus.ds”
exists in the same directory as the Daedalus executable, it will be run as a
script on startup.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=example>DAEDALUS EXAMPLES</a></p>

</div>

<p class=A>Daedalus has many options, however how to use them to implement
specific scenarios related to Mazes may not be obvious. Below are steps to use
Daedalus to accomplish two common scenarios:</p>

<p class=Section2>********************  Custom Maze Creation  ********************</p>

<p class=A>Scenario goal: Create a Maze within a custom irregular shape:</p>

<p class=A>1: Get the bitmap containing the shape you want in Daedalus: Use a “File
/ Open” command or paste in a bitmap format from the clipboard. You can also
use Daedalus commands to draw the shape in the program itself. For example,
turn on “Dot / Drag Move Dot”, then click and drag the mouse to draw the
outline of your shape. After the bitmap is in the program, select “Color /
Bitmap / Put To Bitmap (Nearest)” to ensure the contents are in the main
monochrome bitmap if they aren’t already. (Daedalus Maze creation commands work
with monochrome bitmaps, because they need to know exactly what should be
considered a wall and what should be considered a passage.)</p>

<p class=A>2: Establish a solid area to make your Maze within: If the starting
picture has just a border, first fill in the interior of that shape, so
afterward passages can be carved within it. To do that, click the mouse
somewhere inside the shape, and select “Bitmap / Fill At Dot”. That should give
a white shape with a black background.</p>

<p class=A>3: Ensure white pixels form the shape or wall color, and black
pixels are the background or passage color (at least for now): If they’re
reversed, then select the command “Bitmap / All / Invert All” to swap them. (By
default Daedalus considers white or “on” to be wall, and black or “off” to be
passage.)</p>

<p class=A>4: Run “Maze / Expand Set”: That will zoom the bitmap, so that each
pixel in the old bitmap becomes a 3x3 block able to fit a passage within, and
so there are no stray pixels after the Maze is created.</p>

<p class=A>5: Create the Maze: Run “Create / Partial Create / Kruskal Passages”
and it will fill the shape with Maze passages (as opposed to creating a new
Maze from scratch that fills the entire bitmap replacing what’s already
present).</p>

<p class=A>6: Add an entrance and exit: You can do this in another program, in
Daedalus itself with direct pixel editing, or with the “Maze / Add / Add Entrance”
and “Add Exit” commands.</p>

<p class=A>7: Make other desired adjustments: Orthogonal Mazes in Daedalus are
initially made such that passages and walls are just one pixel. Hence you first
create a raw low level Maze with the plan you want, then zoom it and color it
and such to have the high level look you want. For example, select “Zoom Bias”
and ok the dialog to make passages thinner than walls (recommended), then
select “Invert All” again so walls are black and the passage background is
white (recommended for printing).</p>

<p class=A>8: Do things with the Maze: Save it using “Save Bitmap”, copy it to
the clipboard using “Edit / Copy”, print it using “Print”, and so on. You may
want to also save after step #6 if you want a raw Maze that Daedalus can work
with, such as solve, do a first person walk through, etc.</p>

<p class=Section2>********************  Custom Maze Solving  ********************</p>

<p class=A>Scenario goal: Solve a Maze with irregular passages from an external
source:</p>

<p class=A>1: Get the bitmap containing the Maze you want to solve in Daedalus:
Use a “File / Open” command or paste in a bitmap format from the clipboard. For
example, visit <a href="http://www.astrolog.org/labyrnth/art.htm">http://www.astrolog.org/labyrnth/art.htm</a>,
right click on any of the Maze pictures and select “Copy”, then “Edit / Paste”
in Daedalus. After the bitmap is in the program, select “Color / Bitmap / Put
To Bitmap (Nearest)” to ensure the contents are in the main monochrome bitmap
if they aren’t already. (Daedalus Maze solving commands operate on monochrome
bitmaps, because they need to know exactly what should be considered a wall and
what should be considered a passage.)</p>

<p class=A>2: Ensure white pixels form the Maze or wall color, and black pixels
are the background or passage color (at least for now): If they’re reversed,
then select the command “Bitmap / All / Invert All” to swap them. (By default
Daedalus considers white or “on” to be wall, and black or “off” to be passage.)</p>

<p class=A>3: Ensure the Maze has no shortcuts: The shortest path from the
start of a Maze to the end of the Maze, when both points are on the outside
border, likely just goes around the outside of the Maze instead of through it.
Running the command “Bitmap / Collapse To Set” will trim off any rows and
columns of space around the outside of the Maze, which likely seals off any way
from start to end around the outside. However, that may not be enough if there
are designs surrounding the Maze for the collapse command to catch on. In such
a case it will be necessary to manually remove the designs, or add walls
cutting off such shortcuts. For example, turn on “Dot / Drag Move Dot”, then
click and drag the mouse to draw walls from the boundary of the Maze to the
edge of the bitmap.</p>

<p class=A>4: Choose the start and end points: Click the mouse at the start
point, then select “Dot / 2nd Dot / Set To Dot”. Then click the mouse at the
end point. Also inside “Maze / Maze Settings”, turn on “Solve Fillers Consider
Dots As Exits”. (That setting ensures the solving actually finds a path between
the two dots, instead of just from one dot to the edge of the bitmap, which
escapes the Maze.)</p>

<p class=A>5: Solve the Maze: Turn on “Color / Show Color Bitmap”. Then select “Solve
/ Find Shortest Path”. The result will be the Maze in solved form, with the
passages, walls, and solution path in different colors.</p>

<p class=A>6: Make desired adjustments: For example, select “Color / Replace
Color” and exchange Black with Red (turn on “Swap Instead Of Replace” in the
dialog). Select it again and exchange Black with White. That will have walls be
black, the passage background be white, and the solution path red (which looks
good when printing).</p>

<p class=A>7: Do things with the solution: Save it using “Save Bitmap”, copy it
to the clipboard using “Edit / Copy”, print it using “Print”, and so on.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=file>DAEDALUS FILES</a></p>

</div>

<p class=A><span class=P>DAE34ZIP.EXE:</span> This is the installation file for
Daedalus 3.4. To install, just download this program and run it. Inside are all
the files below, which will be extracted from this archive file and copied into
a directory or folder you specify, or C:\DAEDALUS by default. After unpacking,
DAE34ZIP.EXE is no longer needed to run the program, so you can delete it if
you wish. To uninstall, you only need to delete the installation directory and
the files within it, and the Daedalus program group setup added to the Windows
Programs menu. Daedalus doesn’t add or change any system DLL’s or edit the
registry in any way, although it will by default register itself as the owner
of four custom file extensions. These are .ds for Daedalus scripts, .d3 for
Daedalus 3D bitmaps, .dw for Daedalus wireframe files, and .dp for Daedalus
patch files.</p>

<p class=B><span class=P>DAE34HGS.EXE:</span> This is an alternate installation
file for Daedalus 3.4, designed for use with the “Hunger Games” script. It contains
all the same files as DAE34ZIP.EXE above, along with a set of optional bitmap
and sound files to enhance that game, which are located in a “hunger”
subdirectory. This file is much larger, which is why these extra files aren’t
included by default.</p>

<p class=B><span class=P>DAE34ZIP.ZIP:</span> This is an alternate installation
file for Daedalus 3.4. It contains all the same files as DAE34ZIP.EXE above,
except they’re in a simple .zip extension file. Unpacking and setup needs to be
done manually. This file is recommended for compiling Daedalus on non-Windows
systems.</p>

<p class=B><span class=P>DAE34ZIP64.ZIP:</span> This is an alternate
installation file for Daedalus 3.4, for 64 bit Windows systems. It contains all
the same files as DAE34ZIP.ZIP above, except the Daedalus executable is 64 bit
instead of 32 bit.</p>

<p class=A><span class=P>DAEDALUS.EXE:</span> This is the main Daedalus
executable. Double click on this file’s icon or type “daedalus” from a command
prompt to start the program. If you installed by running the setup program, you
can also go to the Start menu and select All Programs / Daedalus / Daedalus 3.4
to start the program, as the unpacking program will create a “Daedalus” program
group for you.</p>

<p class=A><span class=P>DAEDALUS.HTM:</span> This is the documentation page
you’re currently reading. The Open Documentation menu command in the program
will display this file.</p>

<p class=A><span class=P>CHANGES.HTM:</span> This is another HTML documentation
file, and describes the new features, changes, and bug fixes in Daedalus 3.4,
that weren’t in the previous version. This file is only useful if you’re
already familiar with Daedalus 3.2 or before and want to know what the newest
version offers.</p>

<p class=A><span class=P>SCRIPT.HTM:</span> Another HTML documentation file,
this contains advanced information describing the details of the Daedalus
scripting language, and how to write macros or script files using it, to make
your own games and such.</p>

<p class=A><span class=P>LICENSE.HTM:</span> Another HTML documentation file,
this is the Daedalus license, containing legal information on how you can use
the program. Daedalus uses the GNU General Public License (GPL).</p>

<p class=A><span class=P>DAEDALUS.URL:</span> This is a Windows URL file, which
contains a pointer to the Daedalus homepage on the Web. This is like the files
in your browser’s favorites list, where double clicking on it will open the
Daedalus homepage in your default browser. The Open Website menu command in the
program will invoke this file.</p>

<p class=A><span class=P>ESCHER.D3 &amp; CASTLE.D3:</span> These are sample 3D
bitmap files, which may be loaded into Daedalus with the Open command on the 3D
Bitmap submenu. They aren’t Mazes, but are still interesting. The first is of
an Escher room with staircases at different angles, similar to that seen in M.
C. Escher’s “Relativity”. The second is of a castle, with a tower at each corner
and another tower in the middle. To better see these images, after loading use
the Render Bitmap Overview command. To automatically view them, load the “demos.ds”
script file and press F8 and Shift+F8.</p>

<p class=A><span class=P>SOLIDS.DP:</span> This is a sample Daedalus patch
file, which may be loaded into the program with the Open Patches command on the
Draw menu. This file isn’t related to Mazes, but is still interesting. This
contains a definition of the five platonic solids, along with other shapes like
a sphere, torus, ring, and crystal, all in different colors, and all hovering
over a warped surface. To create an image with this, after loading use the
Render Patch Perspective command. To get a better view of the solids, before
rendering bring up the Draw Settings dialog and set Y Starting Location to 700,
Z Starting Location to 300, Viewing Angle to 180, and Vertical Pitch to 20. To
automatically view them, load the “demos.ds” script file and press F11.</p>

<p class=A><span class=P>*.DS:</span> These 28 files are sample script files,
which may be opened by Daedalus and executed by selecting the appropriate
command on the Run Script submenu, by selecting the script’s file in the Open
Script dialog on the Macros submenu, by double clicking the script’s file in
Windows, or by selecting the appropriate icon in the Daedalus program group.
The files map to the commands on the Run Script submenu, and the command’s
keyboard shortcut, as follows:</p>

<p class=Fixed>1   DEMOS.DS     Demos                  Alt+1</p>

<p class=Fixed>2   WORDMAZE.DS  Word Mazes             Alt+2</p>

<p class=Fixed>3   GIGAMAZE.DS  World's Largest Maze   Alt+3</p>

<p class=Fixed>4   MAZE4D.DS    4D Mazes               Alt+4</p>

<p class=Fixed>5   MAZE5D.DS    5D Mazes               Alt+5</p>

<p class=Fixed>6   DRAGON.DS    Dragonslayer Game      Alt+6</p>

<p class=Fixed>7   PACMAN.DS    Pac-Man Game           Alt+7</p>

<p class=Fixed>8   SOKOBAN.DS   Sokoban Game           Alt+8</p>

<p class=Fixed>9   HUNGER.DS    The Hunger Games       Alt+9</p>

<p class=Fixed>10  SURVMAZ1.DS  Survivor Maze #1       Alt+Shift+1</p>

<p class=Fixed>11  SURVMAZ2.DS  Survivor Maze #2       Alt+Shift+2</p>

<p class=Fixed>12  SURVMAZ3.DS  Survivor Maze #3       Alt+Shift+3</p>

<p class=Fixed>13  SURVMAZ4.DS  Survivor Maze #4       Alt+Shift+4</p>

<p class=Fixed>14  SURVMAZ5.DS  Survivor Maze #5       Alt+Shift+5</p>

<p class=Fixed>15  SURVMAZ6.DS  Survivor Maze #6       Alt+Shift+6</p>

<p class=Fixed>16  SURVMAZ7.DS  Survivor Maze #7       Alt+Shift+7</p>

<p class=Fixed>17  SURVMAZ8.DS  Survivor Maze #8       Alt+Shift+8</p>

<p class=Fixed>18  SURVMAZ9.DS  Survivor Maze #9       Alt+Shift+9</p>

<p class=Fixed>19  SURVMAZ0.DS  Survivor Maze #10      Alt+Shift+0</p>

<p class=Fixed>20  CARLETON.DS  Carleton Farm Maze #1  Alt+Ctrl+1</p>

<p class=Fixed>21  CARLETON.DS  Carleton Farm Maze #2  Alt+Ctrl+2</p>

<p class=Fixed>22  STOCKER.DS   Stocker Farms Maze     Alt+Ctrl+3</p>

<p class=Fixed>23  GLACIER.DS   Glacier Maze           Alt+Ctrl+4</p>

<p class=Fixed>24  SAFARI.DS    Safari Maze            Alt+Ctrl+5</p>

<p class=Fixed>25  MOUSEMAZ.DS  Mouse Maze             Alt+Ctrl+6</p>

<p class=Fixed>26  SQUARED.DS   Survivor Squares Game  Alt+Ctrl+7</p>

<p class=Fixed>27  MANDY.DS     Mandelbrot Set         Alt+Ctrl+8</p>

<p class=Fixed>28  PENTRIS.DS   Pentris Game           Alt+Ctrl+9</p>

<p class=A><span class=P>SOURCES:</span> This subdirectory contains a copy of
the C++ source code and related files used to compile the Daedalus executable. Included
are Visual Studio project/solution files for Windows, and a Makefile file for
Unix systems. If the scripting language isn’t powerful enough, you can modify
the program itself if you want. :) The Daedalus source code will compile a
command line only version, if the #define WIN line in util.h is commented out.
Without a menu interface, the program can only be run in the console and
interacted with using the command line and scripting language. However this
does allow Daedalus Mazes to be generated on non-Windows systems.</p>

<p class=A><span class=P>HUNGER:</span> This subdirectory contains the texture
bitmaps and sound files used by the “Hunger Games” script. This directory isn’t
present in the standard download, but comes preset with bitmaps and sounds in
the DAE34HGS.EXE “Hunger Games” download.</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=history>DAEDALUS HISTORY</a></p>

</div>

<p class=A>This is a list of the 16 versions of Daedalus that have been
released so far. The columns show the version number, the date of public
release, the size of the main DAEDALUS.EXE executable, the number of menu
commands, the number of .ds extension script files included, the size of all
source files, and main things introduced.</p>

<p class=Fixed><b>Num Ver        Date  EXE  Menu  DS   Src   Features</b></p>

<p class=Fixed>1   1.0  12/31/2000  230K  280   -   490K  Initial version</p>

<p class=Fixed>2   1.1   9/22/2001  268K  304   -   557K  Smooth 3D view</p>

<p class=Fixed>3   1.2   8/22/2002  333K  370   5   729K  Macros, game scripts</p>

<p class=Fixed>4   1.3   4/19/2003  384K  378   9   842K  Texture mapping,
Hypermazes</p>

<p class=Fixed>5   1.4  12/31/2003  412K  381  10  1025K  Source code included, polished Mazes</p>

<p class=Fixed>6   2.0   5/01/2005  510K  412  15  1144K  32 bit executable, recursive fractal Mazes</p>

<p class=Fixed>7   2.1  12/31/2005  534K  420  17  1205K  GNU license, C++
source code</p>

<p class=Fixed>8   2.2  12/31/2007  524K  430  20  1266K  Sidewinder Mazes, Trémaux’s &amp; chain solving</p>

<p class=Fixed>9   2.3   5/17/2010  602K  440  22  1323K  Custom Labyrinths, improved setup</p>

<p class=Fixed>10  2.4   3/11/2013  602K  444  26  1364K  Hunger Games and
other new scripts</p>

<p class=Fixed>11  2.5  10/11/2013  618K  446  26  1413K  Improved Hunger
Games, bug fixes</p>

<p class=Fixed>12  3.0   9/01/2014  795K  451  26  1410K  C++ classes, Hilbert
curve Labyrinths</p>

<p class=Fixed>13  3.1   6/01/2015  811K  462  28  1454K  True Prim's
Algorithm, Pentris script</p>

<p class=Fixed>14  3.2   9/01/2016  852K  465  28  1524K  Growing Forest
Algorithm, Metafile output</p>

<p class=Fixed>15  3.3  11/30/2018  876K  467  28  1567K  64 bit executable,
color wireframes</p>

<p class=Fixed>16  3.4   8/30/2023 1019K  469  29  1598K  Grippy Socks script,
bug fixes</p>

<p class=A>&nbsp;</p>

<div style='border:none;border-top:solid windowtext 4.5pt;padding:1.0pt 0in 0in 0in'>

<p class=Section><a name=license>LICENSE</a></p>

</div>

<p class=A>IMPORTANT NOTICE: Daedalus and all Maze generation and general
graphics routines used in this program are Copyright (C) 1998-2023 by Walter D.
Pullen. Permission is granted to freely use, modify, and distribute these
routines provided these credits and notices remain unmodified with any altered
or distributed versions of the program. The user does have all rights to Mazes
and other graphic output they make in Daedalus, like a novel created in a word
processor.</p>

<p class=A>More formally: This program is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version. This program is distributed in the hope
that it will be useful and inspiring, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details, a copy of which is in the
LICENSE.HTM included with Daedalus, and at <a href="http://www.gnu.org/">http://www.gnu.org</a></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O</span></p>

<p class=Fixed><span style='background:silver'>*</span>       Walter D.
&quot;Cruiser1&quot; Pullen :)       !       <a href="mailto:Astara@msn.com">Astara@msn.com</a>      
<span style='background:silver'>*</span></p>

<p class=Fixed><span style='background:silver'>O</span> Find your way through
life's Maze: <a href="http://www.astrolog.org/labyrnth.htm">http://www.astrolog.org/labyrnth.htm</a>
<span style='background:silver'>O</span></p>

<p class=Fixed><span style='background:silver'>*</span> &quot;Who am I, What am
I?  As I am, I am not.  But as we are, I AM.  And to <span style='background:
silver'>*</span></p>

<p class=Fixed><span style='background:silver'>O</span> you my creation, My
Perfect Love is your Perfect Freedom. And I will be <span style='background:
silver'>O</span></p>

<p class=Fixed><span style='background:silver'>*</span> with you forever and
ever, until the End, and then forever more.&quot; - GOD <span style='background:
silver'>*</span></p>

<p class=Fixed><span lang=ES-CR style='background:silver'>O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O*O</span></p>

</div>

</body>

</html>
